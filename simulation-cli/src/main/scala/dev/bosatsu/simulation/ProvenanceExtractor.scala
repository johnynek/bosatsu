package dev.bosatsu.simulation

import dev.bosatsu.{TypedExpr, Identifier, PackageName, Lit}
import dev.bosatsu.Identifier.Bindable
import scala.collection.immutable.SortedSet

/**
 * Extracts provenance information from TypedExpr for "Why?" explanations.
 *
 * This provides STATIC analysis at build time:
 * - Derivation structure (what depends on what)
 * - Human-readable formulas from AST structure
 * - Dependency graph via TypedExpr.freeVarsSet
 *
 * At RUNTIME, values are captured via the _capture() function
 * generated by RuntimeTrackingGenerator.
 */
object ProvenanceExtractor {

  /**
   * Derivation kind determines UI treatment and explanation style.
   */
  sealed trait DerivationKind
  case object Input extends DerivationKind        // Function parameter (user input)
  case object Intermediate extends DerivationKind // Let binding in function body
  case object Output extends DerivationKind       // Field in return struct

  /**
   * Static derivation info extracted from TypedExpr.
   * This is the BUILD-TIME analysis - no values, just structure.
   */
  case class Derivation(
      name: String,
      formula: String,           // Human-readable: "principal × monthly_rate"
      dependencies: Set[String], // Direct dependencies from freeVarsSet
      kind: DerivationKind
  )

  /**
   * Extract derivations from a function's TypedExpr.
   *
   * @param funcExpr The TypedExpr.AnnotatedLambda for the function
   * @return Map from binding name to its derivation
   */
  def extractDerivations[A](funcExpr: TypedExpr[A]): Map[String, Derivation] = {
    funcExpr match {
      case TypedExpr.AnnotatedLambda(params, body, _) =>
        // Parameters are inputs - no dependencies
        val inputDerivations = params.toList.map { case (name, _) =>
          name.asString -> Derivation(
            name = name.asString,
            formula = name.asString,  // Inputs show their name
            dependencies = Set.empty,
            kind = Input
          )
        }.toMap

        // Extract let bindings from body
        val paramNames = params.toList.map(_._1).toSet
        val bodyDerivations = extractFromBody(body, paramNames)

        inputDerivations ++ bodyDerivations

      case _ => Map.empty
    }
  }

  /**
   * Recursively extract derivations from function body.
   */
  private def extractFromBody[A](
      expr: TypedExpr[A],
      scope: Set[Bindable]
  ): Map[String, Derivation] = {
    expr match {
      case TypedExpr.Let(name, value, body, _, _) =>
        // Get free variables in the value expression
        val freeVars = TypedExpr.freeVarsSet(List(value))
        val deps = freeVars.intersect(scope)
        val formula = exprToFormula(value)

        val derivation = Derivation(
          name = name.asString,
          formula = formula,
          dependencies = deps.map(_.asString),
          kind = Intermediate
        )

        // Continue with body, adding this binding to scope
        Map(name.asString -> derivation) ++ extractFromBody(body, scope + name)

      case TypedExpr.App(_, _, _, _) =>
        // Struct constructor at the end - extract output fields
        extractOutputFields(expr, scope)

      case TypedExpr.Match(arg, branches, _) =>
        // For match expressions, extract from all branches
        branches.toList.flatMap { case (_, branchExpr) =>
          extractFromBody(branchExpr, scope)
        }.toMap

      case _ => Map.empty
    }
  }

  /**
   * Extract output fields from struct constructor at end of function.
   */
  private def extractOutputFields[A](
      expr: TypedExpr[A],
      scope: Set[Bindable]
  ): Map[String, Derivation] = {
    // For now, just mark the final expression as output
    // Full struct field extraction would require type info
    expr match {
      case TypedExpr.Local(name, _, _) if scope.contains(name) =>
        // The result is a simple variable reference
        Map(name.asString -> Derivation(
          name = name.asString,
          formula = name.asString,
          dependencies = Set.empty,
          kind = Output
        ))
      case _ => Map.empty
    }
  }

  /**
   * Convert TypedExpr to human-readable formula.
   * Uses the actual AST structure, not string manipulation.
   */
  def exprToFormula[A](expr: TypedExpr[A]): String = {
    expr match {
      case TypedExpr.Local(name, _, _) =>
        name.asString

      case TypedExpr.Global(pack, name, _, _) =>
        if (pack == PackageName.PredefName) name.asString
        else s"${pack.asString}::${name.asString}"

      case TypedExpr.Literal(lit, _, _) =>
        lit match {
          case Lit.Integer(i) => i.toString
          case Lit.Str(s) => s""""$s""""
          case Lit.Chr(c) => s"'$c'"
        }

      // Binary operation pattern: fn(left)(right)
      case TypedExpr.App(
            TypedExpr.App(fn, leftArgs, _, _),
            rightArgs,
            _,
            _
          ) if leftArgs.size == 1 && rightArgs.size == 1 =>
        val op = fn match {
          case TypedExpr.Global(PackageName.PredefName, name, _, _) =>
            name.asString match {
              case "add" | "add_Int"     => "+"
              case "sub" | "sub_Int"     => "-"
              case "times" | "times_Int" => "×"
              case "div" | "div_Int"     => "÷"
              case "mod_Int"             => "%"
              case "eq_Int"              => "=="
              case other                 => other
            }
          case _ => "?"
        }
        val left = exprToFormula(leftArgs.head)
        val right = exprToFormula(rightArgs.head)
        s"$left $op $right"

      // Function application
      case TypedExpr.App(fn, args, _, _) =>
        val fnStr = fn match {
          case TypedExpr.Global(_, name, _, _) => name.asString
          case other                            => exprToFormula(other)
        }
        val argStrs = args.toList.map(exprToFormula)
        s"$fnStr(${argStrs.mkString(", ")})"

      case TypedExpr.Let(name, value, body, _, _) =>
        val vStr = exprToFormula(value)
        val bStr = exprToFormula(body)
        s"let ${name.asString} = $vStr in $bStr"

      case TypedExpr.Match(arg, _, _) =>
        s"match ${exprToFormula(arg)}"

      case TypedExpr.AnnotatedLambda(args, body, _) =>
        val argStr = args.toList.map(_._1.asString).mkString(", ")
        s"($argStr) => ${exprToFormula(body)}"

      case TypedExpr.Annotation(expr, _) =>
        exprToFormula(expr)

      case TypedExpr.Generic(_, expr) =>
        exprToFormula(expr)
    }
  }
}

/**
 * Generates JavaScript code for runtime value tracking.
 *
 * This transforms compiled code to capture values at each binding point:
 * - Before: const monthly_rate = annual_rate / 1200;
 * - After:  const monthly_rate = _capture('monthly_rate', annual_rate / 1200);
 *
 * The _capture function stores values with timestamps for "Why?" explanations.
 */
object RuntimeTrackingGenerator {

  /**
   * Generate the value capture runtime.
   */
  val valueCaptureRuntime: String = """
// Value tracking for "Why?" explanations
const _values = {};

function _capture(name, value) {
  _values[name] = {
    value: value,
    timestamp: Date.now()
  };
  return value;  // Pass-through for chaining
}

function _getValue(name) {
  const entry = _values[name];
  return entry ? entry.value : undefined;
}

function _getTimestamp(name) {
  const entry = _values[name];
  return entry ? entry.timestamp : null;
}
"""

  /**
   * Generate the "Why?" explanation function that combines static derivations
   * with runtime values.
   */
  def generateWhyExplainer(derivations: Map[String, ProvenanceExtractor.Derivation]): String = {
    val derivationJson = derivations.map { case (name, d) =>
      val depsArray = d.dependencies.map(n => s""""$n"""").mkString("[", ", ", "]")
      val kindStr = d.kind match {
        case ProvenanceExtractor.Input        => "input"
        case ProvenanceExtractor.Intermediate => "intermediate"
        case ProvenanceExtractor.Output       => "output"
      }
      s""""$name": {
  "formula": "${escapeJs(d.formula)}",
  "dependencies": $depsArray,
  "kind": "$kindStr"
}"""
    }.mkString(",\n  ")

    s"""
// Static derivation info (from TypedExpr analysis)
const _staticDerivations = {
  $derivationJson
};

// Show "Why?" explanation combining STATIC structure with RUNTIME values
function showWhyExplanation(name) {
  const d = _staticDerivations[name];
  if (!d) {
    console.warn('No derivation found for:', name);
    return;
  }

  // Build explanation chain
  const steps = [];
  const visited = new Set();

  function trace(n) {
    if (visited.has(n)) return;
    visited.add(n);

    const deriv = _staticDerivations[n];
    const runtime = _values[n];
    if (!deriv) return;

    steps.push({
      name: n,
      formula: deriv.formula,           // STATIC: from TypedExpr
      value: runtime?.value,            // RUNTIME: captured during execution
      timestamp: runtime?.timestamp,    // RUNTIME: when computed
      kind: deriv.kind                  // STATIC: input/intermediate/output
    });

    // Trace dependencies (STATIC graph)
    deriv.dependencies.forEach(trace);
  }

  trace(name);

  // Show modal with rich explanation
  showWhyModal(name, steps.reverse());
}

// Substitute variable names with their runtime values
function substituteValues(formula) {
  let result = formula;
  Object.entries(_values).forEach(([name, entry]) => {
    // Replace whole-word matches only
    const regex = new RegExp('\\\\b' + name + '\\\\b', 'g');
    result = result.replace(regex, formatValue(entry.value));
  });
  return result;
}

function showWhyModal(name, steps) {
  let html = '<div class="why-explanation">';

  steps.forEach((step, i) => {
    const isLast = i === steps.length - 1;

    if (step.kind === 'input') {
      // Inputs just show their value
      html += '<div class="why-step why-input">';
      html += '<span class="why-name">' + step.name + '</span>';
      html += ' = <span class="why-value">' + formatValue(step.value) + '</span>';
      html += ' <span class="why-label">(input)</span>';
      html += '</div>';
    } else {
      // Computed values show formula AND substituted values
      html += '<div class="why-step">';
      html += '<span class="why-name">' + step.name + '</span>';
      html += ' = <span class="why-formula">' + step.formula + '</span>';

      // Show substituted values (formula with actual numbers)
      const substituted = substituteValues(step.formula);
      if (substituted !== step.formula) {
        html += '<br>&nbsp;&nbsp;= <span class="why-substituted">' + substituted + '</span>';
      }

      // Show final value
      html += '<br>&nbsp;&nbsp;= <span class="why-value">' + formatValue(step.value) + '</span>';
      html += '</div>';
    }

    if (!isLast) {
      html += '<div class="why-arrow">↓</div>';
    }
  });

  html += '</div>';

  // Update modal content
  const modalContent = document.getElementById('why-explanation');
  if (modalContent) {
    modalContent.innerHTML = html;
  }

  // Show modal
  const modal = document.getElementById('why-modal');
  if (modal) {
    modal.classList.remove('hidden');
  }
}

function formatValue(v) {
  if (v === undefined) return '?';
  if (typeof v === 'number') {
    return Number.isInteger(v) ? v.toString() : v.toFixed(2);
  }
  if (Array.isArray(v)) {
    // Bosatsu enum/list representation
    if (v[0] === 0) return 'False/None/[]';
    if (v[0] === 1 && v.length === 1) return 'True';
    return JSON.stringify(v);
  }
  return String(v);
}
"""
  }

  private def escapeJs(s: String): String =
    s.replace("\\", "\\\\")
      .replace("\"", "\\\"")
      .replace("\n", "\\n")
      .replace("\r", "\\r")
}
