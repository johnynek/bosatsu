<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BosatsuUI vs React Performance Benchmark</title>
    <!-- Real React 18 -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <style>
      * {
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      body {
        max-width: 1000px;
        margin: 40px auto;
        padding: 20px;
        background: #f5f5f5;
      }
      h1 {
        color: #333;
        margin-bottom: 8px;
      }
      .subtitle {
        color: #666;
        margin-bottom: 24px;
      }
      .card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 16px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      h2 {
        margin: 0 0 16px 0;
        color: #333;
        font-size: 18px;
      }
      h3 {
        margin: 16px 0 8px 0;
        color: #666;
        font-size: 14px;
      }
      button {
        background: #4a90d9;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        margin-right: 8px;
        margin-bottom: 8px;
      }
      button:hover {
        background: #357abd;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .benchmark-area {
        display: none;
      }
      .progress {
        color: #666;
        font-style: italic;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 16px 0;
      }
      th,
      td {
        padding: 8px 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background: #f0f0f0;
        font-weight: 600;
      }
      .faster {
        color: #2e7d32;
        font-weight: bold;
      }
      .slower {
        color: #c62828;
      }
      .speedup {
        background: #e8f5e9;
        padding: 16px;
        border-radius: 6px;
        margin-top: 16px;
      }
      .speedup h3 {
        margin-top: 0;
        color: #2e7d32;
      }
      .explainer {
        background: #fff3e0;
        padding: 16px;
        border-radius: 6px;
        margin-bottom: 16px;
      }
      .explainer h3 {
        margin-top: 0;
        color: #e65100;
      }
      .explainer code {
        background: #ffe0b2;
        padding: 2px 6px;
        border-radius: 3px;
      }
      .warning {
        background: #fff8e1;
        border: 1px solid #ffc107;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 16px;
      }
      .warning strong {
        color: #f57c00;
      }
    </style>
  </head>
  <body>
    <h1>BosatsuUI vs React Performance Benchmark</h1>
    <p class="subtitle">Comparing direct DOM binding updates vs Virtual DOM diffing</p>

    <div class="warning">
      <strong>Fair Benchmark:</strong> This benchmark uses actual React 18 (ReactDOM.createRoot, useState) -
      not a simulation. Both frameworks perform real DOM updates. Run multiple times for consistent results.
    </div>

    <div class="card explainer">
      <h3>How BosatsuUI Works (No Virtual DOM!)</h3>
      <p>
        BosatsuUI uses <strong>compile-time static analysis</strong> to extract
        <code>statePath -> DOMProperty</code> bindings. When state changes:
      </p>
      <ol>
        <li>Look up bindings for the changed state path (O(1) map lookup)</li>
        <li>Apply <code>element.property = value</code> directly (O(1) per binding)</li>
        <li>No virtual DOM creation, no tree diffing, no reconciliation</li>
      </ol>
      <p>
        <strong>React approach:</strong> Create new virtual DOM tree -> Diff against old tree
        -> Generate patches -> Apply patches. This is O(n) where n is component tree size.
      </p>
    </div>

    <div class="card">
      <h2>Benchmark Controls</h2>
      <button id="run-all" onclick="runAllBenchmarks()">Run All Benchmarks</button>
      <button id="run-single" onclick="runSingleBenchmark()">Single Updates</button>
      <button id="run-list" onclick="runListBenchmark()">List Updates (100 items)</button>
      <button id="run-targeted" onclick="runTargetedBenchmark()">Targeted Updates</button>
      <p class="progress" id="progress"></p>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div id="results">Click a button above to run benchmarks</div>
    </div>

    <!-- Hidden benchmark areas -->
    <div id="bosatsu-root" class="benchmark-area"></div>
    <div id="react-root" class="benchmark-area"></div>

    <script>
      // =========================================================================
      // BosatsuUI Runtime (matching bosatsu-ui-runtime.js)
      // =========================================================================

      class BosatsuRuntime {
        constructor(bindings, root) {
          this.bindings = bindings
          this.root = root
          this.state = {}
          this.bindingMap = new Map()
          this.elementCache = new Map()

          // Build binding map: statePath (as string) -> bindings[]
          bindings.forEach((b) => {
            const key = b.statePath.join('.')
            const existing = this.bindingMap.get(key) || []
            this.bindingMap.set(key, [...existing, b])
          })
        }

        mount(initialState) {
          this.state = initialState
        }

        setState(path, value) {
          // Update state
          this.state = this.setAtPath(this.state, path, value)
          // Apply bindings directly - O(1) lookup, O(1) update per binding
          this.applyBindingsForPath(path)
        }

        applyBindingsForPath(path) {
          const key = path.join('.')
          const bindings = this.bindingMap.get(key) || []

          bindings.forEach((binding) => {
            // Use element cache for O(1) lookup
            let element = this.elementCache.get(binding.elementId)
            if (!element) {
              element = this.root.querySelector(`#${binding.elementId}`)
              if (element) this.elementCache.set(binding.elementId, element)
            }

            if (element) {
              const newValue = this.getAtPath(this.state, binding.statePath || path)
              element.textContent = String(newValue)
            }
          })
        }

        getAtPath(obj, path) {
          return path.reduce((o, k) => o?.[k], obj)
        }

        setAtPath(obj, path, value) {
          if (path.length === 0) return value
          const [first, ...rest] = path
          return {
            ...obj,
            [first]: rest.length === 0 ? value : this.setAtPath(obj[first] || {}, rest, value),
          }
        }
      }

      // =========================================================================
      // Real React 18 Counter Component
      // =========================================================================

      // We use the global React and ReactDOM loaded from CDN
      const { useState, useCallback, memo } = React

      // Counter component for single update test
      function ReactCounter() {
        const [count, setCount] = useState(0)

        // Expose setter globally for benchmark
        window._reactSetCount = setCount

        return React.createElement('div', { id: 'react-counter-app' },
          React.createElement('span', { id: 'react-count' }, count)
        )
      }

      // List item component (memoized for fair comparison)
      const ListItem = memo(function ListItem({ id, value }) {
        return React.createElement('li', { id: `react-item-${id}` }, value)
      })

      // List component for list update test
      function ReactList({ size }) {
        const [items, setItems] = useState(() =>
          Array.from({ length: size }, (_, i) => i)
        )

        // Expose setter globally for benchmark
        window._reactSetItems = setItems
        window._reactItems = items

        return React.createElement('ul', { id: 'react-list' },
          items.map((value, i) =>
            React.createElement(ListItem, { key: i, id: i, value })
          )
        )
      }

      // Targeted update component (10 separate values)
      function ReactTargeted() {
        const keys = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']
        const [values, setValues] = useState(() =>
          Object.fromEntries(keys.map(k => [k, 0]))
        )

        // Expose setter globally for benchmark
        window._reactSetValues = setValues

        return React.createElement('div', { id: 'react-targeted-app' },
          keys.map(k =>
            React.createElement('div', { key: k, id: `react-section-${k}` },
              React.createElement('span', { id: `react-value-${k}` }, values[k])
            )
          )
        )
      }

      // =========================================================================
      // Benchmark Utilities
      // =========================================================================

      async function runThroughputBenchmark(name, durationMs, setupFn, updateFn) {
        // Allow React to settle
        await new Promise(r => setTimeout(r, 50))

        let ops = 0

        // Warmup
        for (let i = 0; i < 100; i++) {
          updateFn(i)
        }
        // Let React flush
        await new Promise(r => setTimeout(r, 50))

        const benchStart = performance.now()
        while (performance.now() - benchStart < durationMs) {
          updateFn(ops)
          ops++
        }
        const elapsed = performance.now() - benchStart

        // Let React flush final updates
        await new Promise(r => setTimeout(r, 50))

        const opsPerSec = (ops / elapsed) * 1000
        const avgMs = elapsed / ops

        return {
          name,
          iterations: ops,
          totalMs: elapsed,
          avgMs,
          opsPerSec,
        }
      }

      function setProgress(msg) {
        document.getElementById('progress').textContent = msg
      }

      function formatResults(results) {
        let html = '<table>'
        html +=
          '<tr><th>Framework</th><th>Avg (ms)</th><th>Ops/sec</th><th>Speedup vs React</th></tr>'

        const reactResult = results.find((r) => r.name.includes('React'))
        const reactAvg = reactResult ? reactResult.avgMs : 1

        results.forEach((r) => {
          const speedup = reactAvg / r.avgMs
          const speedupText = r.name.includes('React')
            ? '1.00x (baseline)'
            : `${speedup.toFixed(2)}x ${speedup > 1 ? 'faster' : 'slower'}`
          const cls = speedup > 1.5 ? 'faster' : speedup < 0.9 ? 'slower' : ''

          html += `<tr class="${cls}">
            <td>${r.name}</td>
            <td>${r.avgMs.toFixed(4)}</td>
            <td>${Math.round(r.opsPerSec).toLocaleString()}</td>
            <td>${speedupText}</td>
          </tr>`
        })

        html += '</table>'
        return html
      }

      // =========================================================================
      // Single Update Benchmark (uses REAL React)
      // =========================================================================

      async function runSingleBenchmark() {
        setProgress('Running single update benchmark...')
        const results = []
        const durationMs = 2000

        // Setup BosatsuUI
        const bosatsuRoot = document.getElementById('bosatsu-root')
        bosatsuRoot.innerHTML = '<div id="bosatsu-counter-app"><span id="bosatsu-count">0</span></div>'

        const bosatsu = new BosatsuRuntime(
          [{ elementId: 'bosatsu-count', property: 'textContent', statePath: ['count'] }],
          bosatsuRoot
        )
        bosatsu.mount({ count: 0 })

        results.push(
          await runThroughputBenchmark(
            'BosatsuUI (direct binding)',
            durationMs,
            null,
            (i) => bosatsu.setState(['count'], i % 10000)
          )
        )

        // Setup REAL React 18
        const reactRoot = document.getElementById('react-root')
        reactRoot.innerHTML = ''
        const root = ReactDOM.createRoot(reactRoot)
        root.render(React.createElement(ReactCounter))

        // Wait for React to mount
        await new Promise(r => setTimeout(r, 100))

        results.push(
          await runThroughputBenchmark(
            'React 18 (VDOM)',
            durationMs,
            null,
            (i) => window._reactSetCount(i % 10000)
          )
        )

        // Cleanup React
        root.unmount()

        let html = '<h3>Single Property Update</h3>'
        html += formatResults(results)
        html += `<div class="speedup">
          <h3>Why BosatsuUI is faster:</h3>
          <p>BosatsuUI looks up the binding for <code>['count']</code> and directly sets
          <code>element.textContent = value</code>. React must schedule a re-render,
          create a new VDOM tree, diff it, and apply patches.</p>
        </div>`

        document.getElementById('results').innerHTML = html
        setProgress('')
      }

      // =========================================================================
      // List Update Benchmark (uses REAL React with memo)
      // =========================================================================

      async function runListBenchmark() {
        setProgress('Running list update benchmark...')
        const results = []
        const durationMs = 2000
        const listSize = 100

        // Setup BosatsuUI with per-item bindings
        const bosatsuRoot = document.getElementById('bosatsu-root')
        let html = '<ul id="bosatsu-list">'
        for (let i = 0; i < listSize; i++) {
          html += `<li id="bosatsu-item-${i}">${i}</li>`
        }
        html += '</ul>'
        bosatsuRoot.innerHTML = html

        // Create bindings for each item
        const bindings = []
        const initialState = { items: {} }
        for (let i = 0; i < listSize; i++) {
          bindings.push({
            elementId: `bosatsu-item-${i}`,
            property: 'textContent',
            statePath: ['items', String(i)],
          })
          initialState.items[i] = i
        }

        const bosatsu = new BosatsuRuntime(bindings, bosatsuRoot)
        bosatsu.mount(initialState)

        results.push(
          await runThroughputBenchmark(
            `BosatsuUI (1 of ${listSize} items)`,
            durationMs,
            null,
            (i) => {
              const index = i % listSize
              bosatsu.setState(['items', String(index)], i % 10000)
            }
          )
        )

        // Setup REAL React 18 with memoized list items
        const reactRoot = document.getElementById('react-root')
        reactRoot.innerHTML = ''
        const root = ReactDOM.createRoot(reactRoot)
        root.render(React.createElement(ReactList, { size: listSize }))

        // Wait for React to mount
        await new Promise(r => setTimeout(r, 100))

        results.push(
          await runThroughputBenchmark(
            `React 18 (1 of ${listSize} items, memo)`,
            durationMs,
            null,
            (i) => {
              const index = i % listSize
              window._reactSetItems(prev => {
                const copy = [...prev]
                copy[index] = i % 10000
                return copy
              })
            }
          )
        )

        // Cleanup React
        root.unmount()

        let resultHtml = `<h3>List Item Update (${listSize}-item list)</h3>`
        resultHtml += formatResults(results)
        resultHtml += `<div class="speedup">
          <h3>Why BosatsuUI is faster:</h3>
          <p>BosatsuUI has a direct binding for each list item: <code>['items', '42']</code>
          maps to <code>#bosatsu-item-42.textContent</code>. Updating one item is O(1).</p>
          <p>React must create a new array, re-render the parent, and even with <code>memo()</code>
          must check each of ${listSize} children to determine which changed.</p>
        </div>`

        document.getElementById('results').innerHTML = resultHtml
        setProgress('')
      }

      // =========================================================================
      // Targeted Update Benchmark (uses REAL React)
      // =========================================================================

      async function runTargetedBenchmark() {
        setProgress('Running targeted update benchmark...')
        const results = []
        const durationMs = 2000
        const keys = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']

        // BosatsuUI - direct binding per element
        const bosatsuRoot = document.getElementById('bosatsu-root')
        bosatsuRoot.innerHTML = `<div id="bosatsu-targeted-app">${keys.map((k) =>
          `<div id="bosatsu-section-${k}"><span id="bosatsu-value-${k}">0</span></div>`
        ).join('')}</div>`

        const bindings = keys.map((k) => ({
          elementId: `bosatsu-value-${k}`,
          property: 'textContent',
          statePath: [k],
        }))
        const initialState = Object.fromEntries(keys.map((k) => [k, 0]))

        const bosatsu = new BosatsuRuntime(bindings, bosatsuRoot)
        bosatsu.mount(initialState)

        results.push(
          await runThroughputBenchmark(
            'BosatsuUI (1 of 10 elements)',
            durationMs,
            null,
            (i) => {
              const key = keys[i % keys.length]
              bosatsu.setState([key], i % 10000)
            }
          )
        )

        // Setup REAL React 18
        const reactRoot = document.getElementById('react-root')
        reactRoot.innerHTML = ''
        const root = ReactDOM.createRoot(reactRoot)
        root.render(React.createElement(ReactTargeted))

        // Wait for React to mount
        await new Promise(r => setTimeout(r, 100))

        results.push(
          await runThroughputBenchmark(
            'React 18 (1 of 10 elements)',
            durationMs,
            null,
            (i) => {
              const key = keys[i % keys.length]
              window._reactSetValues(prev => ({ ...prev, [key]: i % 10000 }))
            }
          )
        )

        // Cleanup React
        root.unmount()

        let html = '<h3>Targeted Update (update 1 element in 10-element tree)</h3>'
        html += formatResults(results)
        html += `<div class="speedup">
          <h3>Why BosatsuUI excels at targeted updates:</h3>
          <p>This is BosatsuUI's sweet spot. Updating state path <code>['c']</code>
          triggers a direct O(1) lookup and update of <code>#bosatsu-value-c.textContent</code>.</p>
          <p>React must re-render the parent component and reconcile all 10 children,
          even though only one value changed.</p>
        </div>`

        document.getElementById('results').innerHTML = html
        setProgress('')
      }

      // =========================================================================
      // Run All Benchmarks
      // =========================================================================

      async function runAllBenchmarks() {
        const buttons = document.querySelectorAll('button')
        buttons.forEach((b) => (b.disabled = true))

        document.getElementById('results').innerHTML = '<p>Running benchmarks... this may take a while.</p>'

        await runSingleBenchmark()
        await new Promise((r) => setTimeout(r, 500))

        await runListBenchmark()
        await new Promise((r) => setTimeout(r, 500))

        await runTargetedBenchmark()

        buttons.forEach((b) => (b.disabled = false))
        setProgress('All benchmarks complete!')
      }
    </script>
  </body>
</html>
