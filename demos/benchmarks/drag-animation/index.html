<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BosatsuUI vs React: Particle Animation Benchmark</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0b0b14 0%, #1a1a2e 50%, #16213e 100%);
      color: #f2f4ff;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    header { text-align: center; margin-bottom: 30px; }
    h1 {
      font-size: 32px;
      font-weight: 800;
      margin-bottom: 12px;
      background: linear-gradient(135deg, #f2683c 0%, #ffd700 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .subtitle { color: #9aa0d4; font-size: 16px; line-height: 1.6; max-width: 800px; margin: 0 auto; }

    .methodology {
      background: rgba(242, 104, 60, 0.1);
      border: 1px solid rgba(242, 104, 60, 0.3);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
    }
    .methodology h3 { color: #f2683c; margin-bottom: 12px; font-size: 16px; }
    .methodology p { color: #f2f4ff; font-size: 14px; line-height: 1.6; margin-bottom: 8px; }
    .methodology code {
      background: rgba(0,0,0,0.3);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'SF Mono', Consolas, monospace;
      color: #6ee7b7;
    }

    .controls {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
    }
    .control-group { display: flex; flex-direction: column; gap: 4px; }
    .control-group label { font-size: 12px; color: #9aa0d4; }
    .control-group input, .control-group select {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 8px 12px;
      color: #f2f4ff;
      font-size: 14px;
    }
    button {
      background: linear-gradient(135deg, #f2683c, #ff8c42);
      border: none;
      border-radius: 8px;
      padding: 12px 24px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s;
    }
    button:hover { transform: scale(1.02); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .benchmark-area {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 24px;
    }
    .panel {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      overflow: hidden;
    }
    .panel-header {
      padding: 16px 20px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .panel-header h2 { font-size: 18px; font-weight: 600; }
    .panel-header .fps {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 24px;
      font-weight: bold;
    }
    .panel-header .fps.good { color: #6ee7b7; }
    .panel-header .fps.ok { color: #fcd34d; }
    .panel-header .fps.bad { color: #f87171; }
    .particle-container {
      height: 400px;
      position: relative;
      overflow: hidden;
      background: rgba(0,0,0,0.2);
    }
    .particle {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      transition: none;
    }
    .bosatsu-particle { background: linear-gradient(135deg, #f2683c, #ff8c42); box-shadow: 0 0 8px rgba(242, 104, 60, 0.5); }
    .react-particle { background: linear-gradient(135deg, #61dafb, #21a1c4); box-shadow: 0 0 8px rgba(97, 218, 251, 0.5); }

    .results {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
    }
    .results h3 { margin-bottom: 16px; font-size: 18px; }
    .result-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }
    .result-card {
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 16px;
      text-align: center;
    }
    .result-card .label { color: #9aa0d4; font-size: 12px; margin-bottom: 4px; }
    .result-card .value { font-size: 24px; font-weight: bold; }
    .result-card .unit { font-size: 12px; color: #9aa0d4; }

    .code-section {
      background: rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 20px;
      margin-top: 24px;
    }
    .code-section h3 { margin-bottom: 16px; font-size: 18px; }
    .code-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .code-tab {
      padding: 8px 16px;
      background: rgba(255,255,255,0.1);
      border: none;
      border-radius: 6px;
      color: #9aa0d4;
      cursor: pointer;
      font-size: 14px;
    }
    .code-tab.active {
      background: linear-gradient(135deg, #f2683c, #ff8c42);
      color: white;
    }
    .code-block {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 13px;
      line-height: 1.6;
      display: none;
    }
    .code-block.active { display: block; }
    .code-block .comment { color: #9aa0d4; }
    .code-block .keyword { color: #93c5fd; }
    .code-block .string { color: #f472b6; }
    .code-block .function { color: #6ee7b7; }
    .code-block .number { color: #fcd34d; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Particle Animation Benchmark</h1>
      <p class="subtitle">
        Comparing BosatsuUI's O(1) direct DOM binding updates vs React's Virtual DOM diffing.
        Each particle position is updated every frame with random noise.
      </p>
    </header>

    <div class="methodology">
      <h3>How This Benchmark Works</h3>
      <p>
        <strong>BosatsuUI:</strong> Each particle has a <code>style.transform</code> binding. When position changes,
        we do <code>O(1)</code> map lookup to find the element, then direct <code>element.style.transform = value</code> assignment.
        No tree comparison, no diffing. This is the same mechanism used by compiled Bosatsu UI code (see <code>demos/ui/counter.bosatsu</code>).
      </p>
      <p>
        <strong>React:</strong> Position state is held in a single state object. Each frame, <code>setState()</code> triggers
        a full component tree comparison and reconciliation, even though only particle positions changed.
      </p>
      <p>
        <strong>Randomness:</strong> Seeded PRNG (Mulberry32) ensures both frameworks process identical particle movements.
        The noise parameter adds unpredictable jitter that prevents optimization.
      </p>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>Particles</label>
        <select id="particleCount">
          <option value="10">10 particles</option>
          <option value="25">25 particles</option>
          <option value="50" selected>50 particles</option>
          <option value="100">100 particles</option>
          <option value="200">200 particles</option>
          <option value="500">500 particles</option>
        </select>
      </div>
      <div class="control-group">
        <label>Physics Noise</label>
        <input type="range" id="noiseLevel" min="0" max="100" value="50" style="width: 120px;">
      </div>
      <div class="control-group">
        <label>Duration (seconds)</label>
        <input type="number" id="duration" value="5" min="1" max="30" style="width: 80px;">
      </div>
      <div class="control-group">
        <label>Random Seed</label>
        <input type="number" id="seed" value="12345" style="width: 100px;">
      </div>
      <button id="runBenchmark">Run Benchmark</button>
      <button id="stopBenchmark" disabled>Stop</button>
    </div>

    <div class="benchmark-area">
      <div class="panel">
        <div class="panel-header">
          <h2>BosatsuUI (Direct Binding)</h2>
          <span class="fps good" id="bosatsuFps">-- FPS</span>
        </div>
        <div class="particle-container" id="bosatsuContainer"></div>
      </div>
      <div class="panel">
        <div class="panel-header">
          <h2>React (Virtual DOM)</h2>
          <span class="fps good" id="reactFps">-- FPS</span>
        </div>
        <div class="particle-container" id="reactContainer"></div>
      </div>
    </div>

    <div class="results">
      <h3>Results</h3>
      <div class="result-grid">
        <div class="result-card">
          <div class="label">BosatsuUI Average</div>
          <div class="value" id="bosatsuAvg">--</div>
          <div class="unit">FPS</div>
        </div>
        <div class="result-card">
          <div class="label">React Average</div>
          <div class="value" id="reactAvg">--</div>
          <div class="unit">FPS</div>
        </div>
        <div class="result-card">
          <div class="label">Performance Ratio</div>
          <div class="value" id="ratio">--</div>
          <div class="unit">x faster</div>
        </div>
        <div class="result-card">
          <div class="label">Total Frames</div>
          <div class="value" id="totalFrames">--</div>
          <div class="unit">frames</div>
        </div>
      </div>
    </div>

    <div class="code-section">
      <h3>Implementation Code</h3>
      <div class="code-tabs">
        <button class="code-tab active" data-tab="bosatsu">BosatsuUI Approach</button>
        <button class="code-tab" data-tab="react">React Approach</button>
        <button class="code-tab" data-tab="physics">Physics Engine</button>
      </div>
      <pre class="code-block active" id="bosatsu-code"><span class="comment">// BosatsuUI: Compile-time binding extraction</span>
<span class="comment">// In production, UIAnalyzer extracts these from .bosatsu source</span>
<span class="comment">// See demos/ui/counter.bosatsu + counter.html for real compiled example</span>

<span class="comment">// 1. Create binding map (simulates compile-time extraction)</span>
<span class="keyword">const</span> bindings = {};
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < particleCount; i++) {
  bindings[<span class="string">`p${i}_transform`</span>] = [{
    elementId: <span class="string">`bosatsu-p-${i}`</span>,
    property: <span class="string">'style.transform'</span>
  }];
}

<span class="comment">// 2. O(1) state update - direct binding lookup</span>
<span class="keyword">function</span> <span class="function">updateParticle</span>(index, x, y) {
  <span class="keyword">const</span> key = <span class="string">`p${index}_transform`</span>;
  <span class="keyword">const</span> binding = bindings[key][<span class="number">0</span>];  <span class="comment">// O(1) lookup</span>
  <span class="keyword">const</span> el = elementCache[binding.elementId];
  el.style.transform = <span class="string">`translate(${x}px, ${y}px)`</span>;
}

<span class="comment">// No virtual DOM, no diffing, no reconciliation</span>
<span class="comment">// Just: lookup binding â†’ update DOM property</span></pre>
      <pre class="code-block" id="react-code"><span class="comment">// React: Virtual DOM reconciliation</span>

<span class="keyword">function</span> <span class="function">ParticleSystem</span>({ particles }) {
  <span class="keyword">return</span> (
    &lt;div className=<span class="string">"particle-container"</span>&gt;
      {particles.<span class="function">map</span>((p, i) =&gt; (
        &lt;div
          key={i}
          className=<span class="string">"particle react-particle"</span>
          style={{ transform: <span class="string">`translate(${p.x}px, ${p.y}px)`</span> }}
        /&gt;
      ))}
    &lt;/div&gt;
  );
}

<span class="comment">// Each frame:</span>
<span class="comment">// 1. setState triggers re-render</span>
<span class="comment">// 2. Build new virtual DOM tree (N particles)</span>
<span class="comment">// 3. Diff old vs new (O(N) comparison)</span>
<span class="comment">// 4. Apply minimal DOM patches</span>

<span class="keyword">function</span> <span class="function">updateAllParticles</span>(newPositions) {
  <span class="function">setParticles</span>(newPositions); <span class="comment">// Triggers full reconciliation</span>
}</pre>
      <pre class="code-block" id="physics-code"><span class="comment">// Seeded PRNG for reproducible "chaos"</span>
<span class="keyword">function</span> <span class="function">mulberry32</span>(seed) {
  <span class="keyword">return</span> <span class="keyword">function</span>() {
    <span class="keyword">let</span> t = seed += <span class="number">0x6D2B79F5</span>;
    t = Math.<span class="function">imul</span>(t ^ t &gt;&gt;&gt; <span class="number">15</span>, t | <span class="number">1</span>);
    t ^= t + Math.<span class="function">imul</span>(t ^ t &gt;&gt;&gt; <span class="number">7</span>, t | <span class="number">61</span>);
    <span class="keyword">return</span> ((t ^ t &gt;&gt;&gt; <span class="number">14</span>) &gt;&gt;&gt; <span class="number">0</span>) / <span class="number">4294967296</span>;
  };
}

<span class="comment">// Physics with noise injection</span>
<span class="keyword">function</span> <span class="function">updatePhysics</span>(particle, random, noise) {
  <span class="comment">// Base velocity</span>
  particle.vx += (<span class="function">random</span>() - <span class="number">0.5</span>) * noise;
  particle.vy += (<span class="function">random</span>() - <span class="number">0.5</span>) * noise;

  <span class="comment">// Apply velocity</span>
  particle.x += particle.vx;
  particle.y += particle.vy;

  <span class="comment">// Bounce off walls</span>
  <span class="keyword">if</span> (particle.x &lt; <span class="number">0</span> || particle.x &gt; width) particle.vx *= <span class="number">-0.9</span>;
  <span class="keyword">if</span> (particle.y &lt; <span class="number">0</span> || particle.y &gt; height) particle.vy *= <span class="number">-0.9</span>;

  <span class="comment">// Clamp position</span>
  particle.x = Math.<span class="function">max</span>(<span class="number">0</span>, Math.<span class="function">min</span>(width, particle.x));
  particle.y = Math.<span class="function">max</span>(<span class="number">0</span>, Math.<span class="function">min</span>(height, particle.y));
}</pre>
    </div>
  </div>

  <!-- React 18 Production -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script>
    // ========================================================================
    // Seeded PRNG (Mulberry32)
    // ========================================================================
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // ========================================================================
    // BosatsuUI Implementation (Direct Binding)
    // Uses the same binding mechanism as compiled Bosatsu UI code
    // ========================================================================
    class BosatsuUIBenchmark {
      constructor(container, particleCount) {
        this.container = container;
        this.particleCount = particleCount;
        this.elements = [];
        this.bindings = {};  // Compile-time extracted bindings
        this.particles = [];

        this.init();
      }

      init() {
        // Clear container
        this.container.innerHTML = '';

        // Create particles and bindings (simulates compile-time extraction)
        for (let i = 0; i < this.particleCount; i++) {
          // Create DOM element
          const el = document.createElement('div');
          el.className = 'particle bosatsu-particle';
          el.id = `bosatsu-p-${i}`;
          this.container.appendChild(el);

          // Cache element reference
          this.elements[i] = el;

          // Register binding (this is what UIAnalyzer extracts at compile time)
          this.bindings[`p${i}_transform`] = [{
            elementId: el.id,
            property: 'style.transform',
            element: el  // Pre-cached for O(1) access
          }];

          // Initialize particle state
          this.particles[i] = {
            x: Math.random() * (this.container.clientWidth - 12),
            y: Math.random() * (this.container.clientHeight - 12),
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2
          };

          // Set initial position
          el.style.transform = `translate(${this.particles[i].x}px, ${this.particles[i].y}px)`;
        }
      }

      // O(1) state update using binding map
      updateParticle(index, x, y) {
        const binding = this.bindings[`p${index}_transform`][0];
        binding.element.style.transform = `translate(${x}px, ${y}px)`;
      }

      update(random, noise) {
        const width = this.container.clientWidth - 12;
        const height = this.container.clientHeight - 12;

        for (let i = 0; i < this.particleCount; i++) {
          const p = this.particles[i];

          // Physics with noise
          p.vx += (random() - 0.5) * noise;
          p.vy += (random() - 0.5) * noise;
          p.x += p.vx;
          p.y += p.vy;

          // Bounce
          if (p.x < 0 || p.x > width) p.vx *= -0.9;
          if (p.y < 0 || p.y > height) p.vy *= -0.9;
          p.x = Math.max(0, Math.min(width, p.x));
          p.y = Math.max(0, Math.min(height, p.y));

          // O(1) binding update
          this.updateParticle(i, p.x, p.y);
        }
      }
    }

    // ========================================================================
    // React Implementation (Virtual DOM)
    // ========================================================================
    class ReactBenchmark {
      constructor(container, particleCount) {
        this.container = container;
        this.particleCount = particleCount;
        this.root = ReactDOM.createRoot(container);
        this.particles = [];
        this.setParticlesRef = null;

        this.init();
      }

      init() {
        // Initialize particle state
        const initialParticles = [];
        for (let i = 0; i < this.particleCount; i++) {
          initialParticles.push({
            x: Math.random() * (this.container.clientWidth - 12),
            y: Math.random() * (this.container.clientHeight - 12),
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2
          });
        }
        this.particles = initialParticles;

        // Create React component
        const self = this;
        const ParticleSystem = () => {
          const [particles, setParticles] = React.useState(initialParticles);

          // Expose setParticles to class
          React.useEffect(() => {
            self.setParticlesRef = setParticles;
          }, []);

          return React.createElement('div', {
            style: { width: '100%', height: '100%', position: 'relative' }
          },
            particles.map((p, i) =>
              React.createElement('div', {
                key: i,
                className: 'particle react-particle',
                style: { transform: `translate(${p.x}px, ${p.y}px)` }
              })
            )
          );
        };

        this.root.render(React.createElement(ParticleSystem));
      }

      update(random, noise) {
        if (!this.setParticlesRef) return;

        const width = this.container.clientWidth - 12;
        const height = this.container.clientHeight - 12;

        // Update physics
        const newParticles = this.particles.map(p => {
          const np = { ...p };
          np.vx += (random() - 0.5) * noise;
          np.vy += (random() - 0.5) * noise;
          np.x += np.vx;
          np.y += np.vy;

          if (np.x < 0 || np.x > width) np.vx *= -0.9;
          if (np.y < 0 || np.y > height) np.vy *= -0.9;
          np.x = Math.max(0, Math.min(width, np.x));
          np.y = Math.max(0, Math.min(height, np.y));

          return np;
        });

        this.particles = newParticles;

        // Trigger React re-render (full reconciliation)
        this.setParticlesRef(newParticles);
      }

      destroy() {
        this.root.unmount();
      }
    }

    // ========================================================================
    // Benchmark Runner
    // ========================================================================
    let bosatsuBenchmark = null;
    let reactBenchmark = null;
    let animationId = null;
    let running = false;

    const bosatsuFpsSamples = [];
    const reactFpsSamples = [];

    function startBenchmark() {
      const particleCount = parseInt(document.getElementById('particleCount').value);
      const noiseLevel = document.getElementById('noiseLevel').value / 100;
      const duration = parseInt(document.getElementById('duration').value) * 1000;
      const seed = parseInt(document.getElementById('seed').value);

      // Create separate RNGs with same seed
      const bosatsuRandom = mulberry32(seed);
      const reactRandom = mulberry32(seed);

      // Initialize benchmarks
      const bosatsuContainer = document.getElementById('bosatsuContainer');
      const reactContainer = document.getElementById('reactContainer');

      if (bosatsuBenchmark) bosatsuBenchmark = null;
      if (reactBenchmark) {
        reactBenchmark.destroy();
        reactBenchmark = null;
      }

      bosatsuBenchmark = new BosatsuUIBenchmark(bosatsuContainer, particleCount);
      reactBenchmark = new ReactBenchmark(reactContainer, particleCount);

      // Wait for React to initialize
      setTimeout(() => {
        running = true;
        bosatsuFpsSamples.length = 0;
        reactFpsSamples.length = 0;

        document.getElementById('runBenchmark').disabled = true;
        document.getElementById('stopBenchmark').disabled = false;

        let bosatsuLastTime = performance.now();
        let reactLastTime = performance.now();
        let bosatsuFrameCount = 0;
        let reactFrameCount = 0;
        let totalFrames = 0;
        const startTime = performance.now();

        function animate() {
          if (!running) return;

          const now = performance.now();

          // Check duration
          if (now - startTime >= duration) {
            stopBenchmark();
            return;
          }

          // Update BosatsuUI
          const bosatsuStart = performance.now();
          bosatsuBenchmark.update(bosatsuRandom, noiseLevel);
          const bosatsuEnd = performance.now();

          // Update React
          const reactStart = performance.now();
          reactBenchmark.update(reactRandom, noiseLevel);
          const reactEnd = performance.now();

          bosatsuFrameCount++;
          reactFrameCount++;
          totalFrames++;

          // Calculate FPS every 500ms
          if (now - bosatsuLastTime >= 500) {
            const bosatsuFps = Math.round(bosatsuFrameCount / ((now - bosatsuLastTime) / 1000));
            const reactFps = Math.round(reactFrameCount / ((now - reactLastTime) / 1000));

            bosatsuFpsSamples.push(bosatsuFps);
            reactFpsSamples.push(reactFps);

            updateFpsDisplay('bosatsuFps', bosatsuFps);
            updateFpsDisplay('reactFps', reactFps);

            bosatsuFrameCount = 0;
            reactFrameCount = 0;
            bosatsuLastTime = now;
            reactLastTime = now;
          }

          document.getElementById('totalFrames').textContent = totalFrames;

          animationId = requestAnimationFrame(animate);
        }

        animate();
      }, 100);
    }

    function stopBenchmark() {
      running = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      document.getElementById('runBenchmark').disabled = false;
      document.getElementById('stopBenchmark').disabled = true;

      // Calculate averages
      if (bosatsuFpsSamples.length > 0 && reactFpsSamples.length > 0) {
        const bosatsuAvg = Math.round(bosatsuFpsSamples.reduce((a, b) => a + b, 0) / bosatsuFpsSamples.length);
        const reactAvg = Math.round(reactFpsSamples.reduce((a, b) => a + b, 0) / reactFpsSamples.length);
        const ratio = (bosatsuAvg / reactAvg).toFixed(2);

        document.getElementById('bosatsuAvg').textContent = bosatsuAvg;
        document.getElementById('reactAvg').textContent = reactAvg;
        document.getElementById('ratio').textContent = ratio;
      }
    }

    function updateFpsDisplay(elementId, fps) {
      const el = document.getElementById(elementId);
      el.textContent = `${fps} FPS`;
      el.className = 'fps ' + (fps >= 55 ? 'good' : fps >= 30 ? 'ok' : 'bad');
    }

    // Event listeners
    document.getElementById('runBenchmark').addEventListener('click', startBenchmark);
    document.getElementById('stopBenchmark').addEventListener('click', stopBenchmark);

    // Code tabs
    document.querySelectorAll('.code-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.code-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.code-block').forEach(b => b.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(`${tab.dataset.tab}-code`).classList.add('active');
      });
    });
  </script>
</body>
</html>
