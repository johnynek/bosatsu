package Bosatsu/IO/Std

from Bosatsu/Prog import Prog, pure, recover, ignore_err, await
from Bosatsu/IO/Error import IOError, error_to_String

export println, print, print_err, print_errln, read_stdin_utf8_bytes, show_error

# Write a string plus newline to standard output.
external println_impl: String -> Prog[IOError, Unit]
# Write a string to standard output.
external print_impl: String -> Prog[IOError, Unit]
# Write a string to standard error.
external print_err_impl: String -> Prog[IOError, Unit]
# Write a string plus newline to standard error.
external print_errln_impl: String -> Prog[IOError, Unit]

# Read about n bytes from stdin (may read up to n + 4 to finish a UTF-8 codepoint).
# n=0 behaves like n=1; empty string indicates EOF.
external read_stdin_utf8_bytes_impl: Int -> Prog[IOError, String]

# Print a line to standard output.
def println(str: String) -> Prog[IOError, Unit]:
  println_impl(str)

# Print text to standard output.
def print(str: String) -> Prog[IOError, Unit]:
  print_impl(str)

# Print text to standard error.
def print_err(str: String) -> Prog[IOError, Unit]:
  print_err_impl(str)

# Print a line to standard error.
def print_errln(str: String) -> Prog[IOError, Unit]:
  print_errln_impl(str)

# Read UTF-8 text from standard input.
def read_stdin_utf8_bytes(n: Int) -> Prog[IOError, String]:
  read_stdin_utf8_bytes_impl(n)

# Render IOError to stderr and recover with a default value.
def show_error[res](prog: Prog[IOError, res], default: res) -> forall e. Prog[e, res]:
  recover(prog, ioe -> (
    msg = error_to_String(ioe)
    _ <- ignore_err(print_errln(msg), ()).await()
    pure(default)
  ))
