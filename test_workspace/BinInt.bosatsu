package Bosatsu/Num/Binary

from Bosatsu/Num/BinNat import (BinNat, Zero as BNZero,
  prev as prev_BinNat, next as next_BinNat, sub_Option, sub_BinNat,
  add_BinNat, to_Int as binNat_to_Int, to_BinNat as int_to_BinNat,
  cmp_BinNat, eq_BinNat,
)

from Bosatsu/Predef import (add as add_Int,)

export (BinInt(), binNat_to_BinInt, int_to_BinInt, binInt_to_Int,
  negate, abs, add, not, cmp, eq, sub,)

# BWNot(x) == -x - 1
enum BinInt:
  FromBinNat(bn: BinNat)
  BWNot(arg: BinNat)

def cmp(a: BinInt, b: BinInt) -> Comparison:
  match a:
    case FromBinNat(na):
      match b:
        case FromBinNat(nb): cmp_BinNat(na, nb)
        case BWNot(_): GT
    case BWNot(na):
      match b:
        case BWNot(nb):
          # -a - 1 <> -b - 1 == (a <> b).invert
          cmp_BinNat(nb, na)
        case FromBinNat(_): LT

def eq(a: BinInt, b: BinInt) -> Bool:
  match a:
    case FromBinNat(na):
      match b:
        case FromBinNat(nb): eq_BinNat(na, nb)
        case BWNot(_): False
    case BWNot(na):
      match b:
        case BWNot(nb): eq_BinNat(na, nb)
        case FromBinNat(_): False

def binNat_to_BinInt(bn: BinNat) -> BinInt: FromBinNat(bn)

def not(bi: BinInt) -> BinInt:
  match bi:
    case FromBinNat(b): BWNot(b)
    case BWNot(b): FromBinNat(b)

def int_to_BinInt(i: Int) -> BinInt:
  if cmp_Int(i, 0) matches LT:
    # x = -(-x - 1) - 1
    BWNot(int_to_BinNat(not_Int(i)))
  else:
    FromBinNat(int_to_BinNat(i))

def binInt_to_Int(bi: BinInt) -> Int:
  match bi:
    case FromBinNat(bn): binNat_to_Int(bn)
    case BWNot(x): not_Int(binNat_to_Int(x))

def negate(bi: BinInt) -> BinInt:
  # -x = -(x - 1) - 1
  # -(-x - 1) = x + 1
  match bi:
    case FromBinNat(BNZero): bi
    case FromBinNat(bn): BWNot(bn.prev_BinNat())
    case BWNot(x): FromBinNat(x.next_BinNat())

def abs(bi: BinInt) -> BinNat:
  match bi:
    case FromBinNat(bn): bn
    case BWNot(x):
      #abs(-x - 1) = x + 1
      x.next_BinNat()

def add(x: BinInt, y: BinInt) -> BinInt:
  match (x, y):
    case (FromBinNat(nx), FromBinNat(ny)):
      FromBinNat(nx.add_BinNat(ny))
    case (FromBinNat(nx), BWNot(ny)):
      # x + (-y - 1) = x - (y + 1)
      ypos = ny.next_BinNat()
      match sub_Option(nx, ypos):
        case Some(bi): FromBinNat(bi)
        case None: FromBinNat(sub_BinNat(ypos, nx)).negate()
    case (BWNot(nx), FromBinNat(ny)):
      # -x - 1 + y = y - (x + 1) 
      xpos = nx.next_BinNat()
      match sub_Option(ny, xpos):
        case Some(bi): FromBinNat(bi)
        case None: FromBinNat(sub_BinNat(xpos, ny)).negate()
    case (BWNot(nx), BWNot(ny)):
      # (-x - 1) + (-y - 1) == -(x + y + 1) - 1
      BWNot(add_BinNat(nx, ny).next_BinNat())

def sub(a: BinInt, b: BinInt) -> BinInt:
  add(a, negate(b))
