package Bosatsu/List

from Bosatsu/Bool import not
from Bosatsu/Num/Nat import Nat, Zero, Succ
export any, eq_List, exists, head, for_all, size, sum, sort, uncons, zip

def any(as: List[Bool]) -> Bool:
    as matches [*_, True, *_]

def for_all(xs: List[a], fn: a -> Bool) -> Bool:
  recur xs:
    case []: True
    case [head, *tail] if fn(head):
      for_all(tail, fn)
    case [_, *_]:
      False

def sum(as: List[Int]) -> Int:
  as.foldl_List(0, add)

def exists(xs: List[a], fn: a -> Bool) -> Bool:
    recur xs:
        case []: False
        case [head, *_] if fn(head):
            True
        case [_, *tail]:
            exists(tail, fn)

def uncons(xs: List[a]) -> Option[(a, List[a])]:
    match xs:
        case []: None
        case [h, *t]: Some((h, t))

def head(xs: List[a]) -> Option[a]:
    match xs:
        case []: None
        case [h, *_]: Some(h)

def eq_List(fn: (a, a) -> Bool)(a: List[a], b: List[a]) -> Bool:
  recur a:
    case []: b matches []
    case [ah, *at]:
      match b:
        case []: False
        case [bh, *bt] if fn(ah, bh):
          eq_List(fn)(at, bt)
        case [_, *_]:
          False

def zip(left: List[a], right: List[b]) -> List[(a, b)]:
    recur left:
        case []: []
        case [ah, *at]:
            match right:
                case []: []
                case [bh, *bt]: [(ah, bh), *zip(at, bt)]

# tail recursive size implementation
def size1(list, acc):
    recur list:
        case []: acc
        case [_, *t]: size1(t, Succ(acc))

def size(list: List[a]) -> Nat:
    size1(list, Zero)

def sort(ord: Order[a], list: List[a]) -> List[a]:
    Order(to_fn) = ord

    def lt(x, h): to_fn(x, h) matches LT
    def gteq(x, h): to_fn(x, h) matches (GT | EQ)

    def loop(list: List[a], sz: Nat):
        recur sz:
            case Zero: list
            case Succ(n):
                match list:
                    case []: []
                    case [h, *t]:
                        lesser = [ ta for ta in t if lt(ta, h) ]
                        greater = [ ta for ta in t if gteq(ta, h) ]
                        # each of the above are at most size n
                        [ *loop(lesser, n), h, *loop(greater, n) ]
    loop(list, size(list))

##########################
# Test code below
##########################

operator =*= = eq_List(eq_Int)

head_test = (
    res = head([1, 2, 3]) matches Some(1)
    Assertion(res, "head test")
)

uncons_test = (
    res = uncons([1, 2, 3]) matches Some((1, [2, 3]))
    Assertion(res, "uncons test")
)

zip_test = (
    test1 = zip([1, 2], ["1", "2"]) matches [(1, "1"), (2, "2")]

    test2 = zip([1], ["1", "2"]) matches [(1, "1")]

    test3 = zip([1, 2], ["1"]) matches [(1, "1")]

    TestSuite("zip tests", [
      Assertion(test1, "same size"),
      Assertion(test2, "left smaller"),
      Assertion(test3, "right smaller"),
    ])
)

sort_test = (
    sort_Int = list -> sort(Order(cmp_Int), list)
    test1 = sort_Int([3, 1, 2]) matches [1, 2, 3]
    test2 = sort_Int([1, 2, 3]) matches [1, 2, 3]
    test3 = sort_Int([2, 3, 1]) matches [1, 2, 3]
    test4 = sort_Int([1, 2, 1]) matches [1, 1, 2]

    TestSuite("sort tests", [
      Assertion(test1, "3, 1, 2"),
      Assertion(test2, "1, 2, 3"),
      Assertion(test3, "2, 3, 1"),
      Assertion(test4, "1, 2, 1"),
    ])
)

string_tests = TestSuite("string tests", [
  Assertion(int_to_String(0) matches "0", "int_to_String(0) == ${int_to_String(0)}"),
  Assertion(int_to_String(1) matches "1", "int_to_String(1) == ${int_to_String(1)}"),
  Assertion(int_to_String(2) matches "2", "int_to_String(2) == ${int_to_String(2)}"),
])

il = int_loop(5, 0, (i, a) -> (i.sub(1), i.add(a)))

tests = TestSuite("List tests", [
  Assertion(2.sub(3) matches -1, "2 - 3 = ${int_to_String(2.sub(3))}"),
  Assertion(il matches 15, "int_loop test ${int_to_String(il)}"),
  Assertion([1, 2, 3] =*= [1, 2, 3], "list [1, 2, 3]"),
  Assertion(not([1, 2, 3] =*= [1, 2]), "list [1, 2, 3] != [1, 2]"),
  Assertion(range(0) matches [], "range(0) matches []"),
  Assertion(range(1) matches [0], "range(1) matches [0]"),
  Assertion(range(2) matches [0, 1], "range(2) matches [0, 1]"),
  Assertion(range(6) =*= [0, 1, 2, 3, 4, 5], "range(6) == ${concat_String(range(6).map_List(i -> "${int_to_String(i)}, "))}"),
  Assertion(sum([]) matches 0, "sum([])"),
  Assertion(sum([5]) matches 5, "sum([5])"),
  Assertion(sum([5, 11]) matches 16, "sum([5, 11])"),
  Assertion(sum([0, 1, 2, 3, 4, 5]) matches 15, "sum([0, 1, 2, 3, 4, 5])"),
  #Assertion(range(6).sum().eq_Int(15), "range(6).sum == 1 + 2 + 3 + 4 + 5 = 15"),
  Assertion(range(6).exists(v -> v.eq_Int(5)), "range(6) does have 5"),
  Assertion(not(range(6).exists(v -> v.eq_Int(6))), "range(6) does not have 6"),
  string_tests,
  head_test,
  uncons_test,
  zip_test,
  sort_test,
  Assertion(any([]) matches False, "any([])"),
  Assertion(any([True]) matches True, "any([True])"),
  Assertion(any([False]) matches False, "any([False])"),
  Assertion(any([False, False]) matches False, "any([False, False])"),
  Assertion(any([False, True]) matches True, "any([False, True])"),
  Assertion(any([True, False]) matches True, "any([True, False])"),
  Assertion(any([True, True]) matches True, "any([True, True])"),
  ])
