package StringPatternBranchTests

export tests

def andb(a: Bool, b: Bool) -> Bool:
  if a:
    b
  else:
    False

def notb(a: Bool) -> Bool:
  if a:
    False
  else:
    True

def eqs(a: String, b: String) -> Bool:
  cmp_String(a, b) matches EQ

tests = TestSuite("String pattern branch tests", [
  Assertion(uncons_String("") matches None, "uncons empty"),
  Assertion(uncons_String("abc") matches Some((.'a', "bc")), "uncons ascii"),
  Assertion(uncons_String("Ã©a") matches Some((.'Ã©', "a")), "uncons unicode"),

  Assertion(notb("bbb" matches "ab${_}"), "literal prefix not found"),
  Assertion(notb("zabq" matches "ab${_}"), "literal found later is not a prefix"),
  Assertion("abq" matches "ab${_}", "literal prefix with wildcard tail"),
  Assertion(
    match "abq":
      case "ab${tail}":
        eqs(tail, "q")
      case _:
        False,
    "literal prefix with captured tail"),

  Assertion(
    match "xy":
      case "$.{h}${t}":
        if h matches .'x':
          eqs(t, "y")
        else:
          False
      case _:
        False,
    "char capture at head"),
  Assertion("xy" matches "$.{_}${_}", "char wildcard at head"),
  Assertion(notb("" matches "$.{_}"), "char on empty string fails"),

  Assertion("abcz" matches "${_}$.{_}z", "glob-char search finds middle match"),
  Assertion(notb("abc" matches "${_}$.{_}z"), "glob-char search exhausts"),
  Assertion(
    match "abcz":
      case "${left}$.{mid}z":
        andb(eqs(left, "ab"), mid matches .'c')
      case _:
        False,
    "glob-char search with captures"),

  Assertion(notb("abc" matches "${_}xyz"), "glob-literal search with no candidate"),
  Assertion(notb("" matches "${_}x"), "glob-literal search on empty input"),
  Assertion(
    match "aaZ":
      case "${left}aZ":
        eqs(left, "a")
      case _:
        False,
    "glob-literal single-char candidate miss then hit"),
  Assertion(
    "ababZ" matches "${_}abZ",
    "glob-literal multi-char candidate miss then hit"),
  Assertion(
    match "ðŸ‘‹ðŸ‘‹x":
      case "${left}ðŸ‘‹x":
        eqs(left, "ðŸ‘‹")
      case _:
        False,
    "unicode literal candidate miss then hit"),

  Assertion(
    match "AAfooXbarBB":
      case "${left}foo$.{mid}bar${right}":
        andb(andb(eqs(left, "AA"), mid matches .'X'), eqs(right, "BB"))
      case _:
        False,
    "two globs with literal and char capture between"),
  Assertion(
    match "fooXbar":
      case "${left}foo$.{mid}bar${right}":
        andb(andb(eqs(left, ""), mid matches .'X'), eqs(right, ""))
      case _:
        False,
    "two globs allow empty edges"),
  Assertion(
    match "AAfooXbarBB":
      case "${_}foo$.{_}bar${right}":
        eqs(right, "BB")
      case _:
        False,
    "two globs position 1 wildcard, position 2 capture"),
  Assertion(
    match "AAfooXbarBB":
      case "${left}foo$.{_}bar${_}":
        eqs(left, "AA")
      case _:
        False,
    "two globs position 1 capture, position 2 wildcard"),
  Assertion(
    "AAfooXbarBB" matches "${_}foo$.{_}bar${_}",
    "two globs both wildcard"),
  Assertion(
    notb("AAfooXbazBB" matches "${_}foo$.{_}bar${_}"),
    "two globs fail when middle literal is missing"),

  Assertion(
    match "LfooMIDQbarR":
      case "${a}foo${b}$.{c}bar${d}":
        andb(andb(eqs(a, "L"), eqs(b, "MID")), andb(c matches .'Q', eqs(d, "R")))
      case _:
        False,
    "three globs with string and char capture separators"),
  Assertion(
    notb("LfooMIDQbazR" matches "${_}foo${_}$.{_}bar${_}"),
    "three globs fail when trailing literal is missing"),
  Assertion(
    match "fooQbar":
      case "${a}foo${b}$.{c}bar${d}":
        andb(andb(eqs(a, ""), eqs(b, "")), andb(c matches .'Q', eqs(d, "")))
      case _:
        False,
    "three globs allow empty captures around separator"),
  Assertion(
    match "LfooMIDQbarR":
      case "${_}foo${b}$.{c}bar${d}":
        andb(eqs(b, "MID"), andb(c matches .'Q', eqs(d, "R")))
      case _:
        False,
    "three globs position 1 wildcard"),
  Assertion(
    match "LfooMIDQbarR":
      case "${a}foo${_}$.{c}bar${d}":
        andb(eqs(a, "L"), andb(c matches .'Q', eqs(d, "R")))
      case _:
        False,
    "three globs position 2 wildcard"),
  Assertion(
    match "LfooMIDQbarR":
      case "${a}foo${b}$.{c}bar${_}":
        andb(eqs(a, "L"), andb(eqs(b, "MID"), c matches .'Q'))
      case _:
        False,
    "three globs position 3 wildcard"),
  Assertion(
    "LfooMIDQbarR" matches "${_}foo${_}$.{_}bar${_}",
    "three globs all wildcard"),

  Assertion(
    match "PfooM1XbarM2bazS":
      case "${a}foo${b}$.{c}bar${d}baz${e}":
        andb(
          andb(eqs(a, "P"), eqs(b, "M1")),
          andb(c matches .'X', andb(eqs(d, "M2"), eqs(e, "S"))))
      case _:
        False,
    "four globs with mixed separators"),
  Assertion(
    notb("PfooM1XbarM2zzzS" matches "${_}foo${_}$.{_}bar${_}baz${_}"),
    "four globs fail when final literal is missing"),
  Assertion(
    match "fooXbarbaz":
      case "${a}foo${b}$.{c}bar${d}baz${e}":
        andb(
          andb(eqs(a, ""), eqs(b, "")),
          andb(c matches .'X', andb(eqs(d, ""), eqs(e, ""))))
      case _:
        False,
    "four globs allow empty captures across all regions"),
])
