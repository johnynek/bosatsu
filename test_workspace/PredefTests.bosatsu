package PredefTests

from Bosatsu/Num/Float64 import (
  float64_bits_to_Int,
  float64_to_Int,
  float64_to_String,
  int_bits_to_Float64,
  int_to_Float64,
  is_infinite,
  is_nan,
  string_to_Float64,
)

operator / = div
operator % = mod_Int

i = int_to_String

def oi(opt):
  match opt:
    case None: "None"
    case Some(v): "Some(${i(v)})"

def notb(a):
  match a:
    case True: False
    case False: True
def andb(a, b):
  match a:
    case True: b
    case False: False

test_int = TestSuite("Int tests", [
      Assertion((4 % -3) matches -2, "(4 % -3) == -2 got: ${i(4 % -3)}"),
      Assertion((-8 % -2) matches 0, "(-8 % -2) == 0 got: ${i(-8 % -2)}"),
      Assertion((-8 / -2) matches 4, "(-8 / -2) == 4 got: ${i(-8 / -2)}"),

      Assertion((5 / -3) matches -2, "(5 / -3) == -2 got: ${i(5 / -3)}"),
      Assertion((-5 / 3) matches -2, "(-5 / 3) == -2 got: ${i(-5 / 3)}"),
      Assertion((5 / 3) matches 1, "(5 / 3) == 1 got ${i(5 / 3)}"),
      Assertion((-5 / -3) matches 1, "(5 / 3) == 1 got ${i(-5 / -3)}"),

      Assertion((5 % -3) matches -1, "(5 % -3) == -1 got ${i(5 % -3)}"),
      Assertion((-5 % 3) matches 1, "(5 % -3) == 1 got ${i(-5 % 3)}"),
      Assertion((5 % 3) matches 2, "(5 % 3) == 2 got ${i(5 % 3)}"),
      Assertion((-5 % -3) matches -2, "(-5 % -3) == -2 got ${i(-5 % -3)}"),

      # some hard ones found by scalacheck
      Assertion((-15934641381326140386510 / 599767409) matches -26568034778506,
        "(-15934641381326140386510 / 599767409) matches -26568034778506 got ${i(-15934641381326140386510 / 599767409)}"),
      Assertion((-15934641381326140386510 % 599767409) matches 292124444,
        "(-15934641381326140386510 % 599767409) matches 292124444 got ${i(-15934641381326140386510 % 599767409)}"),

      Assertion((2885517232792582372714 / -7104274460) matches -406166350842,
        "(2885517232792582372714 / -7104274460) matches -406166350842 got ${i(2885517232792582372714 / -7104274460)}"),
      Assertion((2885517232792582372714 % -7104274460) matches -5637722606,
        "(2885517232792582372714 % -7104274460) matches -5637722606 got ${i(2885517232792582372714 % -7104274460)}"),

      Assertion((671836834585 / 7104274460) matches 94,
        "(671836834585 / 7104274460) matches 94 got ${i(671836834585 / 7104274460)}"),
      Assertion((671836834585 % 7104274460) matches 4035035345,
        "(671836834585 % 7104274460) matches 4035035345 got ${i(671836834585 % 7104274460)}"),

      Assertion((-4 % -3) matches -1, "(-4 % -3) == -1"),
      Assertion((13 % 3) matches 1, "13 % 3 == 1"),
      Assertion((-113 / 16) matches -8, "-113/16 == -8"),
      Assertion((54 % -3) matches 0, "54 % -3 == 0"),
      Assertion((54 / -3) matches -18, "54 / -3 == -18"),
      Assertion((54 % 0) matches 54, "54 % 0 == 54"),
      Assertion((54 / 0) matches 0, "54 / 0 == 0"),
      Assertion((-54 % 0) matches -54, "-54 % 0 == -54"),
      Assertion((-54 / 0) matches 0, "-54 / 0 == 0"),

      Assertion(shift_left_Int(1, 1) matches 2, "1 << 1 == 2"),
      Assertion(shift_right_Int(1, 1) matches 0, "1 >> 1 == 0"),
      Assertion(xor_Int(1, 1) matches 0, "1 ^ 1 == 0"),
      Assertion(and_Int(-1, 23) matches 23, "-1 & 23 == 23"),
      Assertion(or_Int(-1, 23) matches -1, "-1 | 23 == -1"),
      Assertion(not_Int(-2) matches 1, "~(-2) == 1"),
      
      Assertion(gcd_Int(4, 3) matches 1, "gcd(4, 3) == 1"),
      Assertion(gcd_Int(-4, -3) matches -1, "gcd(-4, -3) == -1"),
      Assertion(gcd_Int(4, 2) matches 2, "gcd(4, 2) == 2"),

      Assertion(int_to_String(0) matches "0", "0 str"),
      Assertion(int_to_String(123) matches "123", "123 str"),
      Assertion(int_to_String(-123) matches "-123", "-123 str"),

      Assertion(string_to_Int("123") matches Some(123), "123 string_to_Int"),
      Assertion(string_to_Int("-123") matches Some(-123), "-123 string_to_Int"),
      Assertion(string_to_Int("-123x") matches None, "-123x string_to_Int"),
      Assertion(string_to_Int("-${int_to_String(123)}") matches Some(-123), "-123 string_to_Int"),

      Assertion(string_to_Int("9223372036854775807") matches Some(9223372036854775807),
        "Long.Max ${oi(string_to_Int("9223372036854775807"))} != ${oi(Some(9223372036854775807))}string_to_Int"),
      Assertion(string_to_Int("9223372036854775808") matches Some(9223372036854775808),
        "Long.Max + 1: ${oi(string_to_Int("9223372036854775808"))} string_to_Int"),

      Assertion(string_to_Int("2147483647") matches Some(2147483647), "Int.Max string_to_Int"),
      Assertion(string_to_Int("2147483648") matches Some(2147483648),
        "Int.Max + 1 string_to_Int: ${oi(string_to_Int("2147483648"))} != ${oi(Some(2147483648))}"),

      Assertion(string_to_Int("-9223372036854775808") matches Some(-9223372036854775808), "Long.Min string_to_Int"),
      Assertion(string_to_Int("-9223372036854775809") matches Some(-9223372036854775809), "Long.Min - 1 string_to_Int"),

      Assertion(string_to_Int("-2147483648") matches Some(-2147483648), "Int.Min string_to_Int"),
      Assertion(string_to_Int("-2147483649") matches Some(-2147483649), "Int.Min - 1 string_to_Int"),
      Assertion(string_to_Int("-2147483649z") matches None, "-2147483649z string_to_Int"),
    ])

test_string = TestSuite("String tests", [
  Assertion("foo".partition_String("f") matches Some(("", "oo")), "foo partition_String f"),
  Assertion("foo".partition_String("") matches None, "foo partition_String \"\""),
  Assertion("foo".partition_String("x") matches None, "foo partition_String x"),
  Assertion("foo".rpartition_String("o") matches Some(("fo", "")), "foo rpartition_String o"),
  Assertion("foo".rpartition_String("") matches None, "foo rpartition_String \"\""),
  Assertion("foo".rpartition_String("x") matches None, "foo rpartition_String x"),
  Assertion(length_String("") matches 0, "length_String empty"),
  Assertion(length_String("abc") matches 3, "length_String ascii"),
  Assertion(char_List_to_String([.'h', .'i']) matches "hi", "char_List_to_String ascii"),
  Assertion(char_List_to_String([.'ðŸ‘‹']) matches "ðŸ‘‹", "char_List_to_String unicode"),

  Assertion(uncons_String("") matches None, "uncons empty"),
  Assertion(uncons_String("abc") matches Some((.'a', "bc")), "uncons ascii"),
  Assertion(uncons_String("Ã©a") matches Some((.'Ã©', "a")), "uncons unicode"),
  Assertion(tail_or_empty_String("") matches "", "tail_or_empty empty"),
  Assertion(tail_or_empty_String("abc") matches "bc", "tail_or_empty ascii"),
  Assertion(tail_or_empty_String("Ã©a") matches "a", "tail_or_empty unicode"),

  Assertion(notb("bbb" matches "ab${_}"), "literal prefix not found"),
  Assertion(notb("zabq" matches "ab${_}"), "literal found later is not a prefix"),
  Assertion("abq" matches "ab${_}", "literal prefix with wildcard tail"),
  Assertion(
    match "abq":
      case "ab${tail}": tail matches "q"
      case _: False,
    "literal prefix with captured tail"),

  Assertion(
    match "xy":
      case "$.{h}${t}":
        if h matches .'x':
          t matches "y"
        else:
          False
      case _: False,
    "char capture at head"),
  Assertion("xy" matches "$.{_}${_}", "char wildcard at head"),
  Assertion(notb("" matches "$.{_}"), "char on empty string fails"),

  Assertion("abcz" matches "${_}$.{_}z", "glob-char search finds middle match"),
  Assertion(notb("abc" matches "${_}$.{_}z"), "glob-char search exhausts"),
  Assertion(
    match "abcz":
      case "${left}$.{mid}z":
        andb(left matches "ab", mid matches .'c')
      case _: False,
    "glob-char search with captures"),

  Assertion(notb("abc" matches "${_}xyz"), "glob-literal search with no candidate"),
  Assertion(notb("" matches "${_}x"), "glob-literal search on empty input"),
  Assertion(
    match "aaZ":
      case "${left}aZ": left matches "a"
      case _: False,
    "glob-literal single-char candidate miss then hit"),
  Assertion("ababZ" matches "${_}abZ", "glob-literal multi-char candidate miss then hit"),
  Assertion(
    match "ðŸ‘‹ðŸ‘‹x":
      case "${left}ðŸ‘‹x": left matches "ðŸ‘‹"
      case _: False,
    "unicode literal candidate miss then hit"),
])

def eqf(a, b): cmp_Float64(a, b) matches EQ
def eqi(a, b): cmp_Int(a, b) matches EQ
def eqb(a, b):
  if a:
    b
  else:
    notb(b)

u64_mod = 1.shift_left_Int(64)
two_pow_52 = 1.shift_left_Int(52)
two_pow_53 = 1.shift_left_Int(53)
lcg_mul = 6364136223846793005
lcg_inc = 1442695040888963407

def next_u64(seed: Int) -> Int:
  seed.mul(lcg_mul).add(lcg_inc).mod_Int(u64_mod)

def bits_roundtrip_law(trials: Int, seed0: Int) -> Bool:
  state = int_loop(trials, (seed0, True), (n, state) -> (
    (seed, ok) = state
    seed1 = next_u64(seed)
    f = int_bits_to_Float64(seed1)
    bits_back = float64_bits_to_Int(f)
    ok1 = match is_nan(f):
      case True: ok
      case False: andb(ok, eqi(bits_back, seed1))
    (n.sub(1), (seed1, ok1))
  ))
  state matches (_, True)

def string_roundtrip_law(trials: Int, seed0: Int) -> Bool:
  state = int_loop(trials, (seed0, True), (n, state) -> (
    (seed, ok) = state
    seed1 = next_u64(seed)
    f = int_bits_to_Float64(seed1)
    parsed = string_to_Float64(float64_to_String(f))
    ok1 = match parsed:
      case Some(f1) if is_nan(f): is_nan(f1)
      case Some(f1): eqf(f, f1)
      case None: False
    (n.sub(1), (seed1, andb(ok, ok1)))
  ))
  state matches (_, True)

def pos_inf_matches_law(trials: Int, seed0: Int) -> Bool:
  state = int_loop(trials, (seed0, True), (n, state) -> (
    (seed, ok) = state
    seed1 = next_u64(seed)
    f = int_bits_to_Float64(seed1)
    rhs = andb(is_infinite(f), cmp_Float64(f, 0.0) matches GT)
    ok1 = andb(ok, eqb(f matches âˆž, rhs))
    (n.sub(1), (seed1, ok1))
  ))
  state matches (_, True)

def neg_inf_matches_law(trials: Int, seed0: Int) -> Bool:
  state = int_loop(trials, (seed0, True), (n, state) -> (
    (seed, ok) = state
    seed1 = next_u64(seed)
    f = int_bits_to_Float64(seed1)
    rhs = andb(is_infinite(f), cmp_Float64(f, 0.0) matches LT)
    ok1 = andb(ok, eqb(f matches -âˆž, rhs))
    (n.sub(1), (seed1, ok1))
  ))
  state matches (_, True)

def nan_matches_law(trials: Int, seed0: Int) -> Bool:
  state = int_loop(trials, (seed0, True), (n, state) -> (
    (seed, ok) = state
    seed1 = next_u64(seed)
    f = int_bits_to_Float64(seed1)
    ok1 = andb(ok, eqb(is_nan(f), f matches .NaN))
    (n.sub(1), (seed1, ok1))
  ))
  state matches (_, True)

def int_float_roundtrip_law(trials: Int, seed0: Int) -> Bool:
  state = int_loop(trials, (seed0, True), (n, state) -> (
    (seed, ok) = state
    seed1 = next_u64(seed)
    i0 = seed1.mod_Int(two_pow_53).sub(two_pow_52)
    back = float64_to_Int(int_to_Float64(i0))
    ok1 = match back:
      case Some(i1): andb(ok, eqi(i0, i1))
      case None: False
    (n.sub(1), (seed1, ok1))
  ))
  state matches (_, True)

def float_to_int_eq(f: Float64, expected: Int) -> Bool:
  match float64_to_Int(f):
    case Some(v): eqi(v, expected)
    case None: False

def int_to_float_eq(i: Int, expected: Float64) -> Bool:
  eqf(int_to_Float64(i), expected)

nan0 = divf(0.0, 0.0)
huge_int = 1.shift_left_Int(2000)

def classify_float(x: Float64) -> Int:
  match x:
    case .NaN: 0
    case 0.0: 1
    case 1.5: 2
    case _: 3

test_float = TestSuite("Float tests", [
  Assertion(eqf(addf(1.25, 2.5), 3.75), "addf"),
  Assertion(eqf(subf(5.5, 2.25), 3.25), "subf"),
  Assertion(eqf(timesf(1.5, 2.0), 3.0), "timesf"),
  Assertion(eqf(divf(7.5, 2.5), 3.0), "divf"),
  Assertion(eqf(.NaN, nan0), "nan equality"),
  Assertion(eqf(1_234.5_6, 1234.56), "underscore parsing"),
  Assertion(eqf(.5, 0.5), "leading dot"),
  Assertion(eqf(5., 5.0), "trailing dot"),
  Assertion(eqf(âˆž, divf(1.0, 0.0)), "literal infinity"),
  Assertion(eqf(-âˆž, divf(-1.0, 0.0)), "literal negative infinity"),
  Assertion(float_to_int_eq(0.5, 0), "python hard case: round(0.5) == 0"),
  Assertion(float_to_int_eq(1.5, 2), "python hard case: round(1.5) == 2"),
  Assertion(float_to_int_eq(2.5, 2), "python hard case: round(2.5) == 2"),
  Assertion(float_to_int_eq(3.5, 4), "python hard case: round(3.5) == 4"),
  Assertion(float_to_int_eq(-0.5, 0), "python hard case: round(-0.5) == 0"),
  Assertion(float_to_int_eq(-1.5, -2), "python hard case: round(-1.5) == -2"),
  Assertion(float_to_int_eq(-2.5, -2), "python hard case: round(-2.5) == -2"),
  Assertion(float_to_int_eq(0.49999999999999994, 0), "python hard case: round(0.49999999999999994) == 0"),
  Assertion(float_to_int_eq(4503599627370495.5, 4503599627370496), "python hard case near 2^52"),
  Assertion(float_to_int_eq(9007199254740992.0, 9007199254740992), "python hard case at 2^53"),
  Assertion(float64_to_Int(.NaN) matches None, "python hard case: round(nan) is invalid"),
  Assertion(float64_to_Int(âˆž) matches None, "python hard case: round(inf) is invalid"),
  Assertion(float64_to_Int(-âˆž) matches None, "python hard case: round(-inf) is invalid"),
  Assertion(int_to_float_eq(9007199254740993, 9007199254740992.0), "python hard case: float(2^53 + 1)"),
  Assertion(int_to_float_eq(-9007199254740993, -9007199254740992.0), "python hard case: float(-(2^53 + 1))"),
  Assertion(int_to_float_eq(10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 1e100),
    "python hard case: float(10**100)"),
  Assertion(int_to_float_eq(-10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -1e100),
    "python hard case: float(-(10**100))"),
  Assertion(eqf(int_to_Float64(huge_int), âˆž), "python hard case: float(str(2**2000)) == inf"),
  Assertion(eqf(int_to_Float64(0.sub(huge_int)), -âˆž), "python hard case: float(str(-(2**2000))) == -inf"),
  Assertion(float_to_int_eq(int_to_Float64(two_pow_52), two_pow_52), "2^52 roundtrip"),
  Assertion(float_to_int_eq(int_to_Float64(0.sub(two_pow_52)), 0.sub(two_pow_52)), "-2^52 roundtrip"),
  Assertion(float64_bits_to_Int(int_bits_to_Float64(0x8000_0000_0000_0000)) matches 0x8000_0000_0000_0000,
    "signed zero bit roundtrip"),
  Assertion(float64_bits_to_Int(int_bits_to_Float64(-9223372036854775807)) matches 0x8000_0000_0000_0001,
    "int_bits uses low 64 bits for negative ints"),
  Assertion(
    match string_to_Float64(float64_to_String(.NaN)):
      case Some(v): is_nan(v)
      case None: False,
    "NaN string roundtrip remains NaN"),
  Assertion(
    (
      match string_to_Float64(".NaN"):
        case Some(v): is_nan(v)
        case None: False
    ),
    ".NaN string parses"),
  Assertion(string_to_Float64("not-a-float") matches None, "invalid float parse"),
  Assertion(bits_roundtrip_law(300, 424242), "bits roundtrip law"),
  Assertion(string_roundtrip_law(300, 424242), "string roundtrip law"),
  Assertion(int_float_roundtrip_law(300, 515151), "int <-> float reversible law for [-2^52, 2^52)"),
  Assertion(nan_matches_law(300, 171717), "is_nan(x) iff (x matches .NaN)"),
  Assertion(pos_inf_matches_law(300, 272727), "positive infinity matches law"),
  Assertion(neg_inf_matches_law(300, 373737), "negative infinity matches law"),
  Assertion(eqf(5e-324, 5e-324), "min subnormal"),
  Assertion(eqf(2.2250738585072014e-308, 2.2250738585072014e-308), "min normal"),
  Assertion(cmp_Float64(nan0, 0.0) matches LT, "nan < non-nan"),
  Assertion(cmp_Float64(0.0, nan0) matches GT, "non-nan > nan"),
  Assertion(cmp_Float64(nan0, .NaN) matches EQ, "all nan compare equal"),
  Assertion(cmp_Float64(-0.0, 0.0) matches EQ, "signed zero compare"),
  Assertion(cmp_Float64(divf(1.0, 0.0), divf(-1.0, 0.0)) matches GT, "inf order"),
  Assertion(classify_float(nan0) matches 0, "nan pattern match"),
  Assertion(classify_float(.NaN) matches 0, "explicit nan literal pattern"),
  Assertion(classify_float(-0.0) matches 1, "signed zero pattern match"),
  Assertion(classify_float(0.0) matches 1, "zero pattern match"),
])

test = TestSuite("Predef tests", [
    test_int,
    test_string,
    test_float,
])
