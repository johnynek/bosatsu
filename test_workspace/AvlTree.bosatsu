package AvlTree

enum Tree[a]:
    Empty, Branch(size: Int, height: Int, key: a, left: Tree[a], right: Tree[a])

enum Rotation: LeftRo, NoRo, RightRo

def operator >(i, j):
    match cmp_Int(i, j):
        GT: True
        _: False

def rotation(left: Int, right: Int, max_diff: Int) -> Rotation:
    if left.sub(right) > max_diff:
        RightRo
    elif right.sub(left) > max_diff:
        LeftRo
    else:
        NoRo

def max(i, j):
    match cmp_Int(i, j):
        LT: j
        _: i

def height(t: Tree[a]) -> Int:
    match t:
        Empty: 0
        Branch { height: h, ...}: h

def size(t: Tree[a]) -> Int:
    match t:
        Empty: 0
        Branch { size: s, ...}: s

def branch(sz, item, left, right):
    h = max(height(left), height(right))
    Branch(sz, h.add(1), item, left, right)

def branch_s(item, left, right):
    sz = size(left).add(size(right)).add(1)
    branch(sz, item, left, right)

def balance(t: Tree[a]) -> Tree[a]:
    match t:
        Empty: Empty
        Branch { key: top_item, left, right, ... }:
          match rotation(height(left), height(right), 1):
              NoRo: t
              LeftRo:
                  match left:
                      Empty: t
                      Branch { key: inner_item, left, right: left_right, ... }:
                          match rotation(height(left), height(left_right), 0):
                              LeftRo | NoRo:
                                  res_r = branch_s(top_item, left_right, right)
                                  branch_s(inner_item, left, res_r)
                              RightRo:
                                  match left_right:
                                      Empty: t
                                      Branch { key: lrv, left: left_right_left, right: left_right_right, ...}:
                                          res_r = branch_s(top_item, left_right_right, right)
                                          res_l = branch_s(inner_item, left, left_right_left)
                                          branch_s(lrv, res_l, res_r)
              RightRo:
                  match right:
                      Empty: t
                      Branch { key: inner_item, left: right_left, right: right_right, ...}:
                          match rotation(height(right_left), height(right_right), 0):
                              RightRo | NoRo:
                                  branch_s(inner_item, branch_s(top_item, left, right_left), right_right)
                              LeftRo:
                                  match right_left:
                                      Empty: t
                                      Branch { key: right_left_key, right: right_left_left, left: right_left_right, ... }:
                                          branch_s(
                                            right_left_key,
                                            branch_s(top_item, left, right_left_left),
                                            branch_s(inner_item, right_left_right, right_right))

def add_item(ord: Order[a], tree: Tree[a], item: a) -> Tree[a]:
    Order(fn) = ord

    def loop(tree: Tree[a]) -> Tree[a]:
        recur tree:
            Empty: Branch(1, 1, item, Empty, Empty)
            Branch(s, h, item0, left, right):
                match fn(item, item0):
                    EQ: Branch(s, h, item, left, right)
                    LT:
                        left = loop(left)
                        branch(s.add(1), item0, left, right)
                    GT:
                        right = loop(right)
                        branch(s.add(1), item0, left, right)

    loop(tree).balance

def contains(ord: Order[a], tree: Tree[a], item: a) -> Bool:
    Order(fn) = ord

    def loop(tree: Tree[a]) -> Bool:
        recur tree:
            Empty: False
            Branch { key, left, right, ... }:
                match fn(item, key):
                    EQ: True
                    LT: loop(left)
                    GT: loop(right)

    loop(tree)

def min(tree: Tree[a]) -> Option[a]:
    recur tree:
        Empty: None
        Branch { key, left: Empty, ... }: Some(key)
        Branch { left, ... }: min(left)


def remove_item(ord: Order[a], tree: Tree[a], item: a) -> Tree[a]:
    Order(fn) = ord

    def loop(tree: Tree[a]) -> Tree[a]:
        recur tree:
            Empty: Empty
            Branch(s, _, item0, left, right):
                match fn(item, item0):
                    EQ:
                        match right:
                            Empty: left
                            _:
                                right = loop(right)
                                branch(s.sub(1), item0, left, right)
                    LT:
                        left = loop(left)
                        branch(s.sub(1), item0, left, right)
                    GT:
                        right = loop(right)
                        branch(s.sub(1), item0, left, right)

    loop(tree).balance

# Module pattern to associate some methods with a typeclass (Order)
struct Module[a](
    order: Order[a],
    add: Tree[a] -> a -> Tree[a],
    single: a -> Tree[a],
    contains: Tree[a] -> a -> Bool,
    remove: Tree[a] -> a -> Tree[a],
)

def module(ord: Order[a]) -> Module[a]:
    Module {
        order: ord,
        add: add_item(ord),
        single: \a -> add_item(ord, Empty, a),
        contains: contains(ord),
        remove: remove_item(ord),
    }
#####################
# test code
#####################

Module { add: add_i, contains: contains_i, single: single_i, remove: rem_i ...} = module(Order(cmp_Int))

def not(x): False if x else True

def contains_test:
    def add_law(t, i, msg):
        Assertion(t.add_i(i).contains_i(i), msg)

    def missing_law(t, i, msg):
        Assertion(not(t.contains_i(i)), msg)

    TestSuite('contains tests', [
      add_law(Empty, 2, "Empty.add_law 2"),
      add_law(single_i(2), 2, "single(2) + 2 add_law"),
      add_law(single_i(3), 42, "single(3) add_law 42"),
      missing_law(single_i(2), 3, "single(2) ! contains 3"),
      missing_law(single_i(2).rem_i(2), 2, "Empty + 2 - 2, !contains(2)"),
      missing_law(single_i(2).rem_i(2).rem_i(2), 2, "Empty + 2 - 2, !contains(2)")
    ])

tests = TestSuite("AvlTree tests", [
    contains_test,
])
