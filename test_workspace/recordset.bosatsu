package RecordSet

enum RowEntry:
  REBool(value: Bool)
  REInt(value: Int)
  REString(value: String)

struct RecordField[t](name: String, toValue: t -> RowEntry)
struct RecordValue[t](value: t)

struct RecordSet[shape](fields: shape[RecordField], rows: List[shape[RecordValue]])

def restructure(RecordSet(fields, rows), f: forall w. shape1[w] -> shape2[w]) -> RecordSet[shape2]:
  RecordSet(f(fields), rows.map_List(f))

struct IntShape[w](int: w[Int])
struct PairShape[shape1,shape2,w](left: shape1[w], right: shape2[w])

def make_pair_int_shape(rest: shape[w], i: w[Int]) -> PairShape[shape,IntShape,w]:
  PairShape(rest, IntShape(i))

# def add_shape(RecordSet(fields1, rows): RecordSet[shape1], fields2: shape2[RecordField[String], RecordField[Int], RecordField[Bool]], f: shape1[String, Int, Bool] -> shape2[String, Int, Bool]) -> RecordSet[PairShape[shape1, shape2]]:
#  RecordSet(PairShape(fields1, fields2), rows.map_List(\row -> PairShape(row, f(row))))

def add_int_field(RecordSet(fields, rows): RecordSet[shape1], name: String, f: shape1[RecordValue] -> Int) -> RecordSet[PairShape[shape1, IntShape]]:
  RecordSet(make_pair_int_shape(fields, RecordField(name, REInt)), rows.map_List(\row -> make_pair_int_shape(row, RecordValue(f(row)))))

##################################################

struct Shape1[w](f1: w[String], f2: w[Int], f3: w[Bool])
struct Shape2[w](f1: w[String], f2: w[Bool], f3: w[Int])
struct Shape3[w](f1: w[String], f2: w[Bool], f3: w[Int], f4: w[Int])

rs = RecordSet(
  Shape1(RecordField("String", REString), RecordField("Int", REInt), RecordField("Bool", REBool)),
  [Shape1(RecordValue("a"), RecordValue(1), RecordValue(True))]
)

rs0 = rs.restructure(\Shape1(a,b,c) -> Shape2(a,c,b))
rs1 = rs0.add_int_field("Second Int", \Shape2(_,_,RecordValue(x)) -> x.add(4))
rs2 = rs1.restructure(\PairShape(Shape2(a,b,c), IntShape(i)) -> Shape3(a,b,c,i))

##################################################

def and(x, y):
  y if x else False

operator && = and

def equals(compare, x, y):
  match compare(x,y):
    EQ: True
    _: False

def cmp_Bool(x, y):
  match (x, y):
    (True, False): GT
    (False, True): LT
    _: EQ

def equal_List(is_equal, l1, l2):
  recur l1:
    []: match l2:
      []: True
      _: False
    [h1, *r1]: match l2:
      []: False
      [h2, *r2]: is_equal(h1, h2) && equal_List(is_equal, r1, r2)

def compare_shape3((compare1, compare2, compare3), Shape3(RecordValue(x1), RecordValue(x2), RecordValue(x3), RecordValue(x4)), Shape3(RecordValue(y1), RecordValue(y2), RecordValue(y3), RecordValue(y4))):
  compare1.equals(x1, y1) && compare2.equals(x2, y2) && compare3.equals(x3, y3) && compare3.equals(x4, y4)

RecordSet(_, rows) = rs2
tests = Test("reordering",
  [
    Assertion((string_Order_fn, cmp_Bool, cmp_Int).compare_shape3.equal_List(rows, [Shape3(RecordValue("a"), RecordValue(True), RecordValue(1), RecordValue(5))]), "swap")
  ]
)
