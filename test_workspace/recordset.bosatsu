package RecordSet

enum RowEntry[w]:
  REBool(value: w[Bool])
  REInt(value: w[Int])
  REString(value: w[String])

struct RecordField[t](name: String, to_entry: forall w. w[t] -> RowEntry[w])
struct RecordValue[t](value: t)
struct RecordGetter[shape, t](f: forall w. shape[w] -> w[t])

struct RecordSet[shape](fields: shape[RecordField], rows: List[shape[RecordValue]], getters: shape[RecordGetter[shape]])

# , forall w1, w2. shape2[w1] -> (forall s. w1[s] -> w2[s]) -> shape2[w2])) -> RecordSet[shape2]:
def restructure(RecordSet(fields, rows, getters): RecordSet[shape1], f: shape1[RecordGetter[shape1]] -> (forall w. shape1[w] -> shape2[w], shape2[RecordGetter[shape2]])) -> RecordSet[shape2]:
  (reshaper1, new_getters) = f(getters)
  (reshaper2, _) = f(getters)
  RecordSet(reshaper1(fields), rows.map_List(reshaper2), new_getters)

struct NilShape[w]
struct IntShape[w](int: w[Int])
struct PS[t,shape2,w](left: w[t], right: shape2[w])

#    \PS(x, _), g -> PS(g(x), NilShape)
def s(RecordGetter(f)):
  (
    \x -> PS(f(x),NilShape),
    PS(RecordGetter(\PS(x, _) -> x), NilShape)
  )

# def ps(RecordGetter(f): RecordGetter[shapae1, t], (g, sh2, traverse): (forall w. shape1[w] -> shape2[w], shape2[RecordGetter[shape2]], forall w1,w2. shape2[w1] -> (forall s. w1[s] -> w2[s]) -> shape2[w2] )):
#  (
#    \sh1 -> PS(f(sh1), g(sh1)),
#    PS(RecordGetter(\PS(x,_) -> x), sh2.traverse(\RecordGetter(f1) -> RecordGetter(\PS(_, sh2) -> f1(sh2)))),
#    \PS(x, sh2), g -> PS(g(x), sh2.traverse(g))
#  )

##################################################

rs = RecordSet(
  PS(RecordField("String", REString), PS(RecordField("Int", REInt), PS(RecordField("Bool", REBool), NilShape))),
  [PS(RecordValue("a"), PS(RecordValue(1), PS(RecordValue(True), NilShape)))],
  PS(RecordGetter(\PS(x,_) -> x), PS(RecordGetter(\PS(_, PS(x, _)) -> x), PS(RecordGetter(\PS(_, PS(_, PS(x, _))) -> x), NilShape)))
)

rs0 = rs.restructure(\PS(a, PS(b, PS(c, _))) -> s(b))

##################################################

def and(x, y):
  y if x else False

operator && = and

def equals(compare, x, y):
  match compare(x,y):
    EQ: True
    _: False

def cmp_Bool(x, y):
  match (x, y):
    (True, False): GT
    (False, True): LT
    _: EQ

def equal_List(is_equal, l1, l2):
  recur l1:
    []: match l2:
      []: True
      _: False
    [h1, *r1]: match l2:
      []: False
      [h2, *r2]: is_equal(h1, h2) && equal_List(is_equal, r1, r2)

def equal_RowEntry(re1, re2):
  match (re1, re2):
    (REBool(RecordValue(x1)), REBool(RecordValue(x2))): cmp_Bool.equals(x1, x2)
    (REInt(RecordValue(x1)), REInt(RecordValue(x2))): cmp_Int.equals(x1, x2)
    (REString(RecordValue(x1)), REString(RecordValue(x2))): string_Order_fn.equals(x1, x2)
    _: False

def equal_rows(row1, row2):
  equal_RowEntry.equal_List(row1, row2)

RecordSet(_, rows, _) = rs0

def to_row(PS(RecordValue(x), _)):
  [REInt(RecordValue(1))]

tests = Test("reordering",
  [
    Assertion(equal_rows.equal_List(rows.map_List(to_row), [[REInt(RecordValue(1))]]), "swap")
  ]
)

