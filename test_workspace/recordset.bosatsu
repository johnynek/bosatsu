package RecordSet

enum RowEntry[w]:
  REBool(value: w[Bool])
  REInt(value: w[Int])
  REString(value: w[String])

struct RecordField[t](name: String, to_entry: forall w. w[t] -> RowEntry[w])
struct RecordValue[t](value: t)
struct RecordGetter[shape, t](
  field: shape[RecordField] -> RecordField[t],
  value: shape[RecordValue] -> RecordValue[t]
)
struct RecordRowEntry[w, t](row_entry: RowEntry[w])

struct RecordSet[shape](
  fields: shape[RecordField],
  rows: List[shape[RecordValue]],
  getters: shape[RecordGetter[shape]]
)

def get(sh: shape[RecordValue], RecordGetter(_, getter): RecordGetter[shape, t]) -> t:
  RecordValue(result) = sh.getter
  result

def create_field(rf: RecordField[t], fn: shape[RecordValue] -> t):
  RecordGetter(\sh -> rf, \sh -> RecordValue(fn(sh)))

struct RestructureOutput[shape1, shape2](
  reshaperFields: shape1[RecordField] -> shape2[RecordField],
  reshaperValues: shape1[RecordValue] -> shape2[RecordValue],
  getters: shape2[RecordGetter[shape2]],
  traverse: (forall w1,w2. shape2[w1] -> (forall ss. w1[ss] -> w2[ss]) -> shape2[w2]),
  record_to_list: (forall w. shape2[RecordRowEntry[w]] -> List[RowEntry[w]])
)
def restructure(RecordSet(fields, rows, getters): RecordSet[shape1], f: shape1[RecordGetter[shape1]] -> RestructureOutput[shape1, shape2]) -> RecordSet[shape2]:
  RestructureOutput(reshaperF, reshaperV, new_getters, _, _) = f(getters)
  RecordSet(reshaperF(fields), rows.map_List(reshaperV), new_getters)

def concat_records(RecordSet(fields, rows, getters), more_rows):
  RecordSet(fields, rows.concat(more_rows), getters)

struct NilShape[w]
struct PS[t,rest,w](left: w[t], right: rest[w])

new_record_set = RecordSet(NilShape, [], NilShape)

def s(RecordGetter(f1, v1)):
  def traverse(PS(x, _), g):
    PS(g(x), NilShape)
  RestructureOutput(
    \x -> PS(f1(x),NilShape),
    \x -> PS(v1(x),NilShape),
    PS(RecordGetter(\PS(x, _) -> x, \PS(x, _) -> x), NilShape),
    traverse,
    \PS(RecordRowEntry(row_entry), _) -> [row_entry]
  )

def ps(
  RecordGetter(fF, fV): RecordGetter[shape1, t],
  RestructureOutput(reshaper1F, reshaper1V, getters1, traverse1, record_to_list1): RestructureOutput[shape1, shape2]):
  getters2 = getters1.traverse1(\RecordGetter(f1, v1) -> RecordGetter(\PS(_, sh2) -> f1(sh2), \PS(_, sh2) -> v1(sh2)))
  RestructureOutput(
    \sh1 -> PS(fF(sh1), reshaper1F(sh1)),
    \sh1 -> PS(fV(sh1), reshaper1V(sh1)),
    PS(RecordGetter(\PS(x,_) -> x, \PS(x,_) -> x), getters2),
    \PS(x, sh2), g -> PS(g(x), sh2.traverse1(g)),
    \PS(RecordRowEntry(row_entry), sh2) -> [row_entry].concat(record_to_list1(sh2))
  )

##################################################

rs = new_record_set.restructure(\ns -> ps(RecordField("String", REString).create_field(\_ -> ""), ps(RecordField("Int", REInt).create_field(\_ -> 0), s(RecordField("Bool", REBool).create_field(\_ -> True))))).concat_records([PS(RecordValue("a"), PS(RecordValue(1), PS(RecordValue(False), NilShape)))])

rs0 = rs.restructure(\PS(a, PS(b, PS(c, _))) -> ps(c,ps(a,s(b))))

##################################################

def and(x, y):
  y if x else False

operator && = and

def equals(compare, x, y):
  match compare(x,y):
    EQ: True
    _: False

def cmp_Bool(x, y):
  match (x, y):
    (True, False): GT
    (False, True): LT
    _: EQ

def equal_List(is_equal, l1, l2):
  recur l1:
    []: match l2:
      []: True
      _: False
    [h1, *r1]: match l2:
      []: False
      [h2, *r2]: is_equal(h1, h2) && equal_List(is_equal, r1, r2)

def equal_RowEntry(re1, re2):
  match (re1, re2):
    (REBool(RecordValue(x1)), REBool(RecordValue(x2))): cmp_Bool.equals(x1, x2)
    (REInt(RecordValue(x1)), REInt(RecordValue(x2))): cmp_Int.equals(x1, x2)
    (REString(RecordValue(x1)), REString(RecordValue(x2))): string_Order_fn.equals(x1, x2)
    _: False

def equal_rows(row1, row2):
  equal_RowEntry.equal_List(row1, row2)

RecordSet(_, rows, _) = rs0

def to_row(PS(RecordValue(x), _)):
  [REInt(RecordValue(1))]

tests = Test("reordering",
  [
    Assertion(equal_rows.equal_List(rows.map_List(to_row), [[REInt(RecordValue(1))]]), "swap")
  ]
)

