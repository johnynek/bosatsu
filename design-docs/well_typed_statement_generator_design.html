<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Well-Typed Statement Generator Design · Bosatsu Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='paradox docs'/>
<link rel="canonical" href="https://github.com/johnynek/bosatsudesign-docs/well_typed_statement_generator_design.html"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../js/page.js"></script>
<script type="text/javascript" src="../js/warnOldVersion.js"></script>
<script type="text/javascript" src="../js/groups.js"></script>
<script type="text/javascript" src="../js/snippets.js"></script>
<link rel="stylesheet" type="text/css" href="../lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="../css/page.css"/>

<!--
<link rel="shortcut icon" href="../images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Bosatsu Documentation
</a>
<div class="version-number">
0.0.0+1-5e5bd1d1*
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../design.html" class="page">Bosatsu Design Philosophy and Goals</a></li>
  <li><a href="../design-docs/index.html" class="page">Design Docs</a></li>
  <li><a href="../getting_started.html" class="page">Getting started (new repo)</a></li>
  <li><a href="../language_guide.html" class="page">Language Guide</a></li>
  <li><a href="../recursion.html" class="page">Recursion in Bosatsu</a></li>
  <li><a href="../generating_json.html" class="page">Generating JSON from Bosatsu Values</a></li>
  <li><a href="../debugging_with_eval.html" class="page">Debugging with <code>lib eval</code></a></li>
  <li><a href="../debugging_with_show.html" class="page">Inspecting Compiled Output with <code>lib show</code></a></li>
  <li><a href="../transpile_python.html" class="page">Compiling to Python</a></li>
  <li><a href="../generated/core_alpha/index.html" class="page">Core Alpha API</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="../index.html">Bosatsu Documentation</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="../index.html" >
<span class="home-icon">⌂</span>Bosatsu Documentation
</a>
<div class="version-number">
0.0.0+1-5e5bd1d1*
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="../design.html" class="page">Bosatsu Design Philosophy and Goals</a></li>
  <li><a href="../design-docs/index.html" class="page">Design Docs</a></li>
  <li><a href="../getting_started.html" class="page">Getting started (new repo)</a></li>
  <li><a href="../language_guide.html" class="page">Language Guide</a></li>
  <li><a href="../recursion.html" class="page">Recursion in Bosatsu</a></li>
  <li><a href="../generating_json.html" class="page">Generating JSON from Bosatsu Values</a></li>
  <li><a href="../debugging_with_eval.html" class="page">Debugging with <code>lib eval</code></a></li>
  <li><a href="../debugging_with_show.html" class="page">Inspecting Compiled Output with <code>lib show</code></a></li>
  <li><a href="../transpile_python.html" class="page">Compiling to Python</a></li>
  <li><a href="../generated/core_alpha/index.html" class="page">Core Alpha API</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="../index.html">Bosatsu Documentation</a></li>
  <li><a href="../design-docs/index.html">Design Docs</a></li>
  <li>Well-Typed Statement Generator Design</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#well-typed-statement-generator-design" name="well-typed-statement-generator-design" class="anchor"><span class="anchor-link"></span></a>Well-Typed Statement Generator Design</h1>
<p>Status: proposed<br/>Date: 2026-02-16</p>
<h2><a href="#goal" name="goal" class="anchor"><span class="anchor-link"></span></a>Goal</h2>
<p>Design <code>wellTypedProgramGen: Gen[WellTypedProgram]</code> that produces source <code>Statement</code>s plus typing witnesses (<code>expected</code>, <code>typeEnv</code>) so we can property-test the compiler pipeline with generated programs, not just parser-shaped random syntax.</p>
<h2><a href="#motivation" name="motivation" class="anchor"><span class="anchor-link"></span></a>Motivation</h2>
<p>Current test generators have a gap:</p>
<ol>
  <li><code>Generators.genStatements</code> generates syntactically valid statements, but not type-directed ones.</li>
  <li><code>Generators.genTypedExpr</code> explicitly notes it is random and not well typed.</li>
</ol>
<p>That means we can stress parsing/printing/proto paths, but we cannot reliably generate source programs to test:</p>
<ol>
  <li><code>SourceConverter</code> + inference success paths,</li>
  <li>normalization and compilation (<code>MatchlessFromTypedExpr</code>),</li>
  <li>backend codegen against broader random inputs.</li>
</ol>
<h2><a href="#non-goals-v1-" name="non-goals-v1-" class="anchor"><span class="anchor-link"></span></a>Non-goals (v1)</h2>
<ol>
  <li>Full language coverage on day one (especially recursion, comprehensions, and complex pattern guards).</li>
  <li>Generating every valid program shape.</li>
  <li>Proving generator soundness independent of the typechecker.</li>
</ol>
<p>v1 should prioritize high signal and low flake risk.</p>
<h2><a href="#proposed-api" name="proposed-api" class="anchor"><span class="anchor-link"></span></a>Proposed API</h2>
<pre class="prettyprint"><code class="language-scala">object WellTypedGenerators {
  final case class Config(
    maxStatements: Int,
    maxExprDepth: Int,
    maxTypeDepth: Int,
    allowDefs: Boolean,
    allowTypeDefs: Boolean
  )

  final case class WellTypedProgram(
    statements: List[Statement],
    expected: Map[Identifier.Bindable, rankn.Type],
    typeEnv: rankn.TypeEnv[Kind.Arg]
  )

  def wellTypedProgramGen(cfg: Config): Gen[WellTypedProgram]
}
</code></pre>
<p><code>wellTypedProgramGen</code> is the primary output because statements alone are not enough to assert typing behavior; tests also need value-type witnesses (<code>expected</code>) and the type-constant interpretation context (<code>typeEnv</code>).</p>
<h2><a href="#core-idea" name="core-idea" class="anchor"><span class="anchor-link"></span></a>Core Idea</h2>
<p>Use type-directed synthesis:</p>
<ol>
  <li>Generate a target type <code>t</code>.</li>
  <li>Generate an expression <code>e</code> such that <code>e : t</code> under the current environment.</li>
  <li>Emit a statement binding <code>name = e</code>.</li>
  <li>Extend the environment with <code>name : t</code>.</li>
  <li>Repeat.</li>
</ol>
<p>This is a standard introduction/elimination strategy:</p>
<ol>
  <li>Introduction rules build values of a requested type (<code>lambda</code>, literals, constructors).</li>
  <li>Elimination rules consume existing values/functions from scope (<code>var</code>, application).</li>
</ol>
<h2><a href="#generation-context" name="generation-context" class="anchor"><span class="anchor-link"></span></a>Generation Context</h2>
<pre class="prettyprint"><code class="language-scala">final case class ValSig(name: Identifier.Bindable, sigma: rankn.Type)
final case class CtorSig(
  pack: PackageName,
  cons: Identifier.Constructor,
  sigma: rankn.Type,
  resultTypeConst: rankn.Type.Const.Defined
)

final case class Ctx(
  packageName: PackageName,
  vals: Vector[ValSig],
  ctors: Vector[CtorSig],
  typeEnv: rankn.TypeEnv[Kind.Arg],
  usedNames: Set[Identifier.Bindable]
)
</code></pre>
<p>Notes:</p>
<ol>
  <li><code>vals</code> holds in-scope names generated so far.</li>
  <li><code>usedNames</code> is the global freshness set, and must include all value binders:  <code>vals.forall(v =&gt; usedNames(v.name))</code>.</li>
  <li>
  <p><code>ctors</code> is a sampling cache; the source of truth is <code>typeEnv</code>, and every cached constructor must exist there:  <code>ctors.forall(c =&gt; typeEnv.getConstructor(c.pack, c.cons).isDefined)</code>.</p></li>
  <li>
  <p><code>CtorSig.resultTypeConst</code> records the constructor&rsquo;s final return type constant (the defined type it constructs), so constructor selection can quickly filter by demanded result type root before full instantiation.</p></li>
  <li><code>ctors</code> and <code>typeEnv</code> come from imported interfaces plus generated type definitions.</li>
  <li>v1 uses monomorphic goals by default, but <code>sigma</code> storage keeps polymorphism support open.</li>
</ol>
<h2><a href="#typeenv-witness" name="typeenv-witness" class="anchor"><span class="anchor-link"></span></a>TypeEnv witness</h2>
<p><code>WellTypedProgram.typeEnv</code> is required so <code>expected: Map[Bindable, Type]</code> has an explicit interpretation context for <code>TyConst</code> references (especially generated local <code>struct</code>/<code>enum</code> types).</p>
<p>Planned construction:</p>
<ol>
  <li>Incrementally update <code>ctx.typeEnv</code> while generating statements (for v1 this is mostly imported/predef; later phases add local type defs).</li>
  <li>On finalize, derive the compiler-view env from generated statements via the same path used by compilation (<code>SourceConverter.toProgram</code> -&gt; parsed type env -&gt; <code>TypeEnv.fromParsed</code>) and merge with imported env.</li>
  <li>Return that finalized env as <code>WellTypedProgram.typeEnv</code>.</li>
</ol>
<p>This keeps the witness aligned with how the compiler interprets type constants.</p>
<h2><a href="#type-generation" name="type-generation" class="anchor"><span class="anchor-link"></span></a>Type Generation</h2>
<p>Generate only inhabitable goal types to keep <code>genExpr(goal)</code> failure low.</p>
<h3><a href="#gentype-ctx-depth-gen-type-" name="gentype-ctx-depth-gen-type-" class="anchor"><span class="anchor-link"></span></a><code>genType(ctx, depth): Gen[Type]</code></h3>
<p>Weighted choices:</p>
<ol>
  <li>Ground base types: <code>Int</code>, <code>String</code>, <code>Char</code>, <code>Float64</code>, <code>Bool</code>, <code>Unit</code>.</li>
  <li>ADT applications with available constructors: <code>Option[a]</code>, <code>List[a]</code>, tuples, and local generated ADTs.</li>
  <li>Function types with explicit arity (small arity), i.e. <code>a -&gt; r</code>, <code>(a1, a2) -&gt; r</code>, <code>(a1, a2, a3) -&gt; r</code>, &hellip; (internally <code>Fn1</code>..<code>Fn32</code>, not curried chains).</li>
</ol>
<h3><a href="#inhabited-type-filter" name="inhabited-type-filter" class="anchor"><span class="anchor-link"></span></a>Inhabited-type filter</h3>
<p>Use a memoized predicate <code>canInhabit(ctx, t)</code>:</p>
<ol>
  <li><code>True</code> for base literal types.</li>
  <li><code>True</code> for function types (we can always lambda-introduce at that exact arity if result type is inhabitable under an extended scope).</li>
  <li><code>True</code> for ADT types when some constructor can be instantiated and all argument types are inhabitable.</li>
  <li><code>True</code> if there is already an in-scope value assignable to <code>t</code>.</li>
</ol>
<p>If no candidate is found at some depth, fall back to base types.</p>
<h2><a href="#expression-generation" name="expression-generation" class="anchor"><span class="anchor-link"></span></a>Expression Generation</h2>
<pre class="prettyprint"><code class="language-scala">def genExpr(ctx: Ctx, goal: Type, depth: Int): OptionT[Gen, Declaration.NonBinding]
</code></pre>
<p><code>OptionT</code> is intentional: some goals may be temporarily unreachable under current context.</p>
<h3><a href="#introduction-path-genintro-" name="introduction-path-genintro-" class="anchor"><span class="anchor-link"></span></a>Introduction path (<code>genIntro</code>)</h3>
<p>Construct directly by type shape:</p>
<ol>
  <li>If goal is <code>Type.Fun(args, res)</code>: generate a lambda with exactly <code>args.length</code> parameters, extend <code>ctx</code>, generate body for <code>res</code>.</li>
  <li>If goal is a literal type: emit literal (<code>Int</code>, <code>String</code>, <code>Char</code>, <code>Float64</code>).</li>
  <li>If goal is an ADT: choose constructor where <code>resultTypeConst</code> matches goal root <code>TyConst</code> (when present), then instantiate <code>sigma</code> to the full goal and recursively build args.</li>
  <li>If goal is tuple/list/option and syntax sugar is easier, emit tuple/list forms directly.</li>
</ol>
<h3><a href="#elimination-path-genelim-" name="elimination-path-genelim-" class="anchor"><span class="anchor-link"></span></a>Elimination path (<code>genElim</code>)</h3>
<p>Use available names:</p>
<ol>
  <li>Choose a value/function <code>v : sigma</code> from <code>ctx.vals</code> or constructor from <code>ctx.ctors</code>.</li>
  <li>For constructors, optionally prefilter by <code>resultTypeConst</code> vs goal root <code>TyConst</code>; then instantiate <code>sigma</code> toward <code>goal</code> (using <code>Type.instantiate</code>-style matching on result type).</li>
  <li>If instantiation yields needed argument types <code>a1..an</code>, recursively generate args and build one application node with arity <code>n</code> (not nested curried applications).</li>
  <li>If no args needed and instantiation matches goal, emit variable directly.</li>
</ol>
<h3><a href="#control-flow-expressions-phase-gated-" name="control-flow-expressions-phase-gated-" class="anchor"><span class="anchor-link"></span></a>Control flow expressions (phase-gated)</h3>
<p>After v1 is stable:</p>
<ol>
  <li><code>if</code> / ternary by generating <code>Bool</code> condition and same-typed branches.</li>
  <li><code>match</code> with typed pattern generation and exhaustiveness by construction.</li>
</ol>
<h2><a href="#complete-declaration-surface-exhaustive-" name="complete-declaration-surface-exhaustive-" class="anchor"><span class="anchor-link"></span></a>Complete Declaration Surface (Exhaustive)</h2>
<p>This section lists every <code>Declaration</code> syntax constructor and how to generate it.</p>
<h3><a href="#declaration-binding-forms-" name="declaration-binding-forms-" class="anchor"><span class="anchor-link"></span></a>Declaration (binding forms)</h3>
<ol>
  <li>
  <p><code>Declaration.Binding(BindingStatement(pattern, value, in))</code><br/> Syntax shape: <code>&lt;pattern&gt; = &lt;nonbinding&gt;</code> then continuation declaration.<br/> Generation: choose <code>pattern</code>, generate <code>value</code> that matches pattern type, extend env with pattern bindings for <code>in</code>.</p></li>
  <li>
  <p><code>Declaration.Comment(CommentStatement[Padding[Declaration]])</code><br/> Syntax shape: <code># ...</code> preceding declaration.<br/> Generation: wrapper over an already generated declaration; semantics-preserving noise.</p></li>
  <li>
  <p><code>Declaration.DefFn(DefStatement(...))</code><br/> Syntax shape: local <code>def</code> with args/body plus continuation.<br/> Generation: generate function type, args/patterns/body, optional return annotation, then generate continuation in extended env.</p></li>
  <li>
  <p><code>Declaration.LeftApply(arg, fn, result)</code><br/> Syntax shape: <code>&lt;pattern&gt; &lt;- &lt;fn(exprs...)&gt;</code> then body.<br/> Generation: choose <code>fn</code> returning function-on-last-arg; generate lambda body for appended arg. Equivalent to desugared <code>Apply</code> with final lambda argument.</p></li>
</ol>
<h3><a href="#declaration-nonbinding-expression-forms-" name="declaration-nonbinding-expression-forms-" class="anchor"><span class="anchor-link"></span></a>Declaration.NonBinding (expression forms)</h3>
<ol>
  <li>
  <p><code>Declaration.Annotation(fn, tpe)</code><br/> Syntax: <code>&lt;expr&gt;: &lt;TypeRef&gt;</code>.<br/> Generation: generate expression of subtype/instantiation-compatible type, then annotate/widen to demanded type.</p></li>
  <li>
  <p><code>Declaration.Apply(fn, args, kind = Parens)</code><br/> Syntax: <code>f(a, b, ...)</code>.<br/> Generation: pick callable with arity <code>n</code>, generate exactly <code>n</code> typed args, build one application.</p></li>
  <li>
  <p><code>Declaration.Apply(fn, args, kind = Dot)</code><br/> Syntax: <code>recv.f(a, b, ...)</code> (parser desugars shape constraints).<br/> Generation: same as apply, but render in dot form when legal for readability/syntax coverage.</p></li>
  <li>
  <p><code>Declaration.ApplyOp(left, op, right)</code><br/> Syntax: <code>left &lt;op&gt; right</code>.<br/> Generation: choose operator identifier with known function type and generate typed operands.</p></li>
  <li>
  <p><code>Declaration.CommentNB(CommentStatement[Padding[NonBinding]])</code><br/> Syntax shape: comment wrapping NB expression.<br/> Generation: wrapper/noise over generated nonbinding.</p></li>
  <li>
  <p><code>Declaration.IfElse(ifCases, elseCase)</code><br/> Syntax: <code>if cond: ... elif cond: ... else: ...</code>.<br/> Generation: generate <code>Bool</code> conditions and branch bodies of demanded type.</p></li>
  <li>
  <p><code>Declaration.Ternary(trueCase, cond, falseCase)</code><br/> Syntax: <code>trueCase if cond else falseCase</code>.<br/> Generation: same typing rule as <code>IfElse</code>, compact syntax variant.</p></li>
  <li>
  <p><code>Declaration.Lambda(args, body)</code><br/> Syntax: <code>(p1, p2, ...) -&gt; body</code> / <code>p -&gt; body</code>.<br/> Generation: introduction for <code>Type.Fun(args, res)</code> with exact arity and typed arg patterns.</p></li>
  <li>
  <p><code>Declaration.Literal(lit)</code><br/> Syntax: numeric/string/char/float literal.<br/> Generation: direct for literal-compatible goal types.</p></li>
  <li>
  <p><code>Declaration.Match(kind, arg, cases)</code><br/>Syntax: <code>match</code>/<code>recur</code> with <code>case</code> branches.<br/>Generation: choose scrutinee type, build total pattern set, generate each branch in branch-extended env.</p></li>
  <li>
  <p><code>Declaration.Matches(arg, pattern)</code><br/>Syntax: <code>expr matches pattern</code> (returns <code>Bool</code>).<br/>Generation: generate <code>arg</code> and pattern at same type; use when demanded type is <code>Bool</code>.</p></li>
  <li>
  <p><code>Declaration.Parens(of)</code><br/>Syntax: <code>(decl)</code>.<br/>Generation: wrapper for precedence/roundtrip diversity.</p></li>
  <li>
  <p><code>Declaration.TupleCons(items)</code><br/>Syntax: <code>()</code>, <code>(a,)</code>, <code>(a, b, ...)</code>.<br/>Generation: produce tuple values for tuple goal types.</p></li>
  <li>
  <p><code>Declaration.Var(name)</code><br/>Syntax: identifier reference.<br/>Generation: elimination path from env value/constructor.</p></li>
  <li>
  <p><code>Declaration.RecordConstructor(cons, arg)</code><br/>Syntax: <code>Cons { field }</code>, <code>Cons { field: value, ... }</code>.<br/>Generation: choose struct/constructor with record style fields; generate each provided field expression.</p></li>
  <li>
    <p><code>Declaration.StringDecl(items)</code> with <code>StringDecl.Part</code> variants: </p>
    <ol>
      <li><code>StringDecl.Literal(region, str)</code></li>
      <li><code>StringDecl.StrExpr(nonBinding)</code></li>
      <li><code>StringDecl.CharExpr(nonBinding)</code><br/>Syntax: interpolated string segments <code>&#39;foo${s}$.{c}&#39;</code>.<br/>Generation: mixed literal and embedded expressions (<code>String</code> or <code>Char</code>) to produce <code>String</code>.</li>
    </ol>
  </li>
  <li>
    <p><code>Declaration.ListDecl(list)</code> with <code>ListLang</code> variants: </p>
    <ol>
      <li><code>ListLang.Cons(items)</code> where items are <code>SpliceOrItem.Item(expr)</code> or <code>SpliceOrItem.Splice(expr)</code> (<code>*expr</code>)</li>
      <li><code>ListLang.Comprehension(expr, binding, in, filter)</code><br/>Syntax: <code>[a, *rest]</code>, <code>[expr for p in src if cond]</code>.<br/>Generation: constructor/list-intro path plus optional comprehension path.</li>
    </ol>
  </li>
  <li>
    <p><code>Declaration.DictDecl(list)</code> with <code>ListLang</code> variants: </p>
    <ol>
      <li><code>ListLang.Cons(items)</code> where item is <code>KVPair(key, value)</code></li>
      <li><code>ListLang.Comprehension(KVPair(key, value), binding, in, filter)</code><br/>Syntax: <code>{k: v, ...}</code>, <code>{k: v for p in src if cond}</code>.<br/>Generation: only when demanded type is <code>Dict[k, v]</code>; generate typed keys/values and source/filter.</li>
    </ol>
  </li>
</ol>
<h3><a href="#internal-declaration-helper-syntax-that-must-also-be-generated" name="internal-declaration-helper-syntax-that-must-also-be-generated" class="anchor"><span class="anchor-link"></span></a>Internal declaration helper syntax that must also be generated</h3>
<ol>
  <li><code>Declaration.MatchBranch(pattern, guard, body)</code> for <code>match</code> cases.</li>
  <li><code>Declaration.RecordArg.Simple(field)</code> and <code>Declaration.RecordArg.Pair(field, arg)</code> for record constructors.</li>
  <li><code>Declaration.ApplyKind.Parens</code> and <code>Declaration.ApplyKind.Dot</code> for application rendering diversity.</li>
</ol>
<h2><a href="#pattern-generation" name="pattern-generation" class="anchor"><span class="anchor-link"></span></a>Pattern Generation</h2>
<p><code>match</code> generation requires typed pattern synthesis plus branch-local binding environments.</p>
<h3><a href="#pattern-surface-exhaustive-" name="pattern-surface-exhaustive-" class="anchor"><span class="anchor-link"></span></a>Pattern surface (exhaustive)</h3>
<p>Generate all <code>Pattern</code> forms:</p>
<ol>
  <li><code>Pattern.WildCard</code> syntax <code>_</code>.</li>
  <li><code>Pattern.Literal(lit)</code> syntax literal pattern.</li>
  <li><code>Pattern.Var(name)</code> syntax bindable name.</li>
  <li><code>Pattern.Named(name, pat)</code> syntax <code>pat as name</code>.</li>
  <li><code>Pattern.Annotation(pat, tpe)</code> syntax <code>pat: Type</code>.</li>
  <li><code>Pattern.PositionalStruct(name, params)</code> syntax:</li>
  <li>constructor tuple-like: <code>Cons(p1, p2, ...)</code>,</li>
  <li>constructor record-like: <code>Cons { f1: p1, f2, ... }</code>,</li>
  <li>tuple patterns: <code>()</code>, <code>(p,)</code>, <code>(p1, p2, ...)</code>,</li>
  <li>partial constructor patterns: <code>Cons(...)</code> and <code>Cons(p1, p2, ...)</code> (<code>NamedPartial</code>).</li>
  <li><code>Pattern.ListPat(parts)</code> syntax <code>[p1, p2, *rest]</code>, with parts:</li>
  <li><code>ListPart.Item(pat)</code>,</li>
  <li><code>ListPart.NamedList(name)</code> (<code>*name</code>),</li>
  <li><code>ListPart.WildList</code> (<code>*_</code>).</li>
  <li><code>Pattern.StrPat(parts)</code> syntax interpolated string patterns with parts:</li>
  <li><code>StrPart.LitStr(s)</code>,</li>
  <li><code>StrPart.NamedStr(name)</code> (<code>${name}</code>),</li>
  <li><code>StrPart.WildStr</code> (<code>${_}</code>),</li>
  <li><code>StrPart.NamedChar(name)</code> (<code>$.{name}</code>),</li>
  <li><code>StrPart.WildChar</code> (<code>$.{_}</code>).</li>
  <li><code>Pattern.Union(head, rest)</code> syntax <code>p1 | p2 | ...</code>.</li>
</ol>
<h3><a href="#typed-branch-plan" name="typed-branch-plan" class="anchor"><span class="anchor-link"></span></a>Typed branch plan</h3>
<p>Use an internal typed plan during generation:</p>
<pre class="prettyprint"><code class="language-scala">final case class BranchPattern(
  parsed: Pattern.Parsed,
  typed: Pattern[(PackageName, Identifier.Constructor), rankn.Type],
  scrutineeType: rankn.Type,
  bindings: Map[Identifier.Bindable, rankn.Type]
)
</code></pre>
<p><code>bindings</code> is computed while building the pattern, not recovered later by guessing.</p>
<h3><a href="#total-pattern-set-generation" name="total-pattern-set-generation" class="anchor"><span class="anchor-link"></span></a>Total pattern-set generation</h3>
<p>Define:</p>
<pre class="prettyprint"><code class="language-scala">def totalPatterns(ctx: Ctx, tpe: rankn.Type, depth: Int): NonEmptyList[BranchPattern]
</code></pre>
<p>Rules (must always return a total set):</p>
<ol>
  <li>If <code>tpe</code> root is a known defined type in <code>ctx.typeEnv</code> (including predef ADTs) and has constructors, generate one branch per constructor.</li>
  <li>Instantiate constructor argument types by substituting the type parameters of the <code>DefinedType</code> with the concrete type arguments from <code>tpe</code>.</li>
  <li>For each constructor argument type, generate subpatterns with a depth budget:</li>
  <li>prefer binders (<code>Var</code>) when branch expressions should use the value,</li>
  <li>prefer <code>_</code> when binding is unnecessary,</li>
  <li>optionally recurse into structural subpatterns for additional coverage.</li>
  <li>If no structural decomposition is available (functions, primitive numerics, opaque defined/external types, unsupported shape), return single wildcard branch <code>_</code>.</li>
  <li>Keep branches unguarded when proving totality by construction; guarded branches can be added only with an unguarded fallback branch.</li>
</ol>
<h3><a href="#definedtype-specific-totality" name="definedtype-specific-totality" class="anchor"><span class="anchor-link"></span></a>DefinedType-specific totality</h3>
<p>Given <code>dt: DefinedType[Kind.Arg]</code> and demanded type <code>T</code>:</p>
<ol>
  <li>Let <code>constructors = dt.constructors</code>.</li>
  <li>Build branch pattern for each constructor <code>cf</code> in source order.</li>
  <li>Each branch root is <code>Pattern.PositionalStruct((dt.packageName, cf.name), argsPats)</code>.</li>
  <li>If <code>constructors</code> is empty, emit wildcard-only fallback (<code>_</code>) for that type.</li>
  <li>Otherwise, this constructor-complete set is total for that <code>DefinedType</code> (modulo valid arity), so it is the default strategy for ADTs/enums.</li>
</ol>
<h3><a href="#branch-environment-extension" name="branch-environment-extension" class="anchor"><span class="anchor-link"></span></a>Branch environment extension</h3>
<p>For each generated branch:</p>
<ol>
  <li>Compute <code>branchCtx = ctx</code> extended with <code>bindings</code> from that branch pattern.</li>
  <li>Generate guard (if any) and branch body under <code>branchCtx</code>.</li>
  <li>Because each branch has different <code>bindings</code>, branch generation is independent per branch.</li>
</ol>
<h3><a href="#validation-pass-for-pattern-sets" name="validation-pass-for-pattern-sets" class="anchor"><span class="anchor-link"></span></a>Validation pass for pattern sets</h3>
<p>Before finalizing a <code>match</code>:</p>
<ol>
  <li>Convert planned patterns to typed/internal form.</li>
  <li>Run <code>TotalityCheck</code> validation (<code>validatePattern</code>, missing/unreachable checks) in test mode.</li>
  <li>If invalid/non-total, regenerate pattern set with reduced complexity or wildcard fallback.</li>
</ol>
<h2><a href="#statement-generation" name="statement-generation" class="anchor"><span class="anchor-link"></span></a>Statement Generation</h2>
<p>Use a stateful loop over <code>Ctx</code>.</p>
<h3><a href="#v1-statement-set" name="v1-statement-set" class="anchor"><span class="anchor-link"></span></a>v1 statement set</h3>
<ol>
  <li><code>Statement.Bind</code> with variable pattern only.</li>
  <li>Optional comments/padding can be added after semantic generation (do not affect typing).</li>
</ol>
<p>This already enables nontrivial typed programs through lambdas/apps/constructors.</p>
<h3><a href="#v2-statement-set" name="v2-statement-set" class="anchor"><span class="anchor-link"></span></a>v2 statement set</h3>
<ol>
  <li><code>Statement.Def</code> for named function declarations.</li>
  <li>Local <code>struct</code>/<code>enum</code> generation, then value generation that uses those constructors.</li>
</ol>
<h3><a href="#v3-statement-set" name="v3-statement-set" class="anchor"><span class="anchor-link"></span></a>v3 statement set</h3>
<ol>
  <li>Recursive defs constrained to known-safe templates.</li>
  <li>Rich patterns and guards in generated <code>match</code>.</li>
</ol>
<h2><a href="#name-and-scope-hygiene" name="name-and-scope-hygiene" class="anchor"><span class="anchor-link"></span></a>Name and Scope Hygiene</h2>
<ol>
  <li>Generate fresh bindable names not in <code>ctx.usedNames</code>.</li>
  <li>For lambdas/matches, avoid shadowing collisions by allocating fresh locals and updating context explicitly.</li>
  <li>Keep top-level names unique in v1 (simplifies witness checking and shrinking).</li>
</ol>
<h2><a href="#shrinking-strategy" name="shrinking-strategy" class="anchor"><span class="anchor-link"></span></a>Shrinking Strategy</h2>
<p>Structural shrinking alone tends to break typing. Use a typing-aware shrinker:</p>
<ol>
  <li>Remove whole statements while preserving at least one exported/main candidate.</li>
  <li>Shrink expression subtrees with typed rules (replace with in-scope variable of same type, simplify constructor args, simplify literals).</li>
  <li>Recheck candidates with the fast typecheck harness; keep only well-typed shrinks.</li>
</ol>
<p>This balances reliability and implementation cost.</p>
<h2><a href="#how-this-checks-the-compiler" name="how-this-checks-the-compiler" class="anchor"><span class="anchor-link"></span></a>How This Checks the Compiler</h2>
<p>The generator enables new properties beyond parser roundtrips.</p>
<h2><a href="#1-typecheck-success-property" name="1-typecheck-success-property" class="anchor"><span class="anchor-link"></span></a>1. Typecheck success property</h2>
<p>For all generated programs, full package typechecking succeeds:</p>
<ol>
  <li>Build a parsed package from generated statements.</li>
  <li>Run <code>PackageMap.typeCheckParsed</code> (so predef import behavior matches real compilation).</li>
  <li>Assert no type errors.</li>
</ol>
<p>This validates both generator and <code>SourceConverter</code> + infer success-path robustness.</p>
<h2><a href="#2-witness-agreement-property" name="2-witness-agreement-property" class="anchor"><span class="anchor-link"></span></a>2. Witness agreement property</h2>
<p>For <code>wellTypedProgramGen</code>, compare inferred top-level types with generator expectations:</p>
<ol>
  <li>For each generated bind <code>x : t_expected</code>,</li>
  <li>infer type <code>t_inferred</code>,</li>
  <li>validate <code>t_expected</code> is closed/resolved in <code>wellTypedProgram.typeEnv</code> (all referenced <code>TyConst</code> are known in that env),</li>
  <li>assert <code>t_inferred</code> subsumes/equates <code>t_expected</code> (modulo normalization/quantification), using the same env context.</li>
</ol>
<p>This catches generator bookkeeping bugs and inference regressions.</p>
<h2><a href="#3-normalization-equivalence-property" name="3-normalization-equivalence-property" class="anchor"><span class="anchor-link"></span></a>3. Normalization equivalence property</h2>
<p>For a generated package with a ground <code>main</code> value:</p>
<ol>
  <li>infer unoptimized body (<code>inferBodyUnopt</code>),</li>
  <li>normalize (<code>TypedExprNormalization.normalizeProgram</code>),</li>
  <li>evaluate both via <code>Evaluation</code>,</li>
  <li>assert equal resulting value.</li>
</ol>
<p>This directly tests optimization soundness on random typed source programs.</p>
<h2><a href="#4-matchless-compilation-totality-property" name="4-matchless-compilation-totality-property" class="anchor"><span class="anchor-link"></span></a>4. Matchless compilation totality property</h2>
<p>For inferred packages:</p>
<ol>
  <li>run <code>MatchlessFromTypedExpr.compile</code>,</li>
  <li>assert no exceptions and all lets compile.</li>
</ol>
<p>This is a strong stability property for the middle-end.</p>
<h2><a href="#5-backend-smoke-semantic-checks-nightly-" name="5-backend-smoke-semantic-checks-nightly-" class="anchor"><span class="anchor-link"></span></a>5. Backend smoke/semantic checks (nightly)</h2>
<p>For a restricted generated subset (ground result types, limited externals):</p>
<ol>
  <li>compile with backend(s) (C/Python as configured),</li>
  <li>evaluate <code>main</code>,</li>
  <li>compare with interpreter result.</li>
</ol>
<p>Run at lower test counts initially due runtime cost.</p>
<h2><a href="#incremental-rollout-plan" name="incremental-rollout-plan" class="anchor"><span class="anchor-link"></span></a>Incremental Rollout Plan</h2>
<ol>
  <li>Phase 1: <code>Bind</code>-only generator, base/ADT/function expressions, typecheck + matchless properties.</li>
  <li>Phase 2: add <code>Def</code>, add generated type definitions (<code>struct</code>/<code>enum</code>), add witness agreement checks.</li>
  <li>Phase 3: add <code>match</code> generation with typed patterns and guards, add normalization equivalence property.</li>
  <li>Phase 4: backend cross-checks for a restricted profile.</li>
</ol>
<h2><a href="#risks-and-mitigations" name="risks-and-mitigations" class="anchor"><span class="anchor-link"></span></a>Risks and Mitigations</h2>
<ol>
  <li>
  <p>High rejection rate from <code>OptionT</code> failures.  Mitigation: inhabited-type filtering + fallback to base goals + bounded retries.</p></li>
  <li>
  <p>Inference blowups on deep types/expressions.  Mitigation: strict depth/arity limits and weighted small-size bias.</p></li>
  <li>
  <p>Shrinker flakiness/perf cost.  Mitigation: typed rewrite shrinker first, then typecheck-filtered fallback.</p></li>
  <li>
  <p>Overfitting to current inference behavior.  Mitigation: keep generator rules type-theoretic (intro/elim) and avoid solver internals where possible.</p></li>
</ol>
<h2><a href="#why-this-design-matches-bosatsu" name="why-this-design-matches-bosatsu" class="anchor"><span class="anchor-link"></span></a>Why This Design Matches Bosatsu</h2>
<ol>
  <li>It composes with existing ASTs (<code>Statement</code>, <code>Declaration</code>) and existing test infra (<code>ScalaCheck</code>, <code>PackageMap.typeCheckParsed</code>).</li>
  <li>It follows the same environment-driven typing model used by inference.</li>
  <li>It gives a clear path from “can typecheck generated source” to “can validate compiler transformations and codegen behavior” using the same generated inputs.</li>
</ol>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/johnynek/bosatsu/tree/master/docs/src/main/paradox/design-docs/well_typed_statement_generator_design.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="../design-docs/quantifier-evidence-design.html">Quantifier Evidence on <code>TypedExpr.Annotation</code></a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="../design-docs/well_typed_statement_generator_design.html#well-typed-statement-generator-design" class="header">Well-Typed Statement Generator Design</a></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2026</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="../lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="../js/magellan.js"></script>

<style type="text/css">@import "../lib/prettify/prettify.css";</style>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '0.0.0+1-5e5bd1d1-SNAPSHOT', 'https://github.com/johnynek/bosatsu')});</script>


</html>
