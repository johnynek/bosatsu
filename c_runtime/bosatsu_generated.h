// STRUCTS
DEFINE_BSTS_OBJ(Struct2,BValue _0;BValue _1;);

BValue alloc_struct2(BValue b0, BValue b1) {
    Struct2* rc = GC_malloc(sizeof(Struct2));
    rc->_0 = b0;
    rc->_1 = b1;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct3,BValue _0;BValue _1;BValue _2;);

BValue alloc_struct3(BValue b0, BValue b1, BValue b2) {
    Struct3* rc = GC_malloc(sizeof(Struct3));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct4,BValue _0;BValue _1;BValue _2;BValue _3;);

BValue alloc_struct4(BValue b0, BValue b1, BValue b2, BValue b3) {
    Struct4* rc = GC_malloc(sizeof(Struct4));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct5,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;);

BValue alloc_struct5(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4) {
    Struct5* rc = GC_malloc(sizeof(Struct5));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct6,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;);

BValue alloc_struct6(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5) {
    Struct6* rc = GC_malloc(sizeof(Struct6));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct7,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;);

BValue alloc_struct7(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6) {
    Struct7* rc = GC_malloc(sizeof(Struct7));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct8,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;);

BValue alloc_struct8(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7) {
    Struct8* rc = GC_malloc(sizeof(Struct8));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct9,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;);

BValue alloc_struct9(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8) {
    Struct9* rc = GC_malloc(sizeof(Struct9));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct10,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;);

BValue alloc_struct10(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9) {
    Struct10* rc = GC_malloc(sizeof(Struct10));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct11,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;);

BValue alloc_struct11(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10) {
    Struct11* rc = GC_malloc(sizeof(Struct11));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct12,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;);

BValue alloc_struct12(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11) {
    Struct12* rc = GC_malloc(sizeof(Struct12));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct13,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;);

BValue alloc_struct13(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12) {
    Struct13* rc = GC_malloc(sizeof(Struct13));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct14,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;);

BValue alloc_struct14(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13) {
    Struct14* rc = GC_malloc(sizeof(Struct14));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct15,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;);

BValue alloc_struct15(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14) {
    Struct15* rc = GC_malloc(sizeof(Struct15));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct16,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;);

BValue alloc_struct16(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15) {
    Struct16* rc = GC_malloc(sizeof(Struct16));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct17,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;);

BValue alloc_struct17(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16) {
    Struct17* rc = GC_malloc(sizeof(Struct17));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct18,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;);

BValue alloc_struct18(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17) {
    Struct18* rc = GC_malloc(sizeof(Struct18));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct19,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;);

BValue alloc_struct19(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18) {
    Struct19* rc = GC_malloc(sizeof(Struct19));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct20,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;);

BValue alloc_struct20(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19) {
    Struct20* rc = GC_malloc(sizeof(Struct20));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct21,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;);

BValue alloc_struct21(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20) {
    Struct21* rc = GC_malloc(sizeof(Struct21));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct22,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;);

BValue alloc_struct22(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21) {
    Struct22* rc = GC_malloc(sizeof(Struct22));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct23,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;);

BValue alloc_struct23(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22) {
    Struct23* rc = GC_malloc(sizeof(Struct23));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct24,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;);

BValue alloc_struct24(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23) {
    Struct24* rc = GC_malloc(sizeof(Struct24));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct25,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;);

BValue alloc_struct25(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24) {
    Struct25* rc = GC_malloc(sizeof(Struct25));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct26,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;);

BValue alloc_struct26(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25) {
    Struct26* rc = GC_malloc(sizeof(Struct26));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct27,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;);

BValue alloc_struct27(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26) {
    Struct27* rc = GC_malloc(sizeof(Struct27));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct28,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;);

BValue alloc_struct28(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27) {
    Struct28* rc = GC_malloc(sizeof(Struct28));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct29,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;BValue _28;);

BValue alloc_struct29(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27, BValue b28) {
    Struct29* rc = GC_malloc(sizeof(Struct29));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    rc->_28 = b28;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct30,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;BValue _28;BValue _29;);

BValue alloc_struct30(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27, BValue b28, BValue b29) {
    Struct30* rc = GC_malloc(sizeof(Struct30));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    rc->_28 = b28;
    rc->_29 = b29;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct31,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;BValue _28;BValue _29;BValue _30;);

BValue alloc_struct31(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27, BValue b28, BValue b29, BValue b30) {
    Struct31* rc = GC_malloc(sizeof(Struct31));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    rc->_28 = b28;
    rc->_29 = b29;
    rc->_30 = b30;
    return (BValue)rc;
}

DEFINE_BSTS_OBJ(Struct32,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;BValue _28;BValue _29;BValue _30;BValue _31;);

BValue alloc_struct32(BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27, BValue b28, BValue b29, BValue b30, BValue b31) {
    Struct32* rc = GC_malloc(sizeof(Struct32));
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    rc->_28 = b28;
    rc->_29 = b29;
    rc->_30 = b30;
    rc->_31 = b31;
    return (BValue)rc;
}

// ENUMS
DEFINE_BSTS_ENUM(Enum1,BValue _0;);

BValue alloc_enum1(ENUM_TAG tag, BValue b0) {
    Enum1* rc = GC_malloc(sizeof(Enum1));
    rc->tag = tag;
    rc->_0 = b0;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum2,BValue _0;BValue _1;);

BValue alloc_enum2(ENUM_TAG tag, BValue b0, BValue b1) {
    Enum2* rc = GC_malloc(sizeof(Enum2));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum3,BValue _0;BValue _1;BValue _2;);

BValue alloc_enum3(ENUM_TAG tag, BValue b0, BValue b1, BValue b2) {
    Enum3* rc = GC_malloc(sizeof(Enum3));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum4,BValue _0;BValue _1;BValue _2;BValue _3;);

BValue alloc_enum4(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3) {
    Enum4* rc = GC_malloc(sizeof(Enum4));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum5,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;);

BValue alloc_enum5(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4) {
    Enum5* rc = GC_malloc(sizeof(Enum5));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum6,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;);

BValue alloc_enum6(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5) {
    Enum6* rc = GC_malloc(sizeof(Enum6));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum7,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;);

BValue alloc_enum7(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6) {
    Enum7* rc = GC_malloc(sizeof(Enum7));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum8,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;);

BValue alloc_enum8(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7) {
    Enum8* rc = GC_malloc(sizeof(Enum8));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum9,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;);

BValue alloc_enum9(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8) {
    Enum9* rc = GC_malloc(sizeof(Enum9));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum10,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;);

BValue alloc_enum10(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9) {
    Enum10* rc = GC_malloc(sizeof(Enum10));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum11,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;);

BValue alloc_enum11(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10) {
    Enum11* rc = GC_malloc(sizeof(Enum11));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum12,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;);

BValue alloc_enum12(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11) {
    Enum12* rc = GC_malloc(sizeof(Enum12));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum13,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;);

BValue alloc_enum13(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12) {
    Enum13* rc = GC_malloc(sizeof(Enum13));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum14,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;);

BValue alloc_enum14(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13) {
    Enum14* rc = GC_malloc(sizeof(Enum14));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum15,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;);

BValue alloc_enum15(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14) {
    Enum15* rc = GC_malloc(sizeof(Enum15));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum16,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;);

BValue alloc_enum16(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15) {
    Enum16* rc = GC_malloc(sizeof(Enum16));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum17,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;);

BValue alloc_enum17(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16) {
    Enum17* rc = GC_malloc(sizeof(Enum17));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum18,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;);

BValue alloc_enum18(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17) {
    Enum18* rc = GC_malloc(sizeof(Enum18));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum19,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;);

BValue alloc_enum19(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18) {
    Enum19* rc = GC_malloc(sizeof(Enum19));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum20,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;);

BValue alloc_enum20(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19) {
    Enum20* rc = GC_malloc(sizeof(Enum20));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum21,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;);

BValue alloc_enum21(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20) {
    Enum21* rc = GC_malloc(sizeof(Enum21));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum22,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;);

BValue alloc_enum22(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21) {
    Enum22* rc = GC_malloc(sizeof(Enum22));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum23,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;);

BValue alloc_enum23(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22) {
    Enum23* rc = GC_malloc(sizeof(Enum23));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum24,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;);

BValue alloc_enum24(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23) {
    Enum24* rc = GC_malloc(sizeof(Enum24));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum25,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;);

BValue alloc_enum25(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24) {
    Enum25* rc = GC_malloc(sizeof(Enum25));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum26,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;);

BValue alloc_enum26(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25) {
    Enum26* rc = GC_malloc(sizeof(Enum26));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum27,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;);

BValue alloc_enum27(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26) {
    Enum27* rc = GC_malloc(sizeof(Enum27));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum28,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;);

BValue alloc_enum28(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27) {
    Enum28* rc = GC_malloc(sizeof(Enum28));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum29,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;BValue _28;);

BValue alloc_enum29(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27, BValue b28) {
    Enum29* rc = GC_malloc(sizeof(Enum29));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    rc->_28 = b28;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum30,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;BValue _28;BValue _29;);

BValue alloc_enum30(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27, BValue b28, BValue b29) {
    Enum30* rc = GC_malloc(sizeof(Enum30));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    rc->_28 = b28;
    rc->_29 = b29;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum31,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;BValue _28;BValue _29;BValue _30;);

BValue alloc_enum31(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27, BValue b28, BValue b29, BValue b30) {
    Enum31* rc = GC_malloc(sizeof(Enum31));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    rc->_28 = b28;
    rc->_29 = b29;
    rc->_30 = b30;
    return (BValue)rc;
}

DEFINE_BSTS_ENUM(Enum32,BValue _0;BValue _1;BValue _2;BValue _3;BValue _4;BValue _5;BValue _6;BValue _7;BValue _8;BValue _9;BValue _10;BValue _11;BValue _12;BValue _13;BValue _14;BValue _15;BValue _16;BValue _17;BValue _18;BValue _19;BValue _20;BValue _21;BValue _22;BValue _23;BValue _24;BValue _25;BValue _26;BValue _27;BValue _28;BValue _29;BValue _30;BValue _31;);

BValue alloc_enum32(ENUM_TAG tag, BValue b0, BValue b1, BValue b2, BValue b3, BValue b4, BValue b5, BValue b6, BValue b7, BValue b8, BValue b9, BValue b10, BValue b11, BValue b12, BValue b13, BValue b14, BValue b15, BValue b16, BValue b17, BValue b18, BValue b19, BValue b20, BValue b21, BValue b22, BValue b23, BValue b24, BValue b25, BValue b26, BValue b27, BValue b28, BValue b29, BValue b30, BValue b31) {
    Enum32* rc = GC_malloc(sizeof(Enum32));
    rc->tag = tag;
    rc->_0 = b0;
    rc->_1 = b1;
    rc->_2 = b2;
    rc->_3 = b3;
    rc->_4 = b4;
    rc->_5 = b5;
    rc->_6 = b6;
    rc->_7 = b7;
    rc->_8 = b8;
    rc->_9 = b9;
    rc->_10 = b10;
    rc->_11 = b11;
    rc->_12 = b12;
    rc->_13 = b13;
    rc->_14 = b14;
    rc->_15 = b15;
    rc->_16 = b16;
    rc->_17 = b17;
    rc->_18 = b18;
    rc->_19 = b19;
    rc->_20 = b20;
    rc->_21 = b21;
    rc->_22 = b22;
    rc->_23 = b23;
    rc->_24 = b24;
    rc->_25 = b25;
    rc->_26 = b26;
    rc->_27 = b27;
    rc->_28 = b28;
    rc->_29 = b29;
    rc->_30 = b30;
    rc->_31 = b31;
    return (BValue)rc;
}

// FUNCTIONS

DEFINE_BSTS_OBJ(BoxedPureFn1, BPureFn1 fn; size_t slot_len;);

BValue alloc_closure1(size_t size, BValue* data, BClosure1 fn) {
    Closure1Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of(rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn1(BPureFn1 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn1* rc = (BoxedPureFn1*)GC_malloc(sizeof(BoxedPureFn1));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn1(BValue fn, BValue arg0) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn1 pure = (BPureFn1)PURE_VALUE(fn);
    return pure(arg0);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn1* purefn = (BoxedPureFn1*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0);
  }
  else {
    // this must be a closure:
    Closure1Data* rc = (Closure1Data*)ptr;
    BValue* data = closure_data_of(rc);
    return rc->fn(data, arg0);
  }
}


DEFINE_BSTS_OBJ(Closure2Data, BClosure2 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn2, BPureFn2 fn; size_t slot_len;);

BValue alloc_closure2(size_t size, BValue* data, BClosure2 fn) {
    Closure2Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn2(BPureFn2 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn2* rc = (BoxedPureFn2*)GC_malloc(sizeof(BoxedPureFn2));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn2(BValue fn, BValue arg0, BValue arg1) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn2 pure = (BPureFn2)PURE_VALUE(fn);
    return pure(arg0, arg1);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn2* purefn = (BoxedPureFn2*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1);
  }
  else {
    // this must be a closure:
    Closure2Data* rc = (Closure2Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1);
  }
}


DEFINE_BSTS_OBJ(Closure3Data, BClosure3 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn3, BPureFn3 fn; size_t slot_len;);

BValue alloc_closure3(size_t size, BValue* data, BClosure3 fn) {
    Closure3Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn3(BPureFn3 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn3* rc = (BoxedPureFn3*)GC_malloc(sizeof(BoxedPureFn3));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn3(BValue fn, BValue arg0, BValue arg1, BValue arg2) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn3 pure = (BPureFn3)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn3* purefn = (BoxedPureFn3*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2);
  }
  else {
    // this must be a closure:
    Closure3Data* rc = (Closure3Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2);
  }
}


DEFINE_BSTS_OBJ(Closure4Data, BClosure4 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn4, BPureFn4 fn; size_t slot_len;);

BValue alloc_closure4(size_t size, BValue* data, BClosure4 fn) {
    Closure4Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn4(BPureFn4 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn4* rc = (BoxedPureFn4*)GC_malloc(sizeof(BoxedPureFn4));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn4(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn4 pure = (BPureFn4)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn4* purefn = (BoxedPureFn4*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3);
  }
  else {
    // this must be a closure:
    Closure4Data* rc = (Closure4Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3);
  }
}


DEFINE_BSTS_OBJ(Closure5Data, BClosure5 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn5, BPureFn5 fn; size_t slot_len;);

BValue alloc_closure5(size_t size, BValue* data, BClosure5 fn) {
    Closure5Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn5(BPureFn5 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn5* rc = (BoxedPureFn5*)GC_malloc(sizeof(BoxedPureFn5));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn5(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn5 pure = (BPureFn5)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn5* purefn = (BoxedPureFn5*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4);
  }
  else {
    // this must be a closure:
    Closure5Data* rc = (Closure5Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4);
  }
}


DEFINE_BSTS_OBJ(Closure6Data, BClosure6 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn6, BPureFn6 fn; size_t slot_len;);

BValue alloc_closure6(size_t size, BValue* data, BClosure6 fn) {
    Closure6Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn6(BPureFn6 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn6* rc = (BoxedPureFn6*)GC_malloc(sizeof(BoxedPureFn6));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn6(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn6 pure = (BPureFn6)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn6* purefn = (BoxedPureFn6*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5);
  }
  else {
    // this must be a closure:
    Closure6Data* rc = (Closure6Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5);
  }
}


DEFINE_BSTS_OBJ(Closure7Data, BClosure7 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn7, BPureFn7 fn; size_t slot_len;);

BValue alloc_closure7(size_t size, BValue* data, BClosure7 fn) {
    Closure7Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn7(BPureFn7 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn7* rc = (BoxedPureFn7*)GC_malloc(sizeof(BoxedPureFn7));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn7(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn7 pure = (BPureFn7)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn7* purefn = (BoxedPureFn7*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
  }
  else {
    // this must be a closure:
    Closure7Data* rc = (Closure7Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
  }
}


DEFINE_BSTS_OBJ(Closure8Data, BClosure8 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn8, BPureFn8 fn; size_t slot_len;);

BValue alloc_closure8(size_t size, BValue* data, BClosure8 fn) {
    Closure8Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn8(BPureFn8 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn8* rc = (BoxedPureFn8*)GC_malloc(sizeof(BoxedPureFn8));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn8(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn8 pure = (BPureFn8)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn8* purefn = (BoxedPureFn8*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  }
  else {
    // this must be a closure:
    Closure8Data* rc = (Closure8Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
  }
}


DEFINE_BSTS_OBJ(Closure9Data, BClosure9 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn9, BPureFn9 fn; size_t slot_len;);

BValue alloc_closure9(size_t size, BValue* data, BClosure9 fn) {
    Closure9Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn9(BPureFn9 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn9* rc = (BoxedPureFn9*)GC_malloc(sizeof(BoxedPureFn9));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn9(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn9 pure = (BPureFn9)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn9* purefn = (BoxedPureFn9*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
  }
  else {
    // this must be a closure:
    Closure9Data* rc = (Closure9Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
  }
}


DEFINE_BSTS_OBJ(Closure10Data, BClosure10 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn10, BPureFn10 fn; size_t slot_len;);

BValue alloc_closure10(size_t size, BValue* data, BClosure10 fn) {
    Closure10Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn10(BPureFn10 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn10* rc = (BoxedPureFn10*)GC_malloc(sizeof(BoxedPureFn10));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn10(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn10 pure = (BPureFn10)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn10* purefn = (BoxedPureFn10*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
  }
  else {
    // this must be a closure:
    Closure10Data* rc = (Closure10Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
  }
}


DEFINE_BSTS_OBJ(Closure11Data, BClosure11 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn11, BPureFn11 fn; size_t slot_len;);

BValue alloc_closure11(size_t size, BValue* data, BClosure11 fn) {
    Closure11Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn11(BPureFn11 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn11* rc = (BoxedPureFn11*)GC_malloc(sizeof(BoxedPureFn11));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn11(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn11 pure = (BPureFn11)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn11* purefn = (BoxedPureFn11*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
  }
  else {
    // this must be a closure:
    Closure11Data* rc = (Closure11Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
  }
}


DEFINE_BSTS_OBJ(Closure12Data, BClosure12 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn12, BPureFn12 fn; size_t slot_len;);

BValue alloc_closure12(size_t size, BValue* data, BClosure12 fn) {
    Closure12Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn12(BPureFn12 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn12* rc = (BoxedPureFn12*)GC_malloc(sizeof(BoxedPureFn12));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn12(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn12 pure = (BPureFn12)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn12* purefn = (BoxedPureFn12*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
  }
  else {
    // this must be a closure:
    Closure12Data* rc = (Closure12Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
  }
}


DEFINE_BSTS_OBJ(Closure13Data, BClosure13 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn13, BPureFn13 fn; size_t slot_len;);

BValue alloc_closure13(size_t size, BValue* data, BClosure13 fn) {
    Closure13Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn13(BPureFn13 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn13* rc = (BoxedPureFn13*)GC_malloc(sizeof(BoxedPureFn13));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn13(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn13 pure = (BPureFn13)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn13* purefn = (BoxedPureFn13*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
  }
  else {
    // this must be a closure:
    Closure13Data* rc = (Closure13Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
  }
}


DEFINE_BSTS_OBJ(Closure14Data, BClosure14 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn14, BPureFn14 fn; size_t slot_len;);

BValue alloc_closure14(size_t size, BValue* data, BClosure14 fn) {
    Closure14Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn14(BPureFn14 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn14* rc = (BoxedPureFn14*)GC_malloc(sizeof(BoxedPureFn14));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn14(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn14 pure = (BPureFn14)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn14* purefn = (BoxedPureFn14*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
  }
  else {
    // this must be a closure:
    Closure14Data* rc = (Closure14Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
  }
}


DEFINE_BSTS_OBJ(Closure15Data, BClosure15 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn15, BPureFn15 fn; size_t slot_len;);

BValue alloc_closure15(size_t size, BValue* data, BClosure15 fn) {
    Closure15Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn15(BPureFn15 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn15* rc = (BoxedPureFn15*)GC_malloc(sizeof(BoxedPureFn15));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn15(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn15 pure = (BPureFn15)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn15* purefn = (BoxedPureFn15*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
  }
  else {
    // this must be a closure:
    Closure15Data* rc = (Closure15Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
  }
}


DEFINE_BSTS_OBJ(Closure16Data, BClosure16 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn16, BPureFn16 fn; size_t slot_len;);

BValue alloc_closure16(size_t size, BValue* data, BClosure16 fn) {
    Closure16Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn16(BPureFn16 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn16* rc = (BoxedPureFn16*)GC_malloc(sizeof(BoxedPureFn16));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn16(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn16 pure = (BPureFn16)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn16* purefn = (BoxedPureFn16*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
  }
  else {
    // this must be a closure:
    Closure16Data* rc = (Closure16Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
  }
}


DEFINE_BSTS_OBJ(Closure17Data, BClosure17 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn17, BPureFn17 fn; size_t slot_len;);

BValue alloc_closure17(size_t size, BValue* data, BClosure17 fn) {
    Closure17Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn17(BPureFn17 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn17* rc = (BoxedPureFn17*)GC_malloc(sizeof(BoxedPureFn17));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn17(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn17 pure = (BPureFn17)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn17* purefn = (BoxedPureFn17*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
  }
  else {
    // this must be a closure:
    Closure17Data* rc = (Closure17Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16);
  }
}


DEFINE_BSTS_OBJ(Closure18Data, BClosure18 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn18, BPureFn18 fn; size_t slot_len;);

BValue alloc_closure18(size_t size, BValue* data, BClosure18 fn) {
    Closure18Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn18(BPureFn18 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn18* rc = (BoxedPureFn18*)GC_malloc(sizeof(BoxedPureFn18));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn18(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn18 pure = (BPureFn18)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn18* purefn = (BoxedPureFn18*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
  }
  else {
    // this must be a closure:
    Closure18Data* rc = (Closure18Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17);
  }
}


DEFINE_BSTS_OBJ(Closure19Data, BClosure19 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn19, BPureFn19 fn; size_t slot_len;);

BValue alloc_closure19(size_t size, BValue* data, BClosure19 fn) {
    Closure19Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn19(BPureFn19 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn19* rc = (BoxedPureFn19*)GC_malloc(sizeof(BoxedPureFn19));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn19(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn19 pure = (BPureFn19)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn19* purefn = (BoxedPureFn19*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
  }
  else {
    // this must be a closure:
    Closure19Data* rc = (Closure19Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18);
  }
}


DEFINE_BSTS_OBJ(Closure20Data, BClosure20 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn20, BPureFn20 fn; size_t slot_len;);

BValue alloc_closure20(size_t size, BValue* data, BClosure20 fn) {
    Closure20Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn20(BPureFn20 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn20* rc = (BoxedPureFn20*)GC_malloc(sizeof(BoxedPureFn20));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn20(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn20 pure = (BPureFn20)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn20* purefn = (BoxedPureFn20*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
  }
  else {
    // this must be a closure:
    Closure20Data* rc = (Closure20Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19);
  }
}


DEFINE_BSTS_OBJ(Closure21Data, BClosure21 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn21, BPureFn21 fn; size_t slot_len;);

BValue alloc_closure21(size_t size, BValue* data, BClosure21 fn) {
    Closure21Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn21(BPureFn21 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn21* rc = (BoxedPureFn21*)GC_malloc(sizeof(BoxedPureFn21));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn21(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn21 pure = (BPureFn21)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn21* purefn = (BoxedPureFn21*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
  }
  else {
    // this must be a closure:
    Closure21Data* rc = (Closure21Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20);
  }
}


DEFINE_BSTS_OBJ(Closure22Data, BClosure22 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn22, BPureFn22 fn; size_t slot_len;);

BValue alloc_closure22(size_t size, BValue* data, BClosure22 fn) {
    Closure22Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn22(BPureFn22 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn22* rc = (BoxedPureFn22*)GC_malloc(sizeof(BoxedPureFn22));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn22(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn22 pure = (BPureFn22)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn22* purefn = (BoxedPureFn22*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
  }
  else {
    // this must be a closure:
    Closure22Data* rc = (Closure22Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21);
  }
}


DEFINE_BSTS_OBJ(Closure23Data, BClosure23 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn23, BPureFn23 fn; size_t slot_len;);

BValue alloc_closure23(size_t size, BValue* data, BClosure23 fn) {
    Closure23Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn23(BPureFn23 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn23* rc = (BoxedPureFn23*)GC_malloc(sizeof(BoxedPureFn23));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn23(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn23 pure = (BPureFn23)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn23* purefn = (BoxedPureFn23*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
  }
  else {
    // this must be a closure:
    Closure23Data* rc = (Closure23Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22);
  }
}


DEFINE_BSTS_OBJ(Closure24Data, BClosure24 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn24, BPureFn24 fn; size_t slot_len;);

BValue alloc_closure24(size_t size, BValue* data, BClosure24 fn) {
    Closure24Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn24(BPureFn24 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn24* rc = (BoxedPureFn24*)GC_malloc(sizeof(BoxedPureFn24));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn24(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn24 pure = (BPureFn24)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn24* purefn = (BoxedPureFn24*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
  }
  else {
    // this must be a closure:
    Closure24Data* rc = (Closure24Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23);
  }
}


DEFINE_BSTS_OBJ(Closure25Data, BClosure25 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn25, BPureFn25 fn; size_t slot_len;);

BValue alloc_closure25(size_t size, BValue* data, BClosure25 fn) {
    Closure25Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn25(BPureFn25 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn25* rc = (BoxedPureFn25*)GC_malloc(sizeof(BoxedPureFn25));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn25(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23, BValue arg24) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn25 pure = (BPureFn25)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn25* purefn = (BoxedPureFn25*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
  }
  else {
    // this must be a closure:
    Closure25Data* rc = (Closure25Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24);
  }
}


DEFINE_BSTS_OBJ(Closure26Data, BClosure26 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn26, BPureFn26 fn; size_t slot_len;);

BValue alloc_closure26(size_t size, BValue* data, BClosure26 fn) {
    Closure26Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn26(BPureFn26 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn26* rc = (BoxedPureFn26*)GC_malloc(sizeof(BoxedPureFn26));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn26(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23, BValue arg24, BValue arg25) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn26 pure = (BPureFn26)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn26* purefn = (BoxedPureFn26*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25);
  }
  else {
    // this must be a closure:
    Closure26Data* rc = (Closure26Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25);
  }
}


DEFINE_BSTS_OBJ(Closure27Data, BClosure27 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn27, BPureFn27 fn; size_t slot_len;);

BValue alloc_closure27(size_t size, BValue* data, BClosure27 fn) {
    Closure27Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn27(BPureFn27 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn27* rc = (BoxedPureFn27*)GC_malloc(sizeof(BoxedPureFn27));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn27(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23, BValue arg24, BValue arg25, BValue arg26) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn27 pure = (BPureFn27)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn27* purefn = (BoxedPureFn27*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26);
  }
  else {
    // this must be a closure:
    Closure27Data* rc = (Closure27Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26);
  }
}


DEFINE_BSTS_OBJ(Closure28Data, BClosure28 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn28, BPureFn28 fn; size_t slot_len;);

BValue alloc_closure28(size_t size, BValue* data, BClosure28 fn) {
    Closure28Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn28(BPureFn28 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn28* rc = (BoxedPureFn28*)GC_malloc(sizeof(BoxedPureFn28));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn28(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23, BValue arg24, BValue arg25, BValue arg26, BValue arg27) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn28 pure = (BPureFn28)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn28* purefn = (BoxedPureFn28*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27);
  }
  else {
    // this must be a closure:
    Closure28Data* rc = (Closure28Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27);
  }
}


DEFINE_BSTS_OBJ(Closure29Data, BClosure29 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn29, BPureFn29 fn; size_t slot_len;);

BValue alloc_closure29(size_t size, BValue* data, BClosure29 fn) {
    Closure29Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn29(BPureFn29 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn29* rc = (BoxedPureFn29*)GC_malloc(sizeof(BoxedPureFn29));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn29(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23, BValue arg24, BValue arg25, BValue arg26, BValue arg27, BValue arg28) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn29 pure = (BPureFn29)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn29* purefn = (BoxedPureFn29*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28);
  }
  else {
    // this must be a closure:
    Closure29Data* rc = (Closure29Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28);
  }
}


DEFINE_BSTS_OBJ(Closure30Data, BClosure30 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn30, BPureFn30 fn; size_t slot_len;);

BValue alloc_closure30(size_t size, BValue* data, BClosure30 fn) {
    Closure30Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn30(BPureFn30 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn30* rc = (BoxedPureFn30*)GC_malloc(sizeof(BoxedPureFn30));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn30(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23, BValue arg24, BValue arg25, BValue arg26, BValue arg27, BValue arg28, BValue arg29) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn30 pure = (BPureFn30)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn30* purefn = (BoxedPureFn30*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29);
  }
  else {
    // this must be a closure:
    Closure30Data* rc = (Closure30Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29);
  }
}


DEFINE_BSTS_OBJ(Closure31Data, BClosure31 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn31, BPureFn31 fn; size_t slot_len;);

BValue alloc_closure31(size_t size, BValue* data, BClosure31 fn) {
    Closure31Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn31(BPureFn31 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn31* rc = (BoxedPureFn31*)GC_malloc(sizeof(BoxedPureFn31));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn31(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23, BValue arg24, BValue arg25, BValue arg26, BValue arg27, BValue arg28, BValue arg29, BValue arg30) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn31 pure = (BPureFn31)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn31* purefn = (BoxedPureFn31*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30);
  }
  else {
    // this must be a closure:
    Closure31Data* rc = (Closure31Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30);
  }
}


DEFINE_BSTS_OBJ(Closure32Data, BClosure32 fn; size_t slot_len;);
DEFINE_BSTS_OBJ(BoxedPureFn32, BPureFn32 fn; size_t slot_len;);

BValue alloc_closure32(size_t size, BValue* data, BClosure32 fn) {
    Closure32Data* rc = GC_malloc(closure_data_size(size));
    rc->fn = fn;
    rc->slot_len = size;
    BValue* closure_data = closure_data_of((Closure1Data*)rc);
    memcpy(closure_data, data, sizeof(BValue*) * size);
    return (BValue)rc;
}

BValue alloc_boxed_pure_fn32(BPureFn32 fn) {
    uintptr_t fn_int = (uintptr_t)fn;
    uintptr_t small_mask = UINTPTR_MAX >> 2;
    if (fn_int <= small_mask) {
      // can pack into a pure value
      return (BValue)(TO_PURE_VALUE(fn));
    }
    BoxedPureFn32* rc = (BoxedPureFn32*)GC_malloc(sizeof(BoxedPureFn32));
    rc->fn = fn;
    rc->slot_len = 0;
    return (BValue)rc;
}

BValue call_fn32(BValue fn, BValue arg0, BValue arg1, BValue arg2, BValue arg3, BValue arg4, BValue arg5, BValue arg6, BValue arg7, BValue arg8, BValue arg9, BValue arg10, BValue arg11, BValue arg12, BValue arg13, BValue arg14, BValue arg15, BValue arg16, BValue arg17, BValue arg18, BValue arg19, BValue arg20, BValue arg21, BValue arg22, BValue arg23, BValue arg24, BValue arg25, BValue arg26, BValue arg27, BValue arg28, BValue arg29, BValue arg30, BValue arg31) {
  if (IS_PURE_VALUE(fn)) {
    // can pack into a pure value
    BPureFn32 pure = (BPureFn32)PURE_VALUE(fn);
    return pure(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30, arg31);
  }
  BValue ptr = (BValue)(fn);
  BoxedPureFn32* purefn = (BoxedPureFn32*)ptr;
  if (purefn->slot_len == 0) {
    return purefn->fn(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30, arg31);
  }
  else {
    // this must be a closure:
    Closure32Data* rc = (Closure32Data*)ptr;
    BValue* data = closure_data_of((Closure1Data*)rc);
    return rc->fn(data, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20, arg21, arg22, arg23, arg24, arg25, arg26, arg27, arg28, arg29, arg30, arg31);
  }
}

