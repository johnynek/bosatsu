<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Language Guide · Bosatsu Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='paradox docs'/>
<link rel="canonical" href="https://github.com/johnynek/bosatsulanguage_guide.html"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/warnOldVersion.js"></script>
<script type="text/javascript" src="js/groups.js"></script>
<script type="text/javascript" src="js/snippets.js"></script>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>

<!--
<link rel="shortcut icon" href="images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>Bosatsu Documentation
</a>
<div class="version-number">
0.0.0+1-fa60524e*
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="design.html" class="page">Bosatsu Design Philosophy and Goals</a></li>
  <li><a href="design-docs/index.html" class="page">Design Docs</a>
  <ul>
    <li><a href="design-docs/pattern_guards_design.html" class="page">Pattern Guards Design</a></li>
    <li><a href="design-docs/issue_1628_pattern_value_reuse_design.html" class="page">Issue 1628: Pattern Value Reuse in <code>TypedExprNormalization</code></a></li>
  </ul></li>
  <li><a href="getting_started.html" class="page">Getting started (new repo)</a></li>
  <li><a href="language_guide.html" class="active page">Language Guide</a></li>
  <li><a href="recursion.html" class="page">Recursion in Bosatsu</a></li>
  <li><a href="generating_json.html" class="page">Generating JSON from Bosatsu Values</a></li>
  <li><a href="transpile_python.html" class="page">Compiling to Python</a></li>
  <li><a href="generated/core_alpha/index.html" class="page">Core Alpha API</a>
  <ul>
    <li><a href="generated/core_alpha/Ackermann.html" class="page"><code>Ackermann</code></a></li>
    <li><a href="generated/core_alpha/AvlTree.html" class="page"><code>AvlTree</code></a></li>
    <li><a href="generated/core_alpha/Bar.html" class="page"><code>Bar</code></a></li>
    <li><a href="generated/core_alpha/BazelDepsApi.html" class="page"><code>BazelDepsApi</code></a></li>
    <li><a href="generated/core_alpha/Bo/Test.html" class="page"><code>Bo/Test</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Bool.html" class="page"><code>Bosatsu/Bool</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Char.html" class="page"><code>Bosatsu/Char</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Collection/Array.html" class="page"><code>Bosatsu/Collection/Array</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Collection/Queue.html" class="page"><code>Bosatsu/Collection/Queue</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Collection/TreeList.html" class="page"><code>Bosatsu/Collection/TreeList</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Dict.html" class="page"><code>Bosatsu/Dict</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/ApplicativeTraverse.html" class="page"><code>Bosatsu/Example/ApplicativeTraverse</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/Ci.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/Ci</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/CodecovMain.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/CodecovMain</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/DeployWeb.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/DeployWeb</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/Release.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/Release</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/Util.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/Util</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/FibBench.html" class="page"><code>Bosatsu/FibBench</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/IO/Error.html" class="page"><code>Bosatsu/IO/Error</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/IO/Std.html" class="page"><code>Bosatsu/IO/Std</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/List.html" class="page"><code>Bosatsu/List</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Nothing.html" class="page"><code>Bosatsu/Nothing</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Num/BinNat.html" class="page"><code>Bosatsu/Num/BinNat</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Num/Binary.html" class="page"><code>Bosatsu/Num/Binary</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Num/Float64.html" class="page"><code>Bosatsu/Num/Float64</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Num/Nat.html" class="page"><code>Bosatsu/Num/Nat</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/NumberProps.html" class="page"><code>Bosatsu/NumberProps</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Option.html" class="page"><code>Bosatsu/Option</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Predef.html" class="page"><code>Bosatsu/Predef</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Prog.html" class="page"><code>Bosatsu/Prog</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Rand.html" class="page"><code>Bosatsu/Rand</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Testing/Properties.html" class="page"><code>Bosatsu/Testing/Properties</code></a></li>
    <li><a href="generated/core_alpha/BuildExample.html" class="page"><code>BuildExample</code></a></li>
    <li><a href="generated/core_alpha/BuildLibrary.html" class="page"><code>BuildLibrary</code></a></li>
    <li><a href="generated/core_alpha/DictTools.html" class="page"><code>DictTools</code></a></li>
    <li><a href="generated/core_alpha/Euler/Four.html" class="page"><code>Euler/Four</code></a></li>
    <li><a href="generated/core_alpha/Euler/One.html" class="page"><code>Euler/One</code></a></li>
    <li><a href="generated/core_alpha/Euler/P5.html" class="page"><code>Euler/P5</code></a></li>
    <li><a href="generated/core_alpha/Euler/P6.html" class="page"><code>Euler/P6</code></a></li>
    <li><a href="generated/core_alpha/Euler/P7.html" class="page"><code>Euler/P7</code></a></li>
    <li><a href="generated/core_alpha/Euler/Three.html" class="page"><code>Euler/Three</code></a></li>
    <li><a href="generated/core_alpha/Euler/Two.html" class="page"><code>Euler/Two</code></a></li>
    <li><a href="generated/core_alpha/Eval.html" class="page"><code>Eval</code></a></li>
    <li><a href="generated/core_alpha/Foo.html" class="page"><code>Foo</code></a></li>
    <li><a href="generated/core_alpha/GenDeps.html" class="page"><code>GenDeps</code></a></li>
    <li><a href="generated/core_alpha/IntTest.html" class="page"><code>IntTest</code></a></li>
    <li><a href="generated/core_alpha/Issue1633.html" class="page"><code>Issue1633</code></a></li>
    <li><a href="generated/core_alpha/ListPat.html" class="page"><code>ListPat</code></a></li>
    <li><a href="generated/core_alpha/Parser.html" class="page"><code>Parser</code></a></li>
    <li><a href="generated/core_alpha/PatternExamples.html" class="page"><code>PatternExamples</code></a></li>
    <li><a href="generated/core_alpha/PredefTests.html" class="page"><code>PredefTests</code></a></li>
    <li><a href="generated/core_alpha/Quicksort.html" class="page"><code>Quicksort</code></a></li>
    <li><a href="generated/core_alpha/RecordSet/Library.html" class="page"><code>RecordSet/Library</code></a></li>
    <li><a href="generated/core_alpha/StrConcatExample.html" class="page"><code>StrConcatExample</code></a></li>
    <li><a href="generated/core_alpha/StringPatternBranchTests.html" class="page"><code>StringPatternBranchTests</code></a></li>
    <li><a href="generated/core_alpha/TypeConstraint.html" class="page"><code>TypeConstraint</code></a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="index.html">Bosatsu Documentation</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>Bosatsu Documentation
</a>
<div class="version-number">
0.0.0+1-fa60524e*
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="design.html" class="page">Bosatsu Design Philosophy and Goals</a></li>
  <li><a href="design-docs/index.html" class="page">Design Docs</a>
  <ul>
    <li><a href="design-docs/pattern_guards_design.html" class="page">Pattern Guards Design</a></li>
    <li><a href="design-docs/issue_1628_pattern_value_reuse_design.html" class="page">Issue 1628: Pattern Value Reuse in <code>TypedExprNormalization</code></a></li>
  </ul></li>
  <li><a href="getting_started.html" class="page">Getting started (new repo)</a></li>
  <li><a href="language_guide.html" class="active page">Language Guide</a></li>
  <li><a href="recursion.html" class="page">Recursion in Bosatsu</a></li>
  <li><a href="generating_json.html" class="page">Generating JSON from Bosatsu Values</a></li>
  <li><a href="transpile_python.html" class="page">Compiling to Python</a></li>
  <li><a href="generated/core_alpha/index.html" class="page">Core Alpha API</a>
  <ul>
    <li><a href="generated/core_alpha/Ackermann.html" class="page"><code>Ackermann</code></a></li>
    <li><a href="generated/core_alpha/AvlTree.html" class="page"><code>AvlTree</code></a></li>
    <li><a href="generated/core_alpha/Bar.html" class="page"><code>Bar</code></a></li>
    <li><a href="generated/core_alpha/BazelDepsApi.html" class="page"><code>BazelDepsApi</code></a></li>
    <li><a href="generated/core_alpha/Bo/Test.html" class="page"><code>Bo/Test</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Bool.html" class="page"><code>Bosatsu/Bool</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Char.html" class="page"><code>Bosatsu/Char</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Collection/Array.html" class="page"><code>Bosatsu/Collection/Array</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Collection/Queue.html" class="page"><code>Bosatsu/Collection/Queue</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Collection/TreeList.html" class="page"><code>Bosatsu/Collection/TreeList</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Dict.html" class="page"><code>Bosatsu/Dict</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/ApplicativeTraverse.html" class="page"><code>Bosatsu/Example/ApplicativeTraverse</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/Ci.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/Ci</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/CodecovMain.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/CodecovMain</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/DeployWeb.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/DeployWeb</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/Release.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/Release</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Example/Json/Github/Workflows/Util.html" class="page"><code>Bosatsu/Example/Json/Github/Workflows/Util</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/FibBench.html" class="page"><code>Bosatsu/FibBench</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/IO/Error.html" class="page"><code>Bosatsu/IO/Error</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/IO/Std.html" class="page"><code>Bosatsu/IO/Std</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/List.html" class="page"><code>Bosatsu/List</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Nothing.html" class="page"><code>Bosatsu/Nothing</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Num/BinNat.html" class="page"><code>Bosatsu/Num/BinNat</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Num/Binary.html" class="page"><code>Bosatsu/Num/Binary</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Num/Float64.html" class="page"><code>Bosatsu/Num/Float64</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Num/Nat.html" class="page"><code>Bosatsu/Num/Nat</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/NumberProps.html" class="page"><code>Bosatsu/NumberProps</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Option.html" class="page"><code>Bosatsu/Option</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Predef.html" class="page"><code>Bosatsu/Predef</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Prog.html" class="page"><code>Bosatsu/Prog</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Rand.html" class="page"><code>Bosatsu/Rand</code></a></li>
    <li><a href="generated/core_alpha/Bosatsu/Testing/Properties.html" class="page"><code>Bosatsu/Testing/Properties</code></a></li>
    <li><a href="generated/core_alpha/BuildExample.html" class="page"><code>BuildExample</code></a></li>
    <li><a href="generated/core_alpha/BuildLibrary.html" class="page"><code>BuildLibrary</code></a></li>
    <li><a href="generated/core_alpha/DictTools.html" class="page"><code>DictTools</code></a></li>
    <li><a href="generated/core_alpha/Euler/Four.html" class="page"><code>Euler/Four</code></a></li>
    <li><a href="generated/core_alpha/Euler/One.html" class="page"><code>Euler/One</code></a></li>
    <li><a href="generated/core_alpha/Euler/P5.html" class="page"><code>Euler/P5</code></a></li>
    <li><a href="generated/core_alpha/Euler/P6.html" class="page"><code>Euler/P6</code></a></li>
    <li><a href="generated/core_alpha/Euler/P7.html" class="page"><code>Euler/P7</code></a></li>
    <li><a href="generated/core_alpha/Euler/Three.html" class="page"><code>Euler/Three</code></a></li>
    <li><a href="generated/core_alpha/Euler/Two.html" class="page"><code>Euler/Two</code></a></li>
    <li><a href="generated/core_alpha/Eval.html" class="page"><code>Eval</code></a></li>
    <li><a href="generated/core_alpha/Foo.html" class="page"><code>Foo</code></a></li>
    <li><a href="generated/core_alpha/GenDeps.html" class="page"><code>GenDeps</code></a></li>
    <li><a href="generated/core_alpha/IntTest.html" class="page"><code>IntTest</code></a></li>
    <li><a href="generated/core_alpha/Issue1633.html" class="page"><code>Issue1633</code></a></li>
    <li><a href="generated/core_alpha/ListPat.html" class="page"><code>ListPat</code></a></li>
    <li><a href="generated/core_alpha/Parser.html" class="page"><code>Parser</code></a></li>
    <li><a href="generated/core_alpha/PatternExamples.html" class="page"><code>PatternExamples</code></a></li>
    <li><a href="generated/core_alpha/PredefTests.html" class="page"><code>PredefTests</code></a></li>
    <li><a href="generated/core_alpha/Quicksort.html" class="page"><code>Quicksort</code></a></li>
    <li><a href="generated/core_alpha/RecordSet/Library.html" class="page"><code>RecordSet/Library</code></a></li>
    <li><a href="generated/core_alpha/StrConcatExample.html" class="page"><code>StrConcatExample</code></a></li>
    <li><a href="generated/core_alpha/StringPatternBranchTests.html" class="page"><code>StringPatternBranchTests</code></a></li>
    <li><a href="generated/core_alpha/TypeConstraint.html" class="page"><code>TypeConstraint</code></a></li>
  </ul></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="index.html">Bosatsu Documentation</a></li>
  <li>Language Guide</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#language-guide" name="language-guide" class="anchor"><span class="anchor-link"></span></a>Language Guide</h1>
<p>This guide is a quick tour of Bosatsu syntax. For installation and running code, see <a href="getting_started.html">Getting started</a>.</p>
<h2><a href="#what-means" name="what-means" class="anchor"><span class="anchor-link"></span></a>What &ldquo;simple&rdquo; means</h2>
<p>Bosatsu aims to be simple, but not always easy.</p>
<p>Simple here means the language has a small core model: 1. structs and enums 1. creating values 1. creating functions 1. calling functions 1. matching on values to take them apart</p>
<p>Conceptually, this is close to the simply typed lambda calculus with algebraic data types, mapped onto a Python-like syntax. It is combined with a package system (<code>package</code>, <code>from ... import</code>, <code>export</code>) so code can be composed safely across libraries.</p>
<p>It is deliberately missing many common language features: methods, subtyping, mutable variables (or any mutation), casts, exceptions, and built-in magical hash/equals/string rendering behavior.</p>
<p>We want the language to be as simple as possible, but no simpler. If we relax the constraints too far, we risk losing non-negotiable properties: a sound type system we can trust, and recursion/loop forms with proven termination (so we do not admit nonsense inhabitants of types such as <code>forall a, b. a -&gt; b</code>).</p>
<h2><a href="#quick-start-5-minutes-" name="quick-start-5-minutes-" class="anchor"><span class="anchor-link"></span></a>Quick start (5 minutes)</h2>
<p>A tiny, complete file:</p>
<pre class="prettyprint"><code class="language-bosatsu">package Demo/Hello

enum Mood: Happy, Sad

def greet(m: Mood) -&gt; String:
  match m:
    case Happy: &quot;hello&quot;
    case Sad: &quot;cheer up&quot;

test = Assertion(greet(Happy) matches &quot;hello&quot;, &quot;greet&quot;)
</code></pre>
<p>Run tests from the repo root:</p>
<pre class="prettyprint"><code class="language-sh">./bosatsu lib test
</code></pre>
<h2><a href="#source-files-and-packages" name="source-files-and-packages" class="anchor"><span class="anchor-link"></span></a>Source files and packages</h2>
<p>Each file declares exactly one package at the top:</p>
<pre class="prettyprint"><code class="language-bosatsu">package Animals/Favorites
</code></pre>
<p>All external names must be explicitly imported, and all values are private unless exported:</p>
<pre class="prettyprint"><code class="language-bosatsu">package Animals/Report

from Animals/Favorites import mammals
export most_fav

most_fav = match mammals:
  case [head, *tail]: head
  case []: &quot;who knows?&quot;
</code></pre>
<h2><a href="#literals" name="literals" class="anchor"><span class="anchor-link"></span></a>Literals</h2>
<h3><a href="#signed-big-integers" name="signed-big-integers" class="anchor"><span class="anchor-link"></span></a>Signed big integers</h3>
<p>Like Python, Bosatsu supports literal signed big integers.</p>
<pre><code>x = 1
y = 42
z = -1024
</code></pre>
<h3><a href="#unicode-strings" name="unicode-strings" class="anchor"><span class="anchor-link"></span></a>Unicode strings</h3>
<p>Bosatsu files are UTF-8 files and between <code>&quot;</code> or <code>&#39;</code> characters we can create any unicode string:</p>
<pre><code>message1 = &#39;bar&#39;
message2 = &quot;this has &#39;single quotes&#39;&quot;
</code></pre>
<p>There is string interpolation syntax:</p>
<pre><code>profile = &quot;my favorite animal is ${animal}&quot;
first = &quot;first letter: $.{letter}&quot;
</code></pre>
<p>Where <code>animal</code> would be any expression that has type <code>String</code>, and <code>letter</code> has type <code>Char</code>.</p>
<h3><a href="#character-literals" name="character-literals" class="anchor"><span class="anchor-link"></span></a>Character literals</h3>
<p>Characters are single Unicode codepoints written with a leading dot:</p>
<pre><code>letter = .&#39;x&#39;
</code></pre>
<h3><a href="#lists-and-list-comprehensions" name="lists-and-list-comprehensions" class="anchor"><span class="anchor-link"></span></a>Lists and list comprehensions</h3>
<p>Like Python, Bosatsu supports a syntax for literal lists:</p>
<pre><code>favorite_animals = [&quot;elephant&quot;, &quot;humpback whale&quot;, &quot;dog&quot;]
</code></pre>
<p>Unlike Python, but like all of Bosatsu, lists are immutable values. In addition to ability to construct lists from items, we can also &ldquo;splice&rdquo; in other lists:</p>
<pre><code>new_favorites = [&quot;mammoth&quot;, *favorite_animals]
</code></pre>
<p>We can also build lists with comprehensions:</p>
<pre><code>squares = [mul(i, i) for i in range(10)]
</code></pre>
<p>Just as we can build up lists literally, we can also use match to tear them down which we discuss more later:</p>
<pre><code>top_animal = match new_favorites:
  case [most_fav, *rest]: most_fav
  case []: &quot;no favorites, :(&quot;
</code></pre>
<h2><a href="#bindings" name="bindings" class="anchor"><span class="anchor-link"></span></a>Bindings</h2>
<p>All bindings start with a lowercase character and do not contain whitespace.</p>
<p>All bindings point to immutable values, because all values are immutable in Bosatsu. Bindings, however, are almost like mutable variables due to the ability to shadow:</p>
<pre><code>def increment_by_2(x):
  x = add(x, 1)
  x = add(x, 1)
  x
</code></pre>
<p>This is a legal program. Don&rsquo;t think of x being mutated (since it isn&rsquo;t if it is captured by an anonymous function). Think of each new line being a new variable that happens to have the same value.</p>
<p>Note this is a difference from python: in python capturing works by reference, not by value, so if the original value is changed, so is the capture. Not so in Bosatsu: lexical scope is always in play.</p>
<p>We recommend not changing the type of a name in a given scope (and may enforce this in the future).</p>
<h3><a href="#naming-style" name="naming-style" class="anchor"><span class="anchor-link"></span></a>Naming style</h3>
<p>For consistency across the bosatsu compiler repository, prefer these naming conventions:</p>
<ol>
  <li>Bindable names (defs, values, parameters, locals) use lowercase with  underscore separation.</li>
  <li>Type and constructor names use UpperCamelCase.</li>
  <li>If a bindable name includes a type name, put the full type name at the end  after an underscore.</li>
</ol>
<p>Examples:</p>
<pre class="prettyprint"><code class="language-bosatsu"># preferred bindable names
def fold_left_Tree(t: Tree[a], init: b, fn: (b, a) -&gt; b) -&gt; b: ...
def one_of(ps: List[Parser[a]]) -&gt; Parser[a]: ...
def string_to_Int(s: String) -&gt; Option[Int]: ...
eq_TreeList_Int = eq_TreeList(eq_Int)

# avoid
def foldTree(...): ...     # camelCase bindable
def Tree_fold(...): ...    # type name in first position
def fold_T(...): ...       # partial/abbreviated type name
</code></pre>
<p>This convention keeps names readable and searchable, especially when multiple implementations of a common operation exist for different types.</p>
<h3><a href="#block-expressions" name="block-expressions" class="anchor"><span class="anchor-link"></span></a>Block expressions</h3>
<p>You can group a sequence of bindings and defs in parentheses to produce a value. The last expression is the result:</p>
<pre><code>result = (
  x = 1
  y = x.add(1)
  (x, y)
)
</code></pre>
<h3><a href="#left-apply-syntax" name="left-apply-syntax" class="anchor"><span class="anchor-link"></span></a>Left-Apply Syntax</h3>
<p>Left-apply (<code>&lt;-</code>) is syntax for continuation-style bindings inside blocks.</p>
<p>A line <code>pat &lt;- expr</code> appends the continuation lambda (<code>pat -&gt; ...</code>) to the outermost function application in <code>expr</code>:</p>
<pre><code>p &lt;- foo(a, b)              # foo(a, b, p -&gt; ...)
p &lt;- foo(a)(b)              # foo(a)(b, p -&gt; ...)
p &lt;- x.await()              # await(x, p -&gt; ...)
p &lt;- x.await().map(f)       # map(await(x), f, p -&gt; ...)
</code></pre>
<p>This is the Bosatsu form of await-style code, monadic-do notation, and Scala for-comprehensions.</p>
<p>Await-style example:</p>
<pre><code>def await(p, fn): p.flat_map(fn)

main = (
  args &lt;- read_env.await()
  _ &lt;- println(&quot;args = ${args}&quot;).await()
  pure(0)
)
</code></pre>
<p>List <code>flat_map</code> example:</p>
<pre><code>pair_sums = (
  x &lt;- [1, 2, 3].flat_map()
  y &lt;- [x, x.add(10)].flat_map()
  [add(x, y)]
)
</code></pre>
<p><code>Option</code> helper example:</p>
<pre><code>def if_Some(opt: Option[a], fn: a -&gt; Option[b]) -&gt; Option[b]:
  flat_map(opt, fn)

sum_if_both_some = (oa: Option[Int], ob: Option[Int]) -&gt; (
  a &lt;- oa.if_Some()
  b &lt;- ob.if_Some()
  Some(add(a, b))
)
</code></pre>
<h2><a href="#functions" name="functions" class="anchor"><span class="anchor-link"></span></a>Functions</h2>
<p>As we have seen in above examples, each function returns a single value which is the final expression in the function block. The reason for this difference with Python is that in Bosatsu, there are no side-effects. There is no reason to compute something if it is not going to be returned, and as such, the last line of every def is the return value. Like Python chooses to omit return in <code>lambda</code> expressions, we remove <code>return</code> entirely from Bosatsu.</p>
<p>Bosatsu has 32 function arities (Fn1..Fn32). A <code>def</code> with N parameters defines an FnN, and each arity is a distinct type. There is no automatic currying. If you want a function that returns a function, write that explicitly with a lambda.</p>
<p>So, we can write:</p>
<pre><code>def add_with_three(x, y):
  add(add(x, y), 3)
</code></pre>
<p>Bosatsu has anonymous function syntax. The above is almost exactly the same as:</p>
<pre><code>add_with_three = (x, y) -&gt; add(add(x, y), 3)
</code></pre>
<p>A few forms to know:</p>
<pre><code>inc = x -&gt; add(x, 1)                 # Fn1
add2 = (x, y) -&gt; add(x, y)           # Fn2
add_curried = x -&gt; y -&gt; add(x, y)    # Fn1 returning Fn1
add_tuple = ((x, y)) -&gt; add(x, y)    # Fn1 taking a tuple
</code></pre>
<p>Note the distinction between <code>(x, y) -&gt; ...</code> (Fn2) and <code>((x, y)) -&gt; ...</code> (Fn1 that takes a tuple).</p>
<p>Function parameters are patterns, so you can destructure arguments directly:</p>
<pre><code>def fst((a, _)): a
sum = ((x, y)) -&gt; add(x, y)
</code></pre>
<h3><a href="#scope-difference-for-defs" name="scope-difference-for-defs" class="anchor"><span class="anchor-link"></span></a>Scope difference for defs</h3>
<p>Unlike normal bindings, defs ARE in scope in their body. However, in order to prevent unbounded loops there are strict rules on accessing defs inside themselves. If you don&rsquo;t intend to write a recursive def, then you can never reuse or access the def&rsquo;s name anywhere inside the body. Specifically, shadowing the def name is not allowed. To write a recursive def see the section on recursive functions below.</p>
<h3><a href="#method-syntax" name="method-syntax" class="anchor"><span class="anchor-link"></span></a>Method syntax</h3>
<p>Bosatsu does not have methods, only functions, it does however have method syntax.</p>
<pre><code>form1 = add(x, y)
form2 = x.add(y)
</code></pre>
<p>The above two forms are equivalent. <code>foo.bar</code> means pass <code>foo</code> as the first argument to <code>bar</code>. This scales to more arguments:</p>
<pre><code>form3 = f(x, y, z)
form4 = x.f(y, z)
</code></pre>
<h3><a href="#operators" name="operators" class="anchor"><span class="anchor-link"></span></a>Operators</h3>
<p>Operators are just functions whose names are written with the <code>operator</code> prefix, and infix expressions call those functions:</p>
<pre><code>def operator +(a, b): a.add(b)
operator == = eq_Int

x = 1 + 2
y = 1 == 1
</code></pre>
<p>You can also import or rename operators:</p>
<pre><code>from Bosatsu/Predef import add as operator +
</code></pre>
<h3><a href="#recursive-functions" name="recursive-functions" class="anchor"><span class="anchor-link"></span></a>Recursive functions</h3>
<p>Bosatsu supports recursion through <code>recur</code>, but only in forms the compiler can prove terminate. A simple structural example:</p>
<pre><code>def len(lst):
  recur lst:
    case []: 0
    case [_, *tail]: len(tail).add(1)
</code></pre>
<p>Tail-recursive style is common:</p>
<pre><code>def len(lst):
  def loop(acc, lst):
    recur lst:
      case []: acc
      case [_, *tail]: loop(acc.add(1), tail)

  loop(0, lst)
</code></pre>
<p>For full recursion rules and advanced patterns (fuel, divide-and-conquer with a size bound, string recursion, trees, Ackermann-style nested recursion), see <a href="recursion.html">Recursion in Bosatsu</a>.</p>
<h2><a href="#loops-with-recur-" name="loops-with-recur-" class="anchor"><span class="anchor-link"></span></a>Loops (with <code>recur</code>)</h2>
<p>Bosatsu has no <code>while</code> or <code>for</code>. Loops are recursive defs using <code>recur</code>. In practice this is stricter than loops in most languages users have seen: we allow loops, but only when the compiler can prove they terminate. That restriction is what preserves type-system soundness.</p>
<p>Most loops are either: 1. structural recursion on subvalues (like a list tail or tree branch), or 1. explicit fuel recursion on a decreasing <code>Nat</code>.</p>
<p>See <a href="recursion.html">Recursion in Bosatsu</a> for detailed examples from <code>test_workspace</code>.</p>
<h2><a href="#pattern-matching" name="pattern-matching" class="anchor"><span class="anchor-link"></span></a>Pattern Matching</h2>
<p>Bosatsu has powerful pattern matching. You can match on literal values, strings and lists in addition to user defined types as discussed later. Use <code>case</code> in every match branch.</p>
<p>Here are some examples:</p>
<pre><code>result0 = match &quot;foo&quot;:
  case &quot;baz&quot;:
    &quot;we matched baz&quot;
  case &quot;foo&quot;:
    &quot;we matched foo&quot;
  case _:
    &quot;hmmm, didn&#39;t match&quot;

result1 = match &quot;foo&quot;:
  case &quot;f${rest}&quot;:
    &quot;we start with f followed by ${rest}&quot;
  case _:
    &quot;hmmm, didn&#39;t match&quot;

result2 = match [&quot;foo&quot;, &quot;bar&quot;]:
  case [&quot;f${rest}&quot;, &quot;baz&quot;]:
    &quot;this won&#39;t match&quot;
  case [&quot;f${rest}&quot;, *_]:
    &quot;we start with f followed by ${rest}&quot;
  case _:
    &quot;hmmm, didn&#39;t match&quot;

result3 = match [False, True, True]:
  case [*_, True, *_]: &quot;at least one is true&quot;
  case _: &quot;all items are false, or the list is empty&quot;

result4 = match [False, True, True]:
  case [*_, True, *tail]:
    match tail:
      case []: &quot;True with tail empty&quot;
      case [True]: &quot;True with tail == [True] (this branch matches)&quot;
      case _: &quot;True with something else&quot;
  case _: &quot;all items are false, or the list is empty&quot;
</code></pre>
<p>Match and <code>recur</code> branches can also have guards:</p>
<pre><code>result5 = match Some(1):
  case Some(v) if v.eq_Int(0): &quot;zero&quot;
  case Some(v): &quot;non-zero ${int_to_String(v)}&quot;
  case None: &quot;none&quot;
</code></pre>
<p>Guards run after the pattern matches, in the same scope as the pattern bindings. The guard expression must have type <code>Bool</code>. If the guard is <code>False</code>, matching continues with the next branch. This works the same way in <code>recur</code> blocks. For totality checking, only unguarded branches count as covering cases, so guarded branches still need an unguarded fallback. Syntax note: write at least one space between the pattern and <code>if</code>.</p>
<p>A common shorthand for checking if something matches is:</p>
<pre><code>long = match [&quot;foo&quot;, &quot;bar&quot;]:
  case [&quot;foo&quot;, *_]: True
  case _: False

short = [&quot;foo&quot;, &quot;bar&quot;] matches [&quot;foo&quot;, *_]
</code></pre>
<p>The caveat is that you cannot have any bindings in the pattern when used as a matches expression.</p>
<p>Patterns can bind the matched value with <code>as</code>:</p>
<pre><code>case Some(v) as whole: whole
case [*_, 4 as four]: four
</code></pre>
<p>Patterns can also be annotated with types using <code>pattern: Type</code>:</p>
<pre><code>case (_: Int) as last: last
</code></pre>
<p>These annotations only guide type inference; they are not runtime checks. Bosatsu has no runtime type checks—types are fully determined at compile time.</p>
<p>In string patterns, <code>${name}</code> binds a substring and <code>$.{name}</code> binds a single <code>Char</code>. Use <code>_</code> to ignore the matched part:</p>
<pre><code>case &quot;${_}$.{c}&quot;: c
</code></pre>
<p>List patterns support &ldquo;globs&rdquo; using <code>*</code>. <code>*_</code> matches any (possibly empty) sublist, and <code>*name</code> binds that sublist. Globs can appear anywhere in the list:</p>
<pre><code>case [*_, True, *_]: &quot;contains True&quot;
</code></pre>
<p>A key feature of Bosatsu pattern matching: at least one branch must match. The compiler will check this and fail to compile any code that could fail to match at runtime. The error will list the branches that are not covered.</p>
<h2><a href="#custom-data-types" name="custom-data-types" class="anchor"><span class="anchor-link"></span></a>Custom Data Types</h2>
<p>All type names start with an uppercase character. We can think of a definition as two things:</p>
<ol>
  <li>defining a new type</li>
  <li>defining a set of constructor functions to create that type</li>
</ol>
<h3><a href="#structs" name="structs" class="anchor"><span class="anchor-link"></span></a>Structs</h3>
<p>In the case of a <code>struct</code>, there is a single constructor function that can take a number of arguments which we can think of as fields to the struct. The constructor function has the same name as the type for <code>struct</code>s.</p>
<pre><code>struct HashResult(as_string: String)

struct File(name: String, modified_time: Int, size: Int, hash: HashResult)
</code></pre>
<p>There are two ways to create a struct or enum value: by treating it as a function or as a named record. The analogy you can think of is that structs are either named tuples, or named dictionaries</p>
<pre><code>my_file = File(&quot;readme.txt&quot;, 1540951025, 10240, HashResult(&quot;b9f32037daab5a0aff8e437ff1dd0f0d&quot;))

# same using record syntax
my_file_rec = File {
  name: &quot;readme.txt&quot;,
  modified_time: 1540951025,
  size: 10240,
  hash: HashResult(&quot;b9f32037daab5a0aff8e437ff1dd0f0d&quot;)
}
</code></pre>
<p>You can only use one syntax: all unnamed tuple-like, or all names dict-like.</p>
<p>Like Rust, if a value is already in scope matching a field name, we can omit the colon:</p>
<pre><code>name = &quot;readme.txt&quot;
size = 10240
hash = HashResult(&quot;b9f32037daab5a0aff8e437ff1dd0f0d&quot;)

my_file_rec = File { name, modified_time: 1540951025, size, hash }
</code></pre>
<p>There are no methods in Bosatsu, only functions. We cannot define methods on <code>struct</code>s or <code>enum</code>s. The only thing we can do with a struct or enum is match it:</p>
<pre><code>nm = match my_file:
  case File(name, _, _, _): name

# same as the above but ignoring trailing fields
nm = match my_file:
  case File(name, ...): name

# same as the above but using records
nm = match my_file:
  case File { name: n, ... }: n

# same, but omit the colon to bind the field name
nm = match my_file:
  case File { name, ... }: name
</code></pre>
<p>All matches in Bosatsu are total: one of the branches must match. We support destructuring style syntax when matches are total:</p>
<pre><code>File(nm, ...) = my_file

# or using record syntax to bind the name to nm
File { name: nm, ... } = my_file

# or using short record syntax binding name below this call
File { name, ... } = my_file
</code></pre>
<p>as a synonym for the above code.</p>
<p>In the above we have added a type annotation for each field. If we omit a type annotation, we assume any type will do so we create a new type parameter. If we need to have alignment in two type parameters, we need to explicitly name them:</p>
<pre><code># Here is a Tuple with 2 items of *any* type
struct Tuple2(fst, snd)

num_str = Tuple2(1, &quot;1&quot;)

# Here is a Pair: both have the same type:
struct Pair(fst: a, snd: a)

neg = Pair(1, -1)
</code></pre>
<p>Sometimes it is important to assign type parameters in a specific order. In those cases we can manually write them:</p>
<pre><code># put the right side type parameter first, otherwise, we would have gotten b
# first in left to right order.
struct Tuple[a, b](fst: b, snd: a)
</code></pre>
<p>Types are assigned left to right when they are omitted.</p>
<h3><a href="#limited-recursion-in-custom-data-types" name="limited-recursion-in-custom-data-types" class="anchor"><span class="anchor-link"></span></a>Limited Recursion in Custom Data Types</h3>
<p>Types must form a directed acyclic graph (DAG) with the exception that they may refer to themselves in covariant positions (i.e. not in the inputs to functions).</p>
<p>An example of a type that does not refer to itself in a covariant position is:</p>
<pre><code>struct W(fn: W[a, b] -&gt; a -&gt; b)
</code></pre>
<p>Here <code>W</code> is in scope inside the definition of W. The types, like packages, must form an acyclic graph. If we allow types like the above, we open the door to recursion at the value level since we allow the Y-combinator to be typed. By banning some recursive types, the type of fix-point combinators becomes infinite, and thus ill-typed. This restriction is currently required to preserve totality in Bosatsu (a more advanced language can allow more recursion that it can prove  does not violate totality).</p>
<p>An important recursive type we can write is <code>List</code>. In Predef we will find a standard linked list:</p>
<pre><code>enum List:
  EmptyList, NonEmptyList(head: a, tail: List[a])
</code></pre>
<p>Data-structures have two simple rules: 1. they must form a DAG 2. if they refer to themselves, they do so in covariant positions (roughly, not  as inputs to functions).</p>
<h3><a href="#tuples" name="tuples" class="anchor"><span class="anchor-link"></span></a>Tuples</h3>
<p>A built-in family of structs are tuples, which you can think of as either lists with potentially a different type in each position and a statically known size, or as an anonymous struct. We write and match them exactly as you might imagine:</p>
<pre><code>x = (1, &quot;2&quot;, [&quot;three&quot;])
# this match is total, so we can do a destructuring assignment:
(a, b, c) = x
# or we can use match syntax if that is more appropriate
match x:
  case (x, y, z): do_something(x, y, z)
</code></pre>
<p>The 0-arity tuple is written <code>()</code> and has type <code>Unit</code>. Tuples are also real predef types and can be named explicitly as <code>Tuple1</code> up to <code>Tuple32</code> (there is no <code>Tuple0</code>; <code>Unit</code> fills that role), with fields <code>item1</code>, <code>item2</code>, and so on. That lets you select parts of a tuple using record-style patterns:</p>
<pre><code>Tuple3 { item2, ... } = (1, 2, 3)
# now item2 = 2
</code></pre>
<p>This pattern is handy when you only need specific tuple positions.</p>
<h3><a href="#enums" name="enums" class="anchor"><span class="anchor-link"></span></a>Enums</h3>
<p>While <code>struct</code> represents a named tuple or product type, an <code>enum</code> represents a named sum type. This is something similar to <code>union</code> in C, <code>sealed trait</code> subclasses in Scala, or its namesake <code>enum</code> from Rust. Perhaps the most famous example is below:</p>
<pre><code>enum Option:
  None, Some(get)
</code></pre>
<p>In this example, we have omitted the type for <code>get</code>, so it can be any type. There is thus one type parameter on <code>Option</code> because <code>Some</code> requires it.</p>
<p>Consider if we want a type to be the same on two branches: we just use the same type parameter name. There is only one namespace per enum for such variables:</p>
<pre><code>enum GoodOrBad:
  Bad(bad: a), Good(good: a)
</code></pre>
<p>In the above example, <code>GoodOrBad</code> has a single type parameter <code>a</code>. So <code>Bad(1)</code> and <code>Good(1)</code> are of the same type.</p>
<h3><a href="#pattern-matching-on-custom-types" name="pattern-matching-on-custom-types" class="anchor"><span class="anchor-link"></span></a>Pattern Matching on Custom Types</h3>
<p>As we have already seen examples of, Bosatsu features powerful pattern matching. Literal values, such as integers or strings, as well as lists and tuples can appear in pattern matches. Patterns can be nested and combined in unions. There is a special wildcard term that can appear in a pattern match that is written as <code>_</code>. The wildcard matches everything but introduces no new bindings.</p>
<p>One restriction is that all match expressions in Bosatsu must be complete matches. It is a compilation error if a pattern match can fail. Remember, Bosatsu is a total language, so we must check for match totality in order to preserve totality of our functions.</p>
<p>Here are some examples of pattern matches:</p>
<pre><code>enum Either: Left(a), Right(b)

match x:
  case Left(Left(Left(_)) | Right(_)): 0
  case Left(Left(Right(_))): 1
  case Right(_): 2

match y:
  case Left(Left(x)) | Right(x):
    # here we require that the bindings in the left and right sides of
    # the union are the same and that they have the same type
    Some(x)
  case Left(Right(_)): None

# if we can write a match in a single arm, we can write it as a binding:
Left(x) | Right(x) = y
</code></pre>
<h2><a href="#types" name="types" class="anchor"><span class="anchor-link"></span></a>Types</h2>
<p>Type variables are all lower case. There is an explicit syntax for function types: <code>a -&gt; b</code> for Fn1. For higher arities, use tuple-style argument lists: <code>(a, b) -&gt; c</code> for Fn2, <code>(a, b, c) -&gt; d</code> for Fn3, and so on.</p>
<p>To write a function that takes a tuple as its single argument, use an extra layer of parentheses in both values and types. For example:</p>
<pre><code># Fn1 taking a tuple
add_tuple: ((Int, Int)) -&gt; Int = ((x, y)) -&gt; add(x, y)
</code></pre>
<p>There is support for universal quantification sometimes called generic values or generic functions: <code>forall a. a -&gt; List[a]</code>.</p>
<h3><a href="#kinds-and-variance-annotations" name="kinds-and-variance-annotations" class="anchor"><span class="anchor-link"></span></a>Kinds and variance annotations</h3>
<p>You can annotate type parameters with kinds and variance. <code>*</code> is the kind of value types, and <code>* -&gt; *</code> (or higher) are type constructors. Variance markers <code>+*</code> and <code>-*</code> mark covariant and contravariant parameters:</p>
<pre><code>enum NEList[a: +*]: NEOne(head: a), NEMore(head: a, tail: NEList[a])
struct Box[a: *](value: a)
def map[f: * -&gt; *, a, b](fa: f[a], fn: a -&gt; b) -&gt; f[b]: ...
def wrap2[shape: (* -&gt; *) -&gt; *](s: shape[List]) -&gt; shape[List]: s
</code></pre>
<p>For <code>struct</code>/<code>enum</code> definitions, kinds are inferred. For functions, kinds are not currently inferred; unannotated type parameters are assumed to be <code>*</code>.</p>
<h3><a href="#existential-types" name="existential-types" class="anchor"><span class="anchor-link"></span></a>Existential types</h3>
<p>Bosatsu also supports existential quantification to hide a type parameter chosen by the producer of a value. The syntax is <code>exists a. ...</code>, and you can quantify multiple variables with commas, e.g. <code>exists a, b. ...</code>.</p>
<p>Here is a simple example that stores an internal type but keeps it opaque in the public constructor:</p>
<pre><code>enum Build[a: *]:
  Mapped(consume: exists b. (Build[b], b -&gt; a))
  Map2(consume: exists b, c. (Build[b], Build[c], (b, c) -&gt; a))
</code></pre>
<p>When you pattern match on a constructor that contains an existential, the hidden type is scoped to that branch, so the parts that depend on it stay consistent:</p>
<pre><code>enum FreeF[a]:
  Pure(a: a)
  Mapped(tup: exists b. (FreeF[b], b -&gt; a))

def run[a](fa: FreeF[a]) -&gt; a:
  recur fa:
    case Pure(a): a
    case Mapped((prev, fn)):
      fn(run(prev))
</code></pre>
<p>When to use existentials: - To hide intermediate types in data constructors while still allowing later  consumption (e.g. <code>Mapped</code>/<code>Map2</code> store an internal <code>b</code> or <code>c</code> plus functions  that know how to use them). - To model heterogeneous or stateful structures where the internal type varies  but is not part of the public API (e.g. existential tails in custom list-like  structures, or continuations with hidden state). - To return or store values that must remain opaque to callers while keeping  internal consistency inside a match branch.</p>
<h2><a href="#the-bosatsu-predef" name="the-bosatsu-predef" class="anchor"><span class="anchor-link"></span></a>The Bosatsu Predef</h2>
<p>The predef includes Int, String, List, Option, Either types and some associated functions. It also defines the built-in test types <code>Assertion</code> and <code>TestSuite</code>.</p>
<h2><a href="#packages" name="packages" class="anchor"><span class="anchor-link"></span></a>Packages</h2>
<p>All names are private unless exported. All names from external packages must be imported. There can be no cycles in the dependency graph of Bosatsu packages.</p>
<pre><code>package Animals/Favorites
export mammals, birds

mammals = [&quot;elephant&quot;, &quot;whale&quot;, &quot;dog&quot;]

birds = [&quot;African grey parrot&quot;, &quot;macaw&quot;]
</code></pre>
<p>In some other package:</p>
<pre><code>package Animals/Report

from Animals/Favorites import mammals
export most_fav

most_fav = match mammals:
  case [head, *tail]: head
  case []: &quot;who knows?&quot;
</code></pre>
<p>You can group imports/exports with parentheses and rename with <code>as</code>:</p>
<pre><code>from Bosatsu/Predef import (foldl_List as foldl, add as operator +)
export (foldl)
</code></pre>
<p>We export types slightly differently. We can export just the type, or the type and the constructors. To export the type and the constructors use <code>Type()</code> whereas <code>Type</code> exports only the type to be visible.</p>
<pre><code>package Great/Types

export ClearOption(), OpaqueOption, foldO, noneO, someO

enum ClearOption:
  CNone, CSome(get)

enum OpaqueOption:
  ONone, OSome(get)

noneO = ONone
def someO(a): OSome(a)

def foldO(oo, if_none, if_some):
  match oo:
    case ONone: if_none
    case OSome(a): if_some(a)
</code></pre>
<p>Here ClearOption exports all its constructors so they can be pattern matched upon. In the OpaqueOption example, we export functions to create the opaque option, and a fold function to tear it down, but we can&rsquo;t explicitly pattern match on the types.</p>
<p>Sometimes such opacity is useful to enforce modularity.</p>
<h2><a href="#value-usage-requirements" name="value-usage-requirements" class="anchor"><span class="anchor-link"></span></a>Value usage requirements</h2>
<p>Bosatsu requires top-level values to be used. A top-level value must be transitively reachable from at least one of these roots: 1. an exported value 1. the package main value (the last top-level value in the package) 1. the package test value (the last top-level value with type <code>Bosatsu/Predef::Test</code>)</p>
<p>If a top-level value is not reachable from any of those roots, compilation fails with an unused-value error.</p>
<p>This rule is intentional. Unused names are often caused by typos, mistaken refactors, or dead code that is no longer needed. Requiring explicit reachability adds a small amount of friction that catches these issues early.</p>
<p>When you intentionally want to evaluate/check something and then discard it, bind it to <code>_</code>:</p>
<pre><code>_ = some_expression
</code></pre>
<p>That makes the intent explicit to readers and to the compiler.</p>
<h2><a href="#testing" name="testing" class="anchor"><span class="anchor-link"></span></a>Testing</h2>
<p>Bosatsu tests are regular values of type <code>Bosatsu/Predef::Test</code>. <code>Bosatsu/Predef</code> defines: 1. <code>Assertion(value: Bool, message: String)</code> 1. <code>TestSuite(name: String, tests: List[Test])</code></p>
<p>Common patterns in <code>test_workspace/*.bosatsu</code>: 1. A single assertion:</p>
<pre><code>test = Assertion(eq_Int(add(1, 1), 2), &quot;1 + 1 == 2&quot;)
</code></pre>
<ol>
  <li>
  <p>A suite of assertions:</p>
  <pre><code>tests = TestSuite(&quot;math tests&quot;, [
  Assertion(eq_Int(add(1, 2), 3), &quot;1 + 2&quot;),
  Assertion(eq_Int(mul(3, 4), 12), &quot;3 * 4&quot;),
])
</code></pre></li>
  <li>
  <p>Nested/composed suites, including generated tests:</p>
  <pre><code>tests = TestSuite(&quot;all tests&quot;, [
  unit_tests,
  TestSuite(&quot;generated&quot;, [mk_test(i) for i in range(10)]),
])
</code></pre></li>
</ol>
<p>Test discovery rule: <code>bosatsu lib test</code> runs the final top-level value in each package whose type is <code>Bosatsu/Predef::Test</code> (the last such value in source order). In practice, keep one final <code>test</code>/<code>tests</code> value per package and make it include all child tests you want run.</p>
<p>From the repo root, run tests with:</p>
<pre class="prettyprint"><code class="language-sh">./bosatsu lib test
</code></pre>
<p>When iterating, you can run only matching package tests with a regular expression filter:</p>
<pre class="prettyprint"><code class="language-sh">./bosatsu lib test --filter &quot;MyLib/.*&quot;
</code></pre>
<p><code>--filter</code> matches package names and can be provided more than once.</p>
<h2><a href="#purity-effects-and-prog" name="purity-effects-and-prog" class="anchor"><span class="anchor-link"></span></a>Purity, Effects, and <code>Prog</code></h2>
<p>Bosatsu expressions are pure: evaluating Bosatsu code does not directly read stdin, write stdout, mutate state, or throw exceptions.</p>
<p>Instead, effectful behavior is represented as data using <code>Prog[env, err, a]</code>. When you write I/O-heavy code, you are building a program description inside Bosatsu. That description can be transformed and composed (for example with <code>map</code>, <code>flat_map</code>, or <code>await</code>-style syntax), but it is not executed by Bosatsu itself.</p>
<p>Execution happens only when a runtime is given a <code>Main</code> program entrypoint. In other words, Bosatsu builds the effectful program, and the runtime executes it.</p>
<p>This is the same core idea used in pure functional programming (for example, Haskell <code>IO</code> or Scala <code>cats.effect.IO</code>): represent effects explicitly and keep core language evaluation pure. Bosatsu goes further by not exposing a general in-language escape hatch to &ldquo;unsafely run&rdquo; a <code>Prog</code> immediately.</p>
<p>You can think of Bosatsu as a pure language for constructing executable programs with effects at the boundary. The goal is practical usability with strong safety: if pieces typecheck, they can be composed with confidence.</p>
<h2><a href="#external-functions-and-values" name="external-functions-and-values" class="anchor"><span class="anchor-link"></span></a>External functions and values</h2>
<p>There is syntax for declaring external values and functions, but regular Bosatsu library code cannot define new externals today.</p>
<p>At the moment, external defs are only allowed in trusted libraries implemented inside the bosatsu compiler repository. This is intentional: Bosatsu is designed for safe composition, and if any dependency could hide unsafe behavior, that safety story gets much weaker.</p>
<p>So &ldquo;use with caution&rdquo; mostly applies to maintainers of trusted runtime/predef code, not to ordinary Bosatsu library authors.</p>
<p>An example function we cannot implement in Bosatsu is:</p>
<pre><code>def int_loop(int_v: Int, state: a, fn: (Int, a) -&gt; (Int, a)) -&gt; a:
  if cmp_Int(int_v, 0) matches GT:
    (next_i, next_state) = fn(int_v, state)
    if cmp_Int(next_i, int_v) matches LT:
      # make sure we always decrease int_v
      int_loop(next_i, next_state, fn)
    else:
      next_state
  else:
    state
</code></pre>
<p>We cannot write this function, even though it is total, because Bosatsu cannot prove that the loop terminates. The only recursions we can do are on values that are substructures of inputs in the same position. This gives a simple proof that the loop will terminate.</p>
<p>Instead, we implement this function in Predef as an external def that has to be supplied to the compiler with a promise that it is total and matches its declared type.</p>
<pre><code>external def int_loop(intValue: Int, state: a, fn: (Int, a) -&gt; (Int, a)) -&gt; a
</code></pre>
<p>External values and types work exactly like internally defined types from any other point of view.</p>
<p>External defs are only supported in libraries implemented inside the compiler repo. The functions must be implemented in the C runtime, and there is currently no provision for providing external implementations from outside the compiler repo. This restriction is intentional to preserve totality, and we do not expect to lift it any time soon.</p>
<p>Because these externals are trusted code, each external def included with the compiler is reviewed and tested carefully to avoid breaking sound typing. This is the central safety goal: if a program typechecks, running it should not produce a value that violates its type.</p>
<p>In the future, we may consider an explicit unsafe boundary (similar in spirit to Rust <code>unsafe</code>) where external defs and calls are marked and that annotation is propagated through callers. That would make the safety/power trade-off explicit. Our bias is strongly toward safety; if you want maximum unrestricted power, this is likely not the right language.</p>
<h1><a href="#note-on-totality" name="note-on-totality" class="anchor"><span class="anchor-link"></span></a>Note on Totality</h1>
<p>Totality is an interesting property that limits a language from being turing complete, however, it is not obvious if that is much of a practical limit. People often criticize fully general languages for configuration, but it is not clear that non-termination or partial functions are the problems.</p>
<p>One can easily argue that total languages are still too big. For instance imagine a function with type <code>a -&gt; Either[a, b]</code> which takes an <code>a</code> and either returns a final <code>b</code> value or the next step <code>a</code> that we should call again. If we have a non-total language we could repeatedly call the function when we have left to build <code>a -&gt; b</code>. In a total language, we could build a</p>
<pre><code>def repeat(n: Int, fn: a -&gt; Either[a, b]) -&gt; (a -&gt; Either[a, b])
</code></pre>
<p>to repeat <code>n</code> times the fn unless we find a b and build a function of the same type that loops more times. By repeatedly applying this function: <code>repeat(1000, repeat(1000, ... repeat(1000, fn)...</code> we can make an exponentially large number of attempts. So we could easily build a function that would take <code>2^128</code> attempts which would take longer than the life of the sun to complete. Is this meaningfully different from an infinite loop?</p>
<p>Our view is that the first goal is a sound type system we can trust. Totality is one important tool for that goal: it helps ensure evaluation produces values of the declared type instead of getting stuck in partial behavior. Termination by itself is not a performance guarantee, since terminating programs can still be exponentially expensive. Therefore, the only possible runtime failure for well-typed pure Bosatsu code is exhausting memory, which is a risk in virtually every programming language.</p>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/johnynek/bosatsu/tree/master/docs/src/main/paradox/language_guide.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="recursion.html">Recursion in Bosatsu</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="language_guide.html#language-guide" class="header">Language Guide</a>
  <ul>
    <li><a href="language_guide.html#what-means" class="header">What &ldquo;simple&rdquo; means</a></li>
    <li><a href="language_guide.html#quick-start-5-minutes-" class="header">Quick start (5 minutes)</a></li>
    <li><a href="language_guide.html#source-files-and-packages" class="header">Source files and packages</a></li>
    <li><a href="language_guide.html#literals" class="header">Literals</a></li>
    <li><a href="language_guide.html#bindings" class="header">Bindings</a></li>
    <li><a href="language_guide.html#functions" class="header">Functions</a></li>
    <li><a href="language_guide.html#loops-with-recur-" class="header">Loops (with <code>recur</code>)</a></li>
    <li><a href="language_guide.html#pattern-matching" class="header">Pattern Matching</a></li>
    <li><a href="language_guide.html#custom-data-types" class="header">Custom Data Types</a></li>
    <li><a href="language_guide.html#types" class="header">Types</a></li>
    <li><a href="language_guide.html#the-bosatsu-predef" class="header">The Bosatsu Predef</a></li>
    <li><a href="language_guide.html#packages" class="header">Packages</a></li>
    <li><a href="language_guide.html#value-usage-requirements" class="header">Value usage requirements</a></li>
    <li><a href="language_guide.html#testing" class="header">Testing</a></li>
    <li><a href="language_guide.html#purity-effects-and-prog" class="header">Purity, Effects, and <code>Prog</code></a></li>
    <li><a href="language_guide.html#external-functions-and-values" class="header">External functions and values</a></li>
    <li><a href="language_guide.html#note-on-totality" class="header">Note on Totality</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2026</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '0.0.0+1-fa60524e-SNAPSHOT', 'https://github.com/johnynek/bosatsu')});</script>


</html>
