<!DOCTYPE html>
<html class="no-js" lang="en">

<head>
<title>Language Guide · Bosatsu Documentation</title>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="description" content='paradox docs'/>
<link href="https://fonts.googleapis.com/css?family=Roboto:100normal,100italic,300normal,300italic,400normal,400italic,500normal,500italic,700normal,700italic,900normal,900italicc" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="lib/jquery/jquery.min.js"></script>
<script type="text/javascript" src="js/page.js"></script>
<script type="text/javascript" src="js/warnOldVersion.js"></script>
<script type="text/javascript" src="js/groups.js"></script>
<link rel="stylesheet" type="text/css" href="lib/foundation/dist/foundation.min.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>

<!--
<link rel="shortcut icon" href="images/favicon.ico" />
-->
</head>

<body>
<div class="off-canvas-wrapper">
<div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

<div class="off-canvas position-left" id="off-canvas-menu" data-off-canvas>
<nav class="off-canvas-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>Bosatsu Documentation
</a>
<div class="version-number">
0.1.0*
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="design.html" class="page">Bosatsu Design Philosophy and Goals</a></li>
  <li><a href="getting_started.html" class="page">Getting started</a></li>
  <li><a href="language_guide.html" class="active page">Language Guide</a></li>
  <li><a href="generating_json.html" class="page">Generating JSON from Bosatsu Values</a></li>
  <li><a href="transpile_python.html" class="page">Compiling to Python</a></li>
</ul>
</div>

</nav>
</div>

<div class="off-canvas-content" data-off-canvas-content>

<header class="site-header expanded row">
<div class="small-12 column">
<a href="#" class="off-canvas-toggle hide-for-medium" data-toggle="off-canvas-menu"><svg class="svg-icon svg-icon-menu" version="1.1" id="Menu" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20" enable-background="new 0 0 20 20" xml:space="preserve"> <path class="svg-icon-menu-path" fill="#53CDEC" d="M16.4,9H3.6C3.048,9,3,9.447,3,10c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,9.447,16.952,9,16.4,9z M16.4,13
H3.6C3.048,13,3,13.447,3,14c0,0.553,0.048,1,0.6,1H16.4c0.552,0,0.6-0.447,0.6-1C17,13.447,16.952,13,16.4,13z M3.6,7H16.4
C16.952,7,17,6.553,17,6c0-0.553-0.048-1-0.6-1H3.6C3.048,5,3,5.447,3,6C3,6.553,3.048,7,3.6,7z"/></svg>
</a>
<div class="title"><a href="index.html">Bosatsu Documentation</a></div>

<!--
<a href="https://www.example.com" class="logo show-for-medium">logo</a>
-->
</div>
</header>

<div class="expanded row">

<div class="medium-3 large-2 show-for-medium column">
<nav class="site-nav">
<div class="nav-home">
<a href="index.html" >
<span class="home-icon">⌂</span>Bosatsu Documentation
</a>
<div class="version-number">
0.1.0*
</div>
</div>
<div class="nav-toc">
<ul>
  <li><a href="design.html" class="page">Bosatsu Design Philosophy and Goals</a></li>
  <li><a href="getting_started.html" class="page">Getting started</a></li>
  <li><a href="language_guide.html" class="active page">Language Guide</a></li>
  <li><a href="generating_json.html" class="page">Generating JSON from Bosatsu Values</a></li>
  <li><a href="transpile_python.html" class="page">Compiling to Python</a></li>
</ul>
</div>

</nav>
</div>

<div class="small-12 medium-9 large-10 column">
<section class="site-content">

<span id="version-warning"></span>

<div class="page-header row">
<div class="medium-12 show-for-medium column">
<div class="nav-breadcrumbs">
<ul>
  <li><a href="index.html">Bosatsu Documentation</a></li>
  <li>Language Guide</li>
</ul>
</div>
</div>
</div>

<div class="page-content row">
<div class="small-12 large-9 column" id="docs">
<h1><a href="#language-guide" name="language-guide" class="anchor"><span class="anchor-link"></span></a>Language Guide</h1>
<p>This is a brief language guide to describe Bosatsu syntax.</p>
<h2><a href="#literals" name="literals" class="anchor"><span class="anchor-link"></span></a>Literals</h2>
<h3><a href="#signed-big-integers" name="signed-big-integers" class="anchor"><span class="anchor-link"></span></a>Signed big integers</h3>
<p>Like Python, Bosatsu supports literal signed big integers.</p>
<pre><code>x = 1
y = 42
z = -1024
</code></pre>
<h3><a href="#unicode-strings" name="unicode-strings" class="anchor"><span class="anchor-link"></span></a>Unicode strings</h3>
<p>Bosatsu files are UTF-8 files and between <code>&quot;</code> or <code>&#39;</code> characters we can create any unicode string:</p>
<pre><code>message1 = &#39;bar&#39;
message2 = &quot;this has &#39;single quotes&#39;&quot;

</code></pre>
<p>There is string interpolation syntax:</p>
<pre><code>profile = &#39;my favorite animal is ${animal}&#39;
</code></pre>
<p>Where <code>animal</code> would be any expression that has type <code>String</code>.</p>
<h3><a href="#lists" name="lists" class="anchor"><span class="anchor-link"></span></a>Lists</h3>
<p>Like Python, Bosatsu supports a syntax for literal lists:</p>
<pre><code>favorite_animals = [&quot;elephant&quot;, &quot;humpback whale&quot;, &quot;dog&quot;]
</code></pre>
<p>Unlike Python, but like all of Bosatsu, lists are immutable values. In addition to ability to construct lists from items, we can also &ldquo;splice&rdquo; in other lists:</p>
<pre><code>new_favorites = [&quot;mammoth&quot;, *favorite_animals]
</code></pre>
<p>Just as we can build up lists literally, we can also use match to tear them down which we discuss more later:</p>
<pre><code>top_animal = match new_favorites:
  [most_fav, *rest]: most_fav
  []: &quot;no favorites, :(&quot;
</code></pre>
<h2><a href="#variables" name="variables" class="anchor"><span class="anchor-link"></span></a>Variables</h2>
<p>All bindings start with a lowercase character and do not contain whitespace.</p>
<p>All bindings point to immutable values, because all values are immutable in Bosatsu. Bindings, however, are almost like mutable variables due to the ability to shadow:</p>
<pre><code><br/>def increment_by_2(x):
  x = add(x, 1)
  x = add(x, 1)
  x

</code></pre>
<p>This is a legal program. Don&rsquo;t think of x being mutated (since it isn&rsquo;t if it is captured by an anonymous function). Think of each new line being a new variable that happens to have the same value.</p>
<p>Note this is a difference from python: in python capturing works by reference, not by value, so if the original value is changed, so is the capture. Not so in Bosatsu: lexical scope is always in play.</p>
<p>We recommend not changing the type of a name in a given scope (and may enforce this in the future).</p>
<h2><a href="#pattern-matching" name="pattern-matching" class="anchor"><span class="anchor-link"></span></a>Pattern Matching</h2>
<p>Bosatsu has powerful pattern matching. You can match on literal values, strings and lists in addition to user defined types as discussed later.</p>
<p>Here are some examples:</p>
<pre><code>result0 = match &quot;foo&quot;:
  &quot;baz&quot;:
    &quot;we matched baz&quot;
  &quot;foo&quot;:
    &quot;we matched foo&quot;
  _:
    &quot;hmmm, didn&#39;t match&quot;

result1 = match &quot;foo&quot;:
  &quot;f${rest}&quot;:
    &quot;we start with f followed by ${rest}&quot;
  _:
    &quot;hmmm, didn&#39;t match&quot;

result2 = match [&quot;foo&quot;, &quot;bar&quot;]:
  [&quot;f${rest}&quot;, &quot;baz&quot;]:
    &quot;this won&#39;t match&quot;
  [&quot;f${rest}&quot;, *_]:
    &quot;we start with f followed by ${rest}&quot;
  _:
    &quot;hmmm, didn&#39;t match&quot;

result3 = match [False, True, True]:
  [*_, True, *_]: &quot;at least one is true&quot;
  _: &quot;all items are false, or the list is empty&quot;

result4 = match [False, True, True]:
  [*_, True, *tail]:
    match tail:
      []: &quot;True with tail empty&quot;
      [True]: &quot;True with tail == [True] (this branch matches)&quot;
      _: &quot;True with something else&quot;
  _: &quot;all items are false, or the list is empty&quot;
</code></pre>
<p>A common shorthand for checking if something matches is:</p>
<pre><code>long = match [&quot;foo&quot;, &quot;bar&quot;]:
  [&quot;foo&quot;, *_]: True
  _: False

short = [&quot;foo&quot;, &quot;bar&quot;] matches [&quot;foo&quot;, *_]
</code></pre>
<p>The caveat is that you cannot have any bindings in the pattern when used as a matches expression.</p>
<p>A key feature of Bosatsu pattern matching: at least one branch must match. The compiler will check this and fail to compile any code that could fail to match at runtime. The error will list the branches that are not covered.</p>
<h2><a href="#functions" name="functions" class="anchor"><span class="anchor-link"></span></a>Functions</h2>
<p>As we have seen in above examples, each function returns a single value which is the final expression in the function block. The reason for this difference with Python is that in Bosatsu, there are no side-effects. There is no reason to compute something if it is not going to be returned, and as such, the last line of every def would be a return. Like Python chooses to omit return in <code>lambda</code> expressions, we choose to remove <code>return</code> entirely from bosatsu.</p>
<p>All functions internally are functions of a single value returning a single value. We have syntax to call multiple variable functions, but that is just syntactic sugar over curried functions.</p>
<p>So, we can write:</p>
<pre><code>def add_with_three(x, y):
  add_Int(add_Int(x, y), 3)
</code></pre>
<p>using the <code>add_Int</code> function from the <code>Bosatsu/Predef</code>. Bosatsu also has anonymous function syntax similar to Haskell. The above is almost exactly the same as:</p>
<pre><code>add_with_three = \x, y -&gt; add_Int(add_Int(x, y), 3)
</code></pre>
<p>or even</p>
<pre><code>add_with_three = \x -&gt; \y -&gt; add_Int(add_Int(x, y), 3)
</code></pre>
<p>Think of <code>\</code> ans an ASCII version of <code>λ</code>.</p>
<p>All of these functions have type <code>Int -&gt; Int -&gt; Int</code>, which is to say, given two integers (the two on the left) we can produce a new integer (always! Remember Bosatsu is total, no exceptions!).</p>
<h3><a href="#scope-difference-for-defs" name="scope-difference-for-defs" class="anchor"><span class="anchor-link"></span></a>Scope difference for defs</h3>
<p>Unlike normal bindings, defs ARE in scope in their body. However, in order to prevent unbounded loops there are strict rules on accessing defs inside themselves. If you don&rsquo;t intend to write a recursive def, then you can never reuse or access the defs name anywhere inside the body. Specifically, shadowing the def name is not allowed. To write a recursive def see the section on recursive functions below.</p>
<h3><a href="#method-syntax" name="method-syntax" class="anchor"><span class="anchor-link"></span></a>Method syntax</h3>
<p>Bosatu does not have methods, only functions, it does however have method syntax.</p>
<pre><code>form1 = add(x, y)
form2 = x.add(y)
</code></pre>
<p>The above to forms are equivalent. <code>foo.bar</code> means pass <code>foo</code> as the first argument to <code>bar</code>. Since all functions are functions of a single argument:</p>
<pre><code>inc10 = add(10)
inc10_again = 10.add
</code></pre>
<p>both of these two values <code>inc10</code> and <code>inc10_again</code> have the type <code>Int -&gt; Int</code> and do the same thing: they add <code>10</code> to an integer.</p>
<h3><a href="#recursive-functions" name="recursive-functions" class="anchor"><span class="anchor-link"></span></a>Recursive functions</h3>
<p>We have very limited support for recursion so that we may prove that all recursive functions terminate. Here is an example:</p>
<pre><code>def len(lst):
  recur lst:
    []: 0
    [_, *tail]: len(tail).add(1)
</code></pre>
<p>In the above, we see the <code>recur</code> syntax. This is a normal match with two restrictions: 1. it can only be on a literal parameter of the nearest enclosing def, 2. a function may have at most one recur in a body, which is not enclosed by a inner def. Inside the branches of such a recur, recursion on the enclosing def is permitted if it meets certain constraints which prevent unbounded loops:</p>
<p>In at least one branch of the recur match there must be a recursive call that must take a substructure of the argument the recur is matching on. In the above example, tail is a substructure of lst, and is used in the same parameter as list appeared in.</p>
<p>These are strict rules, but they guarantee that each recursive function terminates in a finite number of steps, and can never loop forever. The recommendation is to avoid recursive defs as much as possible and limit the number of arguments as much as possible.</p>
<p>Tail recursive loops are optimized into loops, which are safe for cases where recursion depth is high. If you can, prefer to use tail recursive loops:</p>
<pre><code>def len(lst):
  def loop(acc, lst):
    recur lst:
      []: acc
      [_, *tail]: loop(acc.add(1), tail)

  loop(0, lst)
</code></pre>
<h2><a href="#custom-data-types" name="custom-data-types" class="anchor"><span class="anchor-link"></span></a>Custom Data Types</h2>
<p>All type names start with an uppercase character. We can think of a definition as two things:</p>
<ol>
  <li>defining a new type</li>
  <li>defining a set of constructor functions to create that type</li>
</ol>
<h3><a href="#structs" name="structs" class="anchor"><span class="anchor-link"></span></a>Structs</h3>
<p>In the case of a <code>struct</code>, there is a single constructor function that can take a number of arguments which we can think of as fields to the struct. The constructor function has the same name as the type for <code>struct</code>s.</p>
<pre><code>struct HashResult(as_string: String)

struct File(name: String, modified_time: Int, size: Int, hash: HashResult)
</code></pre>
<p>There are two ways to create a struct or enum value: by treating it as a function or as a named record. The analogy you can think of is that structs are either named tuples, or named dictionaries</p>
<pre><code>my_file = File(&quot;readme.txt&quot;, 1540951025, 10240, HashResult(&quot;b9f32037daab5a0aff8e437ff1dd0f0d&quot;))

# same using record syntax
my_file_rec = File {
  name: &quot;readme.txt&quot;,
  modified_time: 1540951025,
  size: 10240,
  hash: HashResult(&quot;b9f32037daab5a0aff8e437ff1dd0f0d&quot;)
}
</code></pre>
<p>You can only use one syntax: all unamed tuple-like, or all names dict-like.</p>
<p>Like Rust, if a value is already in scope matching a field name, we can omit the colon:</p>
<pre><code>name = &quot;readme.txt&quot;
size = 10240
hash = HashResult(&quot;b9f32037daab5a0aff8e437ff1dd0f0d&quot;)

my_file_rec = File { name, modified_time: 1540951025, size, hash }
</code></pre>
<p>There are no methods in bosatsu, only functions. We cannot define methods on <code>struct</code>s or <code>enum</code>s. The only thing we can do with a struct or enum is match it:</p>
<pre><code>nm = match my_file:
  File(name, _, _, _): name

# same as the above but ignoring trailing fields
nm = match my_file:
  File(name, ...): name

# same as the above but using records
nm = match my_file:
  File { name: n, ... }: n

# same, but omit the colon to bind the field name
nm = match my_file:
  File { name, ... }: name
</code></pre>
<p>All matches in Bosatsu are total: one of the branches must match. We support destructuring style syntax when matches are total:</p>
<pre><code>File(nm, ...) = my_file

# or using record syntax to bind the name to nm
File { name: nm, ... } = my_file

# or using short record syntax binding name below this call
File { name, ... } = my_file
</code></pre>
<p>as a synonym for the above code.</p>
<p>In the above we have added a type annotation for each field. If we omit a type annotation, we assume any type will do so we create a new type parameter. If we need to have alignment in two type parameters, we need to explicitly name them:</p>
<pre><code># Here is a Tuple with 2 items of *any* type
struct Tuple2(fst, snd)

num_str = Tuple2(1, &quot;1&quot;)

# Here is a Pair: both have the same type:
struct Pair(fst: a, snd: a)

neg = Pair(1, -1)

</code></pre>
<p>Sometimes it is important to assign type parameters in a specific order. In those cases we can manually write them:</p>
<pre><code># put the right side type parameter first, otherwise, we would have gotten b first in left to right order.
struct Tuple[a, b](fst: b, snd: a)
</code></pre>
<p>Types are assigned left to right when they are omitted.</p>
<h3><a href="#limited-recursion-in-custom-data-types" name="limited-recursion-in-custom-data-types" class="anchor"><span class="anchor-link"></span></a>Limited Recursion in Custom Data Types</h3>
<p>Types must form a directed acyclic graph (DAG) with the exception that they may refer to themselves in covariant positions (i.e. not in the inputs to functions).</p>
<p>An example of a type that does not refer to itself in the covariant position is:</p>
<pre><code>struct W(fn: W[a, b] -&gt; a -&gt; b)
</code></pre>
<p>Here <code>W</code> is in scope inside the definition of W. The types, like packages, must form an acyclic graph. If we allow types like the above, we actually open the door to recursion at the value level since we allow the y-combinator to be typed. By banning some recursive types, the type of fix-point combinators becomes infinite, and thus ill-typed. This restriction is currently required to preserve totality in Bosatsu (a more advanced language can allow more recursion that it can prove does not violate totality).</p>
<p>An import recursive type we can write is <code>List</code>. Indeed in Predef we will find a standard linked list:</p>
<pre><code>enum List:
  Empty, NonEmpty(head: a, tail: List[a])
</code></pre>
<p>Data-structures have two simple rules: 1. they must form a DAG 2. if they refer to themselves, they do so in covariant positions (roughly, not as inputs to  functions).</p>
<h3><a href="#tuples" name="tuples" class="anchor"><span class="anchor-link"></span></a>Tuples</h3>
<p>A built-in family of structs are tuples, which you can think of as either lists with potentially a different type in each position and a statically known size, or as an anonymous struct. We write and match them exactly as you might imagine:</p>
<pre><code>x = (1, &quot;2&quot;, [&quot;three&quot;])
# this match is total, so we can do a destructuring assignment:
(a, b, c) = x
# or we can use match syntax if that is more appropriate
match x:
  (x, y, z): do_something(x, y, z)
</code></pre>
<h3><a href="#enums" name="enums" class="anchor"><span class="anchor-link"></span></a>Enums</h3>
<p>While <code>struct</code> represents a named tuple or product type, an <code>enum</code> represents a named sum type. This is something similar to <code>union</code> in C, <code>sealed trait</code> subclasses in Scala, or its namesake <code>enum</code> from Rust. Perhaps the most famous example is below:</p>
<pre><code>enum Option:
  None, Some(get)
</code></pre>
<p>In this example, we have omitted the type for <code>get</code>, so it can be any type. There is thus one type parameter on <code>Option</code> because <code>Some</code> requires it.</p>
<p>Consider if we want a type to be the same on two branches: we just use the same type parameter name. There is only one namespace per enum for such variables:</p>
<pre><code>enum GoodOrBad:
  Bad(bad: a), Good(good: a)
</code></pre>
<p>In the above example, <code>GoodOrBad</code> has a single type parameter <code>a</code>. So <code>Bad(1)</code> and <code>Good(1)</code> are of the same type.</p>
<h3><a href="#pattern-matching-on-custom-types" name="pattern-matching-on-custom-types" class="anchor"><span class="anchor-link"></span></a>Pattern Matching on Custom Types</h3>
<p>As we have already seen examples of, Bosatsu features powerful pattern matching. Literal values, such as integers or strings, as well as lists and tuples can appear in pattern matches. Patterns can be nested and combined in unions. There is a special wildcard term that can appear in a pattern match that is written as <code>_</code>. The wildcard matches everything but introduces no new bindings.</p>
<p>On restriction is that all match expressions in Bosatsu must be complete matches. It is a compilation error if a pattern match can fail. Remember, Bosatsu is a total language, so we must check for match totality in order to preserve totality of our functions.</p>
<p>Here are some examples of pattern matches:</p>
<pre><code>enum Either: Left(a), Right(b)

match x:
  Left(Left(Left(_)) | Right(_)): 0
  Left(Left(Right(_))): 1
  Right(_): 2

match y:
  Left(Left(x)) | Right(x):
    # here we require that the bindings in the left and right sides of
    # the union are the same and that they have the same type
    Some(x)
  Left(Right(_)): None

# if we can write a match in a single arm, we can write it as a binding:
Left(x) | Right(x) = y
</code></pre>
<h2><a href="#types" name="types" class="anchor"><span class="anchor-link"></span></a>Types</h2>
<p>Type variables are all lower case. There is an explicit syntax for function type: <code>a -&gt; b</code>. There is support for universal quantification sometimes called generic values or generic functions: <code>forall a. a -&gt; List[a]</code>.</p>
<h2><a href="#the-bosatsu-predef" name="the-bosatsu-predef" class="anchor"><span class="anchor-link"></span></a>The Bosatsu Predef</h2>
<p>The predef includes Int, String, List, Option, Either types and some associated functions.</p>
<h2><a href="#packages" name="packages" class="anchor"><span class="anchor-link"></span></a>Packages</h2>
<p>All names are private unless exported. All names from external packages must be imported. There can be no cycles in the dependency graph of Bosatsu packages.</p>
<pre><code>package Animals/Favorites
export mammals, birds

mammals = [&quot;elephant&quot;, &quot;whale&quot;, &quot;dog&quot;]

birds = [&quot;African grey parrot&quot;, &quot;macaw&quot;]

</code></pre>
<p>In some other package:</p>
<pre><code>package Animals/Report

from Animals/Favorites import mammals
export most_fav

most_fav = match mammals:
  [head, *tail]: head
  []: &quot;who knows?&quot;

</code></pre>
<p>We export types slightly differently. We can export just the type, or the type and the constructors. To export the type and the constructors use <code>Type()</code> where as <code>Type</code> exports only the type to be visible.</p>
<pre><code><br/>package Great/Types

export ClearOption(), OpaqueOption, foldO, noneO, someO

enum ClearOption:
  CNone, CSome(get)

enum OpaqueOption:
  ONone, OSome(get)

noneO = ONone
def someO(a): OSome(a)

def foldO(oo, if_none, if_some):
  match oo:
    ONone: if_none
    oSome(a): if_some(a)

</code></pre>
<p>Here ClearOption exports all its constructors so they can be pattern matched upon. In the OpaqueOption example, we export functions to create the opaque option, and fold function to tear it down, but we can&rsquo;t explicitly pattern match on the types.</p>
<p>Sometimes such opacity is useful to enforce modularity.</p>
<h2><a href="#external-functions-and-values" name="external-functions-and-values" class="anchor"><span class="anchor-link"></span></a>External functions and values</h2>
<p>There is syntax for declaring external values and functions. This is obviously dangerous since it gives the user a chance to violate totality. Use with caution.</p>
<p>An example function we cannot implement in bosatsu is:</p>
<pre><code>def int_loop(int_v: Int, state: a, fn: Int -&gt; a -&gt; (Int, a)) -&gt; a:
  if cmp_Int(int_v, 0) matches GT:
    (next_i, next_state) = fn(int_v, state)
    if cmp_Int(next_i, int_v) matches LT:
      # make sure we always decrease int_v
      int_loop(next_i, next_state, fn)
    else:
      next_state
  else:
    a
</code></pre>
<p>We cannot write this function, even though it is total, because Bosatsu cannot prove that the loop terminates. The only recursions we can do are on values that are substructures of inputs in the same position. This gives a simple proof that the loop will terminate.</p>
<p>Instead, we implement this function in Predef as an external def that has to be supplied to the compiler with a promise that it is indeed total.</p>
<pre><code>external def int_loop(intValue: Int, state: a, fn: Int -&gt; a -&gt; TupleCons[Int, TupleCons[a, Unit]]) -&gt; a
</code></pre>
<p>External values and types work exactly like internally defined types from any other point of view.</p>
<div class="source-github">
The source code for this page can be found <a href="https://github.com/johnynek/bosatsu/tree/master/docs/src/main/paradox/language_guide.md">here</a>.
</div>

<div class="nav-next">
<p><strong>Next:</strong> <a href="generating_json.html">Generating JSON from Bosatsu Values</a></p>
</div>
</div>
<div class="large-3 show-for-large column" data-sticky-container>
<nav class="sidebar sticky" data-sticky data-anchor="docs" data-sticky-on="large">
<div class="page-nav">
<div class="nav-title">On this page:</div>
<div class="nav-toc">
<ul>
  <li><a href="language_guide.html#language-guide" class="header">Language Guide</a>
  <ul>
    <li><a href="language_guide.html#literals" class="header">Literals</a></li>
    <li><a href="language_guide.html#variables" class="header">Variables</a></li>
    <li><a href="language_guide.html#pattern-matching" class="header">Pattern Matching</a></li>
    <li><a href="language_guide.html#functions" class="header">Functions</a></li>
    <li><a href="language_guide.html#custom-data-types" class="header">Custom Data Types</a></li>
    <li><a href="language_guide.html#types" class="header">Types</a></li>
    <li><a href="language_guide.html#the-bosatsu-predef" class="header">The Bosatsu Predef</a></li>
    <li><a href="language_guide.html#packages" class="header">Packages</a></li>
    <li><a href="language_guide.html#external-functions-and-values" class="header">External functions and values</a></li>
  </ul></li>
</ul>
</div>
</div>
</nav>
</div>
</div>

</section>
</div>

</div>

<footer class="site-footer">

<section class="site-footer-nav">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 medium-4 large-3 text-center column">
<div class="nav-links">
<ul>
<!-- <li><a href="https://www.example.com/products/">Products</a> -->
</ul>
</div>
</div>

</div>
</div>
</div>
</section>

<section class="site-footer-base">
<div class="expanded row">
<div class="small-12 large-offset-2 large-10 column">
<div class="row site-footer-content">

<div class="small-12 text-center large-9 column">

<!--
<div class="copyright">
<span class="text">&copy; 2021</span>
<a href="https://www.example.com" class="logo">logo</a>
</div>
-->
</div>

</div>
</div>
</div>
</section>
</footer>

</div>
</div>
</div>
</body>

<script type="text/javascript" src="lib/foundation/dist/foundation.min.js"></script>
<script type="text/javascript">jQuery(document).foundation();</script>
<script type="text/javascript" src="js/magellan.js"></script>

<style type="text/css">@import "lib/prettify/prettify.css";</style>
<script type="text/javascript" src="lib/prettify/prettify.js"></script>
<script type="text/javascript" src="lib/prettify/lang-scala.js"></script>
<script type="text/javascript">jQuery(function(){window.prettyPrint && prettyPrint()});</script>
<script type="text/javascript">jQuery(function(jq){initOldVersionWarnings(jq, '0.1.0-SNAPSHOT', '')});</script>


</html>
