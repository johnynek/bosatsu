package Bosatsu/Predef

export [
  Assertion(),
  Bool(),
  Comparison(),
  Int,
  Option(),
  List(),
  String,
  Test(),
  TestSuite(),
  Tuple2(),
  Order,
  Unit(),
  Dict,
  add,
  add_key,
  cmp_Int,
  concat,
  div,
  empty_Dict,
  eq_Int,
  flat_map_List,
  foldLeft,
  gcd_Int,
  get_key,
  int_loop,
  items,
  map_List,
  mod_Int,
  range,
  range_fold,
  remove_key,
  reverse,
  reverse_concat,
  sub,
  string_Order_fn,
  string_Order,
  times,
  trace,
  uncurry2,
  uncurry3,
]

struct Unit
struct Tuple2(first, second)

enum Bool:
  False
  True

enum List:
  EmptyList, NonEmptyList(head: a, tail: List[a])

def foldLeft(lst: List[a], item: b, fn: b -> a -> b) -> b:
  # make the loop function as small as possible
  def loop(lst, item):
    recur lst:
      EmptyList: item
      NonEmptyList(head, tail): loop(tail, fn(item, head))
  loop(lst, item)

def reverse_concat(front: List[a], back: List[a]) -> List[a]:
  foldLeft(front, back, \tail, h -> NonEmptyList(h, tail))

def reverse(as: List[a]) -> List[a]:
  reverse_concat(as, EmptyList)

def map_List(lst: List[a], fn: a -> b) -> List[b]:
  lst.foldLeft(EmptyList, \t, a -> NonEmptyList(fn(a), t)).reverse

def flat_map_List(lst: List[a], fn: a -> List[b]) -> List[b]:
  lst.foldLeft(EmptyList, \t, a -> fn(a).reverse_concat(t)).reverse

def concat(front: List[a], back: List[a]) -> List[a]:
  match back:
    []: front
    _: reverse_concat(reverse(front), back)

def uncurry2(f: t1 -> t2 -> r) -> (t1, t2) -> r:
  \tuple ->
    (x1, x2) = tuple
    f(x1, x2)

def uncurry3(f: t1 -> t2 -> t3 -> r) -> (t1, t2, t3) -> r:
  \tuple ->
    (x1, x2, x3) = tuple
    f(x1, x2, x3)

enum Comparison:
  LT
  EQ
  GT

enum Option:
  None
  Some(v)

struct Order(fn: a -> a -> Comparison)

external struct Dict[k, v]
external def empty_Dict(comp: Order[k]) -> forall v. Dict[k, v]
external def add_key(dict: Dict[k, v], key: k, value: v) -> Dict[k, v]
external def get_key(dict: Dict[k, v], key: k) -> Option[v]
external def remove_key(dict: Dict[k, v], key: k) -> Dict[k, v]
external def items(dict: Dict[k, v]) -> List[(k, v)]

external struct Int

external def add(a: Int, b: Int) -> Int
external def sub(a: Int, b: Int) -> Int
external def times(a: Int, b: Int) -> Int
external def div(a: Int, b: Int) -> Option[Int]
external def eq_Int(a: Int, b: Int) -> Bool
external def gcd_Int(a: Int, b: Int) -> Int
external def cmp_Int(a: Int, b: Int) -> Comparison
external def mod_Int(a: Int, mod: Int) -> Int

external def range(exclusiveUpper: Int) -> List[Int]

# this loops until the returned Int is <= 0 or the returned Int is >= intValue
external def int_loop(intValue: Int, state: a, fn: Int -> a -> Tuple2[Int, Tuple2[a, Unit]]) -> a

def range_fold(inclusiveLower: Int, exclusiveUpper: Int, init: a, fn: a -> Int -> a) -> a:
  diff = exclusiveUpper.sub(inclusiveLower)
  int_loop(diff, init, \diff0, a ->
    idx = exclusiveUpper.sub(diff0)
    a1 = fn(a, idx)
    Tuple2(diff0.sub(1), Tuple2(a1, Unit)))

external struct String
external def string_Order_fn(str0: String, str1: String) -> Comparison
string_Order = Order(string_Order_fn)

struct Assertion(value: Bool, message: String)
struct Test(name: String, assertions: List[Assertion])
struct TestSuite(name: String, tests: List[Test])

external def trace(prefix: String, item: a) -> a
