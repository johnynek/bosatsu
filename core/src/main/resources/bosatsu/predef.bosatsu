package Bosatsu/Predef

export (
  Bool(),
  Char,
  Comparison(),
  Int,
  Float64,
  Option(),
  List(),
  String,
  Test(),
  Tuple1(),
  Tuple2(),
  Tuple3(),
  Tuple4(),
  Tuple5(),
  Tuple6(),
  Tuple7(),
  Tuple8(),
  Tuple9(),
  Tuple10(),
  Tuple11(),
  Tuple12(),
  Tuple13(),
  Tuple14(),
  Tuple15(),
  Tuple16(),
  Tuple17(),
  Tuple18(),
  Tuple19(),
  Tuple20(),
  Tuple21(),
  Tuple22(),
  Tuple23(),
  Tuple24(),
  Tuple25(),
  Tuple26(),
  Tuple27(),
  Tuple28(),
  Tuple29(),
  Tuple30(),
  Tuple31(),
  Tuple32(),
  Order(),
  Unit(),
  Dict,
  add,
  addf,
  add_key,
  build_List,
  char_to_Int,
  char_List_to_String,
  char_to_String,
  cmp_Int,
  cmp_Float64,
  concat,
  concat_String,
  div,
  divf,
  clear_Dict,
  empty_Dict,
  eq_Int,
  flat_map_List,
  foldl_List,
  foldr_List,
  gcd_Int,
  get_key,
  int_loop,
  int_to_Char,
  int_to_String,
  length_String,
  string_to_Int,
  uncons_String,
  items,
  map_List,
  mod_Int,
  shift_left_Int,
  shift_right_Int,
  and_Int,
  or_Int,
  xor_Int,
  not_Int,
  partition_String,
  rpartition_String,
  range,
  range_fold,
  remove_key,
  replicate_List,
  reverse,
  reverse_concat,
  sub,
  subf,
  cmp_String,
  string_Order,
  mul,
  timesf,
  trace,
  uncurry2,
  uncurry3,
)

struct Unit
struct Tuple1[a: +*](item1: a)
struct Tuple2[a: +*, b: +*](item1: a, item2: b)
struct Tuple3[a: +*, b: +*, c: +*](item1: a, item2: b, item3: c)
struct Tuple4[a: +*, b: +*, c: +*, d: +*](item1: a, item2: b, item3: c, item4: d)
struct Tuple5[a: +*, b: +*, c: +*, d: +*, e: +*](item1: a, item2: b, item3: c, item4: d, item5: e)
struct Tuple6[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f)
struct Tuple7[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g)
struct Tuple8[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h)
struct Tuple9[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i)
struct Tuple10[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j)
struct Tuple11[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k)
struct Tuple12[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l)
struct Tuple13[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m)
struct Tuple14[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n)
struct Tuple15[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o)
struct Tuple16[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p)
struct Tuple17[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q)
struct Tuple18[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r)
struct Tuple19[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s)
struct Tuple20[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t)
struct Tuple21[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u)
struct Tuple22[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v)
struct Tuple23[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w)
struct Tuple24[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x)
struct Tuple25[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*, y: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x, item25: y)
struct Tuple26[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*, y: +*, z: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x, item25: y, item26: z)
struct Tuple27[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*, y: +*, z: +*, a0: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x, item25: y, item26: z, item27: a0)
struct Tuple28[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*, y: +*, z: +*, a0: +*, b0: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x, item25: y, item26: z, item27: a0, item28: b0)
struct Tuple29[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*, y: +*, z: +*, a0: +*, b0: +*, c0: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x, item25: y, item26: z, item27: a0, item28: b0, item29: c0)
struct Tuple30[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*, y: +*, z: +*, a0: +*, b0: +*, c0: +*, d0: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x, item25: y, item26: z, item27: a0, item28: b0, item29: c0, item30: d0)
struct Tuple31[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*, y: +*, z: +*, a0: +*, b0: +*, c0: +*, d0: +*, e0: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x, item25: y, item26: z, item27: a0, item28: b0, item29: c0, item30: d0, item31: e0)
struct Tuple32[a: +*, b: +*, c: +*, d: +*, e: +*, f: +*, g: +*, h: +*, i: +*, j: +*, k: +*, l: +*, m: +*, n: +*, o: +*, p: +*, q: +*, r: +*, s: +*, t: +*, u: +*, v: +*, w: +*, x: +*, y: +*, z: +*, a0: +*, b0: +*, c0: +*, d0: +*, e0: +*, f0: +*](item1: a, item2: b, item3: c, item4: d, item5: e, item6: f, item7: g, item8: h, item9: i, item10: j, item11: k, item12: l, item13: m, item14: n, item15: o, item16: p, item17: q, item18: r, item19: s, item20: t, item21: u, item22: v, item23: w, item24: x, item25: y, item26: z, item27: a0, item28: b0, item29: c0, item30: d0, item31: e0, item32: f0)

enum Bool:
  False, True

#############
# Support for built-in lists
#############
enum List:
  EmptyList, NonEmptyList(head: a, tail: List[a])

def build_List[a](fn: forall b. (((a, b) -> b), b) -> b) -> List[a]:
    fn(NonEmptyList, [])

def foldr_List(list: List[a], fn: (a, b) -> b, acc: b) -> b:
    def loop(list: List[a]) -> b:
        recur list:
            case []: acc
            case [h, *t]: fn(h, loop(t))
    loop(list)

# we can rewrite: foldr_List(build_List(g), f, x) => g(f, x)
# see "A Shortcut to Deforestation" by Gill et. al.

def foldl_List(lst: List[a], item: b, fn: (b, a) -> b) -> b:
  # make the loop function as small as possible
  def loop(lst, item):
    recur lst:
      case []: item
      case [head, *tail]: loop(tail, fn(item, head))
  loop(lst, item)

def reverse_concat(front: List[a], back: List[a]) -> List[a]:
  foldl_List(front, back, (tail, h) -> [h, *tail])

def reverse(as: List[a]) -> List[a]:
  reverse_concat(as, [])

def concat(front: List[a], back: List[a]) -> List[a]:
  match back:
    case []: front
    case _: reverse_concat(reverse(front), back)

def map_List(lst: List[a], fn: a -> b) -> List[b]:
  lst.foldl_List([], (t, a) -> [fn(a), *t]).reverse()

def flat_map_List(lst: List[a], fn: a -> List[b]) -> List[b]:
  lst.foldl_List([], (t, a) -> fn(a).reverse_concat(t)).reverse()

def replicate_List[a](item: a, cnt: Int) -> List[a]:
  int_loop(cnt, EmptyList, (i, acc) -> (i.sub(1), NonEmptyList(item, acc)))

#############
# Some utilities for dealing with functions
#############

def uncurry2(f: t1 -> t2 -> r) -> (t1, t2) -> r:
  (x1, x2) -> f(x1)(x2)

def uncurry3(f: t1 -> t2 -> t3 -> r) -> (t1, t2, t3) -> r:
  (x1, x2, x3) -> f(x1)(x2)(x3)

#############
# Standardize notion of ordering
#############
enum Comparison:
    LT, EQ, GT

struct Order(to_Fn: (a, a) -> Comparison)

enum Option:
  None, Some(v)

#############
# Int functions
#############
external struct Int
external struct Float64

external def add(a: Int, b: Int) -> Int
external def sub(a: Int, b: Int) -> Int
external def mul(a: Int, b: Int) -> Int
external def div(a: Int, b: Int) -> Int
external def eq_Int(a: Int, b: Int) -> Bool
external def gcd_Int(a: Int, b: Int) -> Int
external def cmp_Int(a: Int, b: Int) -> Comparison
external def mod_Int(a: Int, mod: Int) -> Int
external def shift_left_Int(arg: Int, shift: Int) -> Int
external def shift_right_Int(arg: Int, shift: Int) -> Int
external def and_Int(a: Int, b: Int) -> Int
external def or_Int(a: Int, b: Int) -> Int
external def xor_Int(a: Int, b: Int) -> Int
external def not_Int(a: Int) -> Int
external def addf(a: Float64, b: Float64) -> Float64
external def subf(a: Float64, b: Float64) -> Float64
external def timesf(a: Float64, b: Float64) -> Float64
external def divf(a: Float64, b: Float64) -> Float64
external def cmp_Float64(a: Float64, b: Float64) -> Comparison

# this loops until the returned Int is <= 0 or the returned Int is >= intValue
external def int_loop(intValue: Int, state: a, fn: (Int, a) -> (Int, a)) -> a

def range(exclusiveUpper: Int) -> List[Int]:
  int_loop(exclusiveUpper, [], (i, tail) ->
    inext = i.sub(1)
    (inext, [inext, *tail]))

def range_fold(inclusiveLower: Int, exclusiveUpper: Int, init: a, fn: (a, Int) -> a) -> a:
  diff = exclusiveUpper.sub(inclusiveLower)
  int_loop(diff, init, (diff0, a) ->
    idx = exclusiveUpper.sub(diff0)
    a1 = fn(a, idx)
    (diff0.sub(1), a1))

#############
# String functions
#############
external struct String
external struct Char

external def char_to_String(c: Char) -> String
external def char_to_Int(c: Char) -> Int
external def char_List_to_String(chars: List[Char]) -> String
external def int_to_Char(code_point: Int) -> Option[Char]
external def cmp_String(str0: String, str1: String) -> Comparison
string_Order = Order(cmp_String)
external def concat_String(items: List[String]) -> String

def length_String(s: String) -> Int:
  def loop(rest: String, acc: Int) -> Int:
    recur rest:
      case "":
        acc
      case "$.{_}${tail}":
        loop(tail, acc.add(1))

  loop(s, 0)

# if this returns Some((a, b)) then arg == concat_String([a, sep, b])
# a and b are always proper substrings, so partition_String(a, "") == None
# this matches from the left, so partition_String(a, sep) == None
external def partition_String(arg: String, sep: String) -> Option[(String, String)]
# if this returns Some((a, b)) then arg == concat_String([a, sep, b])
# a and b are always proper substrings, so rpartition_String(a, "") == None
# this matches from the right, so partition_String(b, sep) == None
external def rpartition_String(arg: String, sep: String) -> Option[(String, String)]
# if this returns Some((h, t)) then arg == concat_String([h, t])
# h is exactly one codepoint and t is the remaining suffix
external def uncons_String(arg: String) -> Option[(Char, String)]

external def int_to_String(i: Int) -> String
external def string_to_Int(s: String) -> Option[Int]

external def trace(prefix: String, item: a) -> a

#############
# Support for built-in testing:
#############
enum Test:
  Assertion(value: Bool, message: String)
  TestSuite(name: String, tests: List[Test])

#############
# AVL trees used to implement dictionaries
# these are private implementation details
# and not exported intentionally
#############

enum Tree[a]:
    Empty, Branch(size: Int, height: Int, key: a, left: Tree[a], right: Tree[a])

enum Rotation: LeftRo, NoRo, RightRo

def operator >(i, j):
    cmp_Int(i, j) matches GT

def rotation(left: Int, right: Int, max_diff: Int) -> Rotation:
    if left.sub(right) > max_diff:
        RightRo
    elif right.sub(left) > max_diff:
        LeftRo
    else:
        NoRo

def max(i, j):
    match cmp_Int(i, j):
        case LT: j
        case _: i

# properly balanced trees:
# h < c log_2(n + 2) + b, c ~= 1.44, b ~= -1.33
def height(t: Tree[a]) -> Int:
    match t:
        case Empty: 0
        case Branch { height: h, ... }: h

def size(t: Tree[a]) -> Int:
    match t:
        case Empty: 0
        case Branch { size: s, ... }: s

def branch(sz, item, left, right):
    h = max(height(left), height(right))
    Branch(sz, h.add(1), item, left, right)

def branch_s(item, left, right):
    sz = size(left).add(size(right)).add(1)
    branch(sz, item, left, right)

def balance(t: Tree[a]) -> Tree[a]:
    match t:
        case Empty: Empty
        case Branch { key: top_item, left, right, ... }:
          match rotation(height(left), height(right), 1):
              case NoRo: t
              case RightRo:
                  match left:
                      case Empty: t
                      case Branch { key: inner_item, left, right: left_right, ... }:
                          match rotation(height(left), height(left_right), 0):
                              case RightRo | NoRo:
                                  res_r = branch_s(top_item, left_right, right)
                                  branch_s(inner_item, left, res_r)
                              case LeftRo:
                                  match left_right:
                                      case Empty: trace("unreachable", t)
                                      case Branch { key: lrv, left: left_right_left, right: left_right_right, ...}:
                                          res_r = branch_s(top_item, left_right_right, right)
                                          res_l = branch_s(inner_item, left, left_right_left)
                                          branch_s(lrv, res_l, res_r)
              case LeftRo:
                  match right:
                      case Empty: t
                      case Branch { key: inner_item, left: right_left, right: right_right, ...}:
                          match rotation(height(right_left), height(right_right), 0):
                              case LeftRo | NoRo:
                                  res_l = branch_s(top_item, left, right_left)
                                  branch_s(inner_item, res_l, right_right)
                              case RightRo:
                                  match right_left:
                                      case Empty: trace("unreachable", t)
                                      case Branch { key: right_left_key, right: right_left_left, left: right_left_right, ... }:
                                          branch_s(
                                            right_left_key,
                                            branch_s(top_item, left, right_left_left),
                                            branch_s(inner_item, right_left_right, right_right))

def add_item(ord: Order[a], tree: Tree[a], item: a) -> Tree[a]:
    Order(fn) = ord

    def loop(tree: Tree[a]) -> Tree[a]:
        recur tree:
            case Empty: Branch(1, 1, item, Empty, Empty)
            case Branch(s, h, item0, left, right):
                match fn(item, item0):
                    case EQ: Branch(s, h, item, left, right)
                    case LT:
                        left = loop(left)
                        branch(s.add(1), item0, left, right).balance()
                    case GT:
                        right = loop(right)
                        branch(s.add(1), item0, left, right).balance()

    loop(tree)

def contains(ord: Order[a], tree: Tree[a], item: a) -> Option[a]:
    Order(fn) = ord

    def loop(tree: Tree[a]) -> Option[a]:
        recur tree:
            case Empty: None
            case Branch { key, left, right, ... }:
                match fn(item, key):
                    case EQ: Some(key)
                    case LT: loop(left)
                    case GT: loop(right)

    loop(tree)

def remove_item(ord: Order[a], tree: Tree[a], item: a) -> Tree[a]:
    Order(fn) = ord

    def loop(tree: Tree[a]) -> Tree[a]:
        recur tree:
            case Empty: Empty
            case Branch { size, key, left, right, ... }:
                match fn(item, key):
                    case EQ:
                        match right:
                            case Empty: left
                            case _:
                                right = loop(right)
                                branch(size.sub(1), key, left, right).balance()
                    case LT:
                        left = loop(left)
                        branch(size.sub(1), key, left, right).balance()
                    case GT:
                        right = loop(right)
                        branch(size.sub(1), key, left, right).balance()

    loop(tree)

def fold_right_Tree(t: Tree[a], right_v: b, fn: (a, b) -> b) -> b:
    recur t:
        case Empty: right_v
        case Branch { key, left, right, ... }:
            v1 = fold_right_Tree(right, right_v, fn)
            v2 = fn(key, v1)
            fold_right_Tree(left, v2, fn)


#############
# Standard dictionaries
#############

struct Dict[k, v: +*](order: forall a. Order[(k, a)], tree: Tree[(k, v)])

def empty_Dict(comp: Order[k]) -> forall v. Dict[k, v]:
    Order(fn) = comp
    pair_ord = Order(((k1, _), (k2, _)) -> fn(k1, k2))
    Dict(pair_ord, Empty)

def add_key(dict: Dict[k, v], key: k, value: v) -> Dict[k, v]:
    Dict(ord, tree) = dict
    new_tree = add_item(ord, tree, (key, value))
    Dict(ord, new_tree)

def get_key(dict: Dict[k, v], key: k) -> Option[v]:
    Dict(ord, tree) = dict
    match tree:
        case Branch { key: (_, v), ... }:
            # fill in a fake v
            match contains(ord, tree, (key, v)):
                case Some((_, v)): Some(v)
                case None: None
        case Empty: None

def remove_key(dict: Dict[k, v], key: k) -> Dict[k, v]:
    Dict(ord, tree) = dict
    match tree:
        case Branch { key: (_, v), ... }:
            # fill in a fake v
            tree1 = remove_item(ord, tree, (key, v))
            Dict(ord, tree1)
        case Empty: dict

def items(dict: Dict[k, v]) -> List[(k, v)]:
    Dict(_, tree) = dict
    tree.fold_right_Tree([], (kv, tail) -> [kv, *tail])

def clear_Dict(dict: Dict[k, v]) -> Dict[k, v]:
    Dict(ord, _) = dict
    Dict(ord, Empty)
