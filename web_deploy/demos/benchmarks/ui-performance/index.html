<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BosatsuUI vs React vs Elm Performance Benchmark</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
      crossorigin
    ></script>
    <style>
      * {
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      body {
        max-width: 1000px;
        margin: 40px auto;
        padding: 20px;
        background: #f5f5f5;
      }
      h1 {
        color: #333;
        margin-bottom: 8px;
      }
      .subtitle {
        color: #666;
        margin-bottom: 24px;
      }
      .card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 16px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      h2 {
        margin: 0 0 16px 0;
        color: #333;
        font-size: 18px;
      }
      h3 {
        margin: 16px 0 8px 0;
        color: #666;
        font-size: 14px;
      }
      button {
        background: #4a90d9;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        margin-right: 8px;
        margin-bottom: 8px;
      }
      button:hover {
        background: #357abd;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .results {
        font-family: monospace;
        white-space: pre;
        overflow-x: auto;
        font-size: 12px;
        line-height: 1.5;
      }
      .benchmark-area {
        display: none;
      }
      .progress {
        color: #666;
        font-style: italic;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 16px 0;
      }
      th,
      td {
        padding: 8px 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background: #f0f0f0;
        font-weight: 600;
      }
      .faster {
        color: #2e7d32;
        font-weight: bold;
      }
      .slower {
        color: #c62828;
      }
      .speedup {
        background: #e8f5e9;
        padding: 16px;
        border-radius: 6px;
        margin-top: 16px;
      }
      .speedup h3 {
        margin-top: 0;
        color: #2e7d32;
      }
      .explainer {
        background: #fff3e0;
        padding: 16px;
        border-radius: 6px;
        margin-bottom: 16px;
      }
      .explainer h3 {
        margin-top: 0;
        color: #e65100;
      }
      .explainer code {
        background: #ffe0b2;
        padding: 2px 6px;
        border-radius: 3px;
      }
    </style>
  </head>
  <body>
    <h1>BosatsuUI vs React vs Elm Performance Benchmark</h1>
    <p class="subtitle">Comparing direct DOM binding updates vs Virtual DOM diffing</p>

    <div class="card explainer">
      <h3>How BosatsuUI Works (No Virtual DOM!)</h3>
      <p>
        BosatsuUI uses <strong>compile-time static analysis</strong> to extract
        <code>statePath -> DOMProperty</code> bindings. When state changes:
      </p>
      <ol>
        <li>Look up bindings for the changed state path (O(1) map lookup)</li>
        <li>Apply <code>element.property = value</code> directly (O(1) per binding)</li>
        <li>No virtual DOM creation, no tree diffing, no reconciliation</li>
      </ol>
      <p>
        <strong>React/Elm approach:</strong> Create new virtual DOM tree -> Diff against old tree
        -> Generate patches -> Apply patches. This is O(n) where n is tree size.
      </p>
    </div>

    <div class="card">
      <h2>Benchmark Controls</h2>
      <button id="run-all" onclick="runAllBenchmarks()">Run All Benchmarks</button>
      <button id="run-single" onclick="runSingleBenchmark()">Single Updates</button>
      <button id="run-batch" onclick="runBatchBenchmark()">Batch Updates</button>
      <button id="run-list" onclick="runListBenchmark()">List Updates (1000 items)</button>
      <button id="run-targeted" onclick="runTargetedBenchmark()">Targeted Updates</button>
      <p class="progress" id="progress"></p>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div id="results">Click a button above to run benchmarks</div>
    </div>

    <!-- Hidden benchmark areas -->
    <div id="bosatsu-root" class="benchmark-area"></div>
    <div id="react-root" class="benchmark-area"></div>
    <div id="elm-root" class="benchmark-area"></div>

    <script>
      // =========================================================================
      // BosatsuUI Runtime (matching bosatsu-ui-runtime.js)
      // =========================================================================

      class BosatsuRuntime {
        constructor(bindings, root, options = {}) {
          this.bindings = bindings
          this.root = root
          this.state = {}
          this.bindingMap = new Map()
          this.elementCache = new Map()
          this.batchMode = options.batchMode || 'immediate'

          // Batching state
          this.pendingPaths = new Map()
          this.flushScheduled = false
          this.inBatch = false

          // Build binding map: statePath (as string) -> bindings[]
          bindings.forEach((b) => {
            const key = b.statePath.join('.')
            const existing = this.bindingMap.get(key) || []
            this.bindingMap.set(key, [...existing, b])
          })
        }

        mount(initialState) {
          this.state = initialState
        }

        setState(path, value) {
          // Update state immediately
          this.state = this.setAtPath(this.state, path, value)

          // Queue DOM update
          if (this.batchMode === 'immediate' && !this.inBatch) {
            this.applyBindingsForPath(path)
          } else {
            const key = path.join('.')
            this.pendingPaths.set(key, path)
            this.scheduleFlush()
          }
        }

        scheduleFlush() {
          if (this.flushScheduled || this.inBatch) return
          this.flushScheduled = true
          queueMicrotask(() => this.flushPendingUpdates())
        }

        flushPendingUpdates() {
          this.flushScheduled = false
          this.pendingPaths.forEach((path) => this.applyBindingsForPath(path))
          this.pendingPaths.clear()
        }

        flush() {
          this.flushPendingUpdates()
        }

        batch(fn) {
          this.inBatch = true
          try {
            fn()
          } finally {
            this.inBatch = false
            this.flushPendingUpdates()
          }
        }

        applyBindingsForPath(path) {
          const key = path.join('.')
          const bindings = this.bindingMap.get(key) || []

          bindings.forEach((binding) => {
            // Use element cache for O(1) lookup
            let element = this.elementCache.get(binding.elementId)
            if (!element) {
              const selector = binding.elementId.startsWith('[')
                ? binding.elementId
                : `[data-bosatsu-id="${binding.elementId}"]`
              element = this.root.querySelector(selector) ||
                        this.root.querySelector(`#${binding.elementId}`)
              if (element) this.elementCache.set(binding.elementId, element)
            }

            if (element) {
              let newValue = this.getAtPath(this.state, binding.statePath || path)
              if (binding.transform) {
                newValue = binding.transform(newValue)
              }

              switch (binding.property) {
                case 'textContent':
                  element.textContent = String(newValue)
                  break
                case 'className':
                  element.className = String(newValue)
                  break
                case 'value':
                  element.value = String(newValue)
                  break
                case 'checked':
                  element.checked = Boolean(newValue)
                  break
                default:
                  if (binding.property.startsWith('style.')) {
                    const prop = binding.property.slice(6)
                    element.style[prop] = String(newValue)
                  }
              }
            }
          })
        }

        getAtPath(obj, path) {
          return path.reduce((o, k) => o?.[k], obj)
        }

        setAtPath(obj, path, value) {
          if (path.length === 0) return value
          const [first, ...rest] = path
          return {
            ...obj,
            [first]: rest.length === 0 ? value : this.setAtPath(obj[first] || {}, rest, value),
          }
        }
      }

      // =========================================================================
      // React Simulation (Virtual DOM overhead)
      // =========================================================================

      class ReactSimulation {
        constructor(root) {
          this.root = root
          this.state = {}
          this.prevVDOM = null
        }

        mount(initialState) {
          this.state = initialState
        }

        createVDOM(state) {
          // Simulate creating a virtual DOM tree
          return {
            type: 'div',
            props: { id: 'app' },
            children: Object.entries(state).map(([k, v]) => ({
              type: 'span',
              props: { id: k },
              children: [String(v)],
            })),
          }
        }

        diffAndPatch(prev, next) {
          // Simulate tree traversal and diffing overhead
          const walk = (node) => {
            if (!node || typeof node !== 'object') return 1
            if (Array.isArray(node.children)) {
              return 1 + node.children.reduce((sum, c) => sum + walk(c), 0)
            }
            return 1
          }
          walk(next)
        }

        setState(path, value) {
          this.state = this.setAtPath(this.state, path, value)
          const newVDOM = this.createVDOM(this.state)
          this.diffAndPatch(this.prevVDOM, newVDOM)

          // Actual DOM update
          const element = this.root.querySelector(`#${path[0]}`)
          if (element) element.textContent = String(value)

          this.prevVDOM = newVDOM
        }

        setAtPath(obj, path, value) {
          if (path.length === 0) return value
          const [first, ...rest] = path
          return {
            ...obj,
            [first]: rest.length === 0 ? value : this.setAtPath(obj[first] || {}, rest, value),
          }
        }
      }

      // =========================================================================
      // Elm Simulation (Pure functional VDOM)
      // =========================================================================

      class ElmSimulation {
        constructor(root) {
          this.root = root
          this.model = {}
          this.prevView = null
        }

        mount(initialState) {
          this.model = initialState
        }

        // Pure view function
        view(model) {
          return {
            tag: 'div',
            attrs: { id: 'app' },
            children: Object.entries(model).map(([k, v]) => ({
              tag: 'span',
              attrs: { id: k },
              children: [String(v)],
            })),
          }
        }

        // Elm's diff algorithm
        diff(prev, next) {
          // Walk both trees
          const walk = (node) => {
            if (!node || typeof node !== 'object') return 1
            if (Array.isArray(node.children)) {
              return 1 + node.children.reduce((sum, c) => sum + walk(c), 0)
            }
            return 1
          }
          walk(next)
        }

        // Update function
        update(msg, model) {
          return { ...model, [msg.path[0]]: msg.value }
        }

        setState(path, value) {
          this.model = this.update({ path, value }, this.model)
          const newView = this.view(this.model)
          this.diff(this.prevView, newView)

          // Actual DOM update
          const element = this.root.querySelector(`#${path[0]}`)
          if (element) element.textContent = String(value)

          this.prevView = newView
        }
      }

      // =========================================================================
      // Benchmark Utilities
      // =========================================================================

      function runThroughputBenchmark(name, durationMs, fn, waitFn) {
        return new Promise(async (resolve) => {
          let ops = 0

          // Warmup
          for (let i = 0; i < 100; i++) {
            fn()
          }
          if (waitFn) await waitFn()

          const benchStart = performance.now()
          while (performance.now() - benchStart < durationMs) {
            fn()
            if (waitFn) await waitFn()
            ops++
          }
          const elapsed = performance.now() - benchStart

          const opsPerSec = (ops / elapsed) * 1000
          const avgMs = elapsed / ops

          resolve({
            name,
            iterations: ops,
            totalMs: elapsed,
            avgMs,
            minMs: avgMs,
            maxMs: avgMs,
            opsPerSec,
          })
        })
      }

      const flushPromise = () =>
        new Promise((resolve) => {
          const channel = new MessageChannel()
          channel.port1.onmessage = resolve
          channel.port2.postMessage(null)
        })

      function setProgress(msg) {
        document.getElementById('progress').textContent = msg
      }

      function formatResults(results) {
        let html = '<table>'
        html +=
          '<tr><th>Framework</th><th>Avg (ms)</th><th>Ops/sec</th><th>Speedup vs React</th></tr>'

        const reactResult = results.find((r) => r.name.includes('React'))
        const reactAvg = reactResult ? reactResult.avgMs : 1

        results.forEach((r) => {
          const speedup = reactAvg / r.avgMs
          const speedupText = r.name.includes('React')
            ? '1.00x (baseline)'
            : `${speedup.toFixed(2)}x ${speedup > 1 ? 'faster' : 'slower'}`
          const cls = speedup > 1.5 ? 'faster' : speedup < 0.9 ? 'slower' : ''

          html += `<tr class="${cls}">
            <td>${r.name}</td>
            <td>${r.avgMs.toFixed(4)}</td>
            <td>${Math.round(r.opsPerSec).toLocaleString()}</td>
            <td>${speedupText}</td>
          </tr>`
        })

        html += '</table>'
        return html
      }

      // =========================================================================
      // Single Update Benchmark
      // =========================================================================

      async function runSingleBenchmark() {
        setProgress('Running single update benchmark...')
        const results = []
        const durationMs = 2000

        // Setup BosatsuUI
        const bosatsuRoot = document.getElementById('bosatsu-root')
        bosatsuRoot.innerHTML = '<div id="app"><span id="count" data-bosatsu-id="count">0</span></div>'

        const bosatsu = new BosatsuRuntime(
          [{ elementId: 'count', property: 'textContent', statePath: ['count'] }],
          bosatsuRoot,
          { batchMode: 'immediate' }
        )
        bosatsu.mount({ count: 0 })

        results.push(
          await runThroughputBenchmark(
            'BosatsuUI (direct binding)',
            durationMs,
            () => bosatsu.setState(['count'], Math.floor(Math.random() * 1000)),
            null
          )
        )

        // Setup React simulation
        const reactRoot = document.getElementById('react-root')
        reactRoot.innerHTML = '<div id="app"><span id="count">0</span></div>'

        const react = new ReactSimulation(reactRoot)
        react.mount({ count: 0 })

        results.push(
          await runThroughputBenchmark(
            'React (VDOM diff)',
            durationMs,
            () => react.setState(['count'], Math.floor(Math.random() * 1000)),
            null
          )
        )

        // Setup Elm simulation
        const elmRoot = document.getElementById('elm-root')
        elmRoot.innerHTML = '<div id="app"><span id="count">0</span></div>'

        const elm = new ElmSimulation(elmRoot)
        elm.mount({ count: 0 })

        results.push(
          await runThroughputBenchmark(
            'Elm (pure VDOM)',
            durationMs,
            () => elm.setState(['count'], Math.floor(Math.random() * 1000)),
            null
          )
        )

        let html = '<h3>Single Property Update</h3>'
        html += formatResults(results)
        html += `<div class="speedup">
          <h3>Why BosatsuUI is faster:</h3>
          <p>BosatsuUI looks up the binding for <code>['count']</code> and directly sets
          <code>element.textContent = value</code>. React/Elm must create new VDOM trees
          and diff them even for a single property change.</p>
        </div>`

        document.getElementById('results').innerHTML = html
        setProgress('')
      }

      // =========================================================================
      // Batch Update Benchmark
      // =========================================================================

      async function runBatchBenchmark() {
        setProgress('Running batch update benchmark...')
        const results = []
        const durationMs = 2000
        const batchSize = 100

        // BosatsuUI with batching
        const bosatsuRoot = document.getElementById('bosatsu-root')
        bosatsuRoot.innerHTML = '<div id="app"><span id="count" data-bosatsu-id="count">0</span></div>'

        const bosatsu = new BosatsuRuntime(
          [{ elementId: 'count', property: 'textContent', statePath: ['count'] }],
          bosatsuRoot,
          { batchMode: 'immediate' }
        )
        bosatsu.mount({ count: 0 })

        results.push(
          await runThroughputBenchmark(
            `BosatsuUI (${batchSize} updates batched)`,
            durationMs,
            () => {
              bosatsu.batch(() => {
                for (let i = 0; i < batchSize; i++) {
                  bosatsu.setState(['count'], i)
                }
              })
            },
            null
          )
        )

        // React simulation
        const reactRoot = document.getElementById('react-root')
        reactRoot.innerHTML = '<div id="app"><span id="count">0</span></div>'

        const react = new ReactSimulation(reactRoot)
        react.mount({ count: 0 })

        results.push(
          await runThroughputBenchmark(
            `React (${batchSize} setState calls)`,
            durationMs,
            () => {
              for (let i = 0; i < batchSize; i++) {
                react.setState(['count'], i)
              }
            },
            null
          )
        )

        // Elm simulation
        const elmRoot = document.getElementById('elm-root')
        elmRoot.innerHTML = '<div id="app"><span id="count">0</span></div>'

        const elm = new ElmSimulation(elmRoot)
        elm.mount({ count: 0 })

        results.push(
          await runThroughputBenchmark(
            `Elm (${batchSize} updates)`,
            durationMs,
            () => {
              for (let i = 0; i < batchSize; i++) {
                elm.setState(['count'], i)
              }
            },
            null
          )
        )

        let html = `<h3>Batch Updates (${batchSize} updates per batch)</h3>`
        html += formatResults(results)
        html += `<div class="speedup">
          <h3>Why BosatsuUI is faster:</h3>
          <p>BosatsuUI's batch() deduplicates updates to the same path - 100 updates to
          <code>['count']</code> result in 1 DOM write. React/Elm create 100 VDOM trees
          (though React 18 batches renders, it still diffs).</p>
        </div>`

        document.getElementById('results').innerHTML = html
        setProgress('')
      }

      // =========================================================================
      // List Update Benchmark
      // =========================================================================

      async function runListBenchmark() {
        setProgress('Running list update benchmark...')
        const results = []
        const durationMs = 2000
        const listSize = 1000

        // BosatsuUI with per-item bindings
        const bosatsuRoot = document.getElementById('bosatsu-root')
        let html = '<ul id="list">'
        for (let i = 0; i < listSize; i++) {
          html += `<li id="item-${i}" data-bosatsu-id="item-${i}">${i}</li>`
        }
        html += '</ul>'
        bosatsuRoot.innerHTML = html

        // Create bindings for each item
        const bindings = []
        const initialState = { items: {} }
        for (let i = 0; i < listSize; i++) {
          bindings.push({
            elementId: `item-${i}`,
            property: 'textContent',
            statePath: ['items', String(i)],
          })
          initialState.items[i] = i
        }

        const bosatsu = new BosatsuRuntime(bindings, bosatsuRoot, { batchMode: 'immediate' })
        bosatsu.mount(initialState)

        results.push(
          await runThroughputBenchmark(
            `BosatsuUI (1 of ${listSize} items)`,
            durationMs,
            () => {
              const index = Math.floor(Math.random() * listSize)
              bosatsu.setState(['items', String(index)], Math.floor(Math.random() * 1000))
            },
            null
          )
        )

        // React list simulation
        const reactRoot = document.getElementById('react-root')
        reactRoot.innerHTML = `<ul id="list">${Array.from({ length: listSize }, (_, i) =>
          `<li id="item-${i}">${i}</li>`).join('')}</ul>`

        class ReactList {
          constructor(root, size) {
            this.root = root
            this.items = Array.from({ length: size }, (_, i) => i)
            this.prevVDOM = this.createVDOM()
          }

          createVDOM() {
            return {
              type: 'ul',
              children: this.items.map((item, i) => ({
                type: 'li',
                key: i,
                children: [String(item)],
              })),
            }
          }

          reconcile(prev, next) {
            // O(n) list reconciliation
            const keyMap = new Map()
            prev?.children?.forEach((child, i) => keyMap.set(child.key, i))
            next?.children?.forEach((child) => {
              const oldIndex = keyMap.get(child.key)
              // Compare operation
            })
          }

          updateItem(index, value) {
            this.items = [...this.items.slice(0, index), value, ...this.items.slice(index + 1)]
            const newVDOM = this.createVDOM()
            this.reconcile(this.prevVDOM, newVDOM)

            const li = this.root.querySelector(`#item-${index}`)
            if (li) li.textContent = String(value)

            this.prevVDOM = newVDOM
          }
        }

        const reactList = new ReactList(reactRoot, listSize)

        results.push(
          await runThroughputBenchmark(
            `React (1 of ${listSize} items, keyed)`,
            durationMs,
            () => {
              const index = Math.floor(Math.random() * listSize)
              reactList.updateItem(index, Math.floor(Math.random() * 1000))
            },
            null
          )
        )

        // Elm list simulation
        const elmRoot = document.getElementById('elm-root')
        elmRoot.innerHTML = `<ul id="list">${Array.from({ length: listSize }, (_, i) =>
          `<li id="item-${i}">${i}</li>`).join('')}</ul>`

        class ElmList {
          constructor(root, size) {
            this.root = root
            this.model = { items: Array.from({ length: size }, (_, i) => i) }
            this.prevView = this.view()
          }

          view() {
            return {
              tag: 'ul',
              children: this.model.items.map((item, i) => ({
                tag: 'li',
                key: i,
                children: [String(item)],
              })),
            }
          }

          diff(prev, next) {
            // O(n) keyed diff
            next?.children?.forEach((child) => {
              // Compare operation per child
            })
          }

          updateItem(index, value) {
            this.model = {
              items: [...this.model.items.slice(0, index), value, ...this.model.items.slice(index + 1)],
            }
            const newView = this.view()
            this.diff(this.prevView, newView)

            const li = this.root.querySelector(`#item-${index}`)
            if (li) li.textContent = String(value)

            this.prevView = newView
          }
        }

        const elmList = new ElmList(elmRoot, listSize)

        results.push(
          await runThroughputBenchmark(
            `Elm (1 of ${listSize} items, keyed)`,
            durationMs,
            () => {
              const index = Math.floor(Math.random() * listSize)
              elmList.updateItem(index, Math.floor(Math.random() * 1000))
            },
            null
          )
        )

        let resultHtml = `<h3>List Item Update (${listSize}-item list)</h3>`
        resultHtml += formatResults(results)
        resultHtml += `<div class="speedup">
          <h3>Why BosatsuUI is faster:</h3>
          <p>BosatsuUI has a direct binding for each list item: <code>['items', '42']</code>
          maps to <code>#item-42.textContent</code>. Updating one item is O(1).</p>
          <p>React/Elm must create a new 1000-element VDOM array and reconcile it to find
          the one changed item - O(n) even with keyed reconciliation.</p>
        </div>`

        document.getElementById('results').innerHTML = resultHtml
        setProgress('')
      }

      // =========================================================================
      // Targeted Update Benchmark
      // =========================================================================

      async function runTargetedBenchmark() {
        setProgress('Running targeted update benchmark...')
        const results = []
        const durationMs = 2000
        const keys = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']

        // BosatsuUI - direct binding per element
        const bosatsuRoot = document.getElementById('bosatsu-root')
        bosatsuRoot.innerHTML = `<div id="app">${keys.map((k) =>
          `<div id="section-${k}"><span id="value-${k}" data-bosatsu-id="value-${k}">0</span></div>`
        ).join('')}</div>`

        const bindings = keys.map((k) => ({
          elementId: `value-${k}`,
          property: 'textContent',
          statePath: [k],
        }))
        const initialState = Object.fromEntries(keys.map((k) => [k, 0]))

        const bosatsu = new BosatsuRuntime(bindings, bosatsuRoot, { batchMode: 'immediate' })
        bosatsu.mount(initialState)

        results.push(
          await runThroughputBenchmark(
            'BosatsuUI (1 of 10 elements)',
            durationMs,
            () => {
              const key = keys[Math.floor(Math.random() * keys.length)]
              bosatsu.setState([key], Math.floor(Math.random() * 1000))
            },
            null
          )
        )

        // React - must diff entire tree
        const reactRoot = document.getElementById('react-root')
        reactRoot.innerHTML = `<div id="app">${keys.map((k) =>
          `<div id="section-${k}"><span id="value-${k}">0</span></div>`
        ).join('')}</div>`

        const react = new ReactSimulation(reactRoot)
        react.mount(Object.fromEntries(keys.map((k) => [k, 0])))

        // Override createVDOM for complex tree
        react.createVDOM = function(state) {
          return {
            type: 'div',
            props: { id: 'app' },
            children: keys.map((k) => ({
              type: 'div',
              props: { id: `section-${k}` },
              children: [{
                type: 'span',
                props: { id: `value-${k}` },
                children: [String(state[k] || 0)],
              }],
            })),
          }
        }

        results.push(
          await runThroughputBenchmark(
            'React (1 of 10 elements, full diff)',
            durationMs,
            () => {
              const key = keys[Math.floor(Math.random() * keys.length)]
              react.setState([key], Math.floor(Math.random() * 1000))
            },
            null
          )
        )

        // Elm - must diff entire tree
        const elmRoot = document.getElementById('elm-root')
        elmRoot.innerHTML = `<div id="app">${keys.map((k) =>
          `<div id="section-${k}"><span id="value-${k}">0</span></div>`
        ).join('')}</div>`

        const elm = new ElmSimulation(elmRoot)
        elm.mount(Object.fromEntries(keys.map((k) => [k, 0])))

        // Override view for complex tree
        elm.view = function(model) {
          return {
            tag: 'div',
            attrs: { id: 'app' },
            children: keys.map((k) => ({
              tag: 'div',
              attrs: { id: `section-${k}` },
              children: [{
                tag: 'span',
                attrs: { id: `value-${k}` },
                children: [String(model[k] || 0)],
              }],
            })),
          }
        }

        results.push(
          await runThroughputBenchmark(
            'Elm (1 of 10 elements, full diff)',
            durationMs,
            () => {
              const key = keys[Math.floor(Math.random() * keys.length)]
              elm.setState([key], Math.floor(Math.random() * 1000))
            },
            null
          )
        )

        let html = '<h3>Targeted Update (update 1 element in 10-element tree)</h3>'
        html += formatResults(results)
        html += `<div class="speedup">
          <h3>Why BosatsuUI excels at targeted updates:</h3>
          <p>This is BosatsuUI's sweet spot. Updating state path <code>['c']</code>
          triggers a direct O(1) lookup and update of <code>#value-c.textContent</code>.</p>
          <p>React/Elm must recreate and diff the entire tree structure to discover that
          only one span changed. The larger the tree, the bigger BosatsuUI's advantage.</p>
        </div>`

        document.getElementById('results').innerHTML = html
        setProgress('')
      }

      // =========================================================================
      // Run All Benchmarks
      // =========================================================================

      async function runAllBenchmarks() {
        const buttons = document.querySelectorAll('button')
        buttons.forEach((b) => (b.disabled = true))

        await runSingleBenchmark()
        await new Promise((r) => setTimeout(r, 500))

        await runBatchBenchmark()
        await new Promise((r) => setTimeout(r, 500))

        await runListBenchmark()
        await new Promise((r) => setTimeout(r, 500))

        await runTargetedBenchmark()

        buttons.forEach((b) => (b.disabled = false))
        setProgress('All benchmarks complete!')
      }
    </script>
  </body>
</html>
