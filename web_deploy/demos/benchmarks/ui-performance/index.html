<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BosatsuUI vs React Performance Benchmark</title>
    <!-- Real React 18 -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Real BosatsuUI Runtime -->
    <script src="../../../core/src/main/resources/bosatsu-ui-runtime.js"></script>
    <style>
      * {
        box-sizing: border-box;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      }
      body {
        max-width: 1000px;
        margin: 40px auto;
        padding: 20px;
        background: #f5f5f5;
      }
      h1 {
        color: #333;
        margin-bottom: 8px;
      }
      .subtitle {
        color: #666;
        margin-bottom: 24px;
      }
      .card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 16px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      h2 {
        margin: 0 0 16px 0;
        color: #333;
        font-size: 18px;
      }
      h3 {
        margin: 16px 0 8px 0;
        color: #666;
        font-size: 14px;
      }
      button {
        background: #4a90d9;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        margin-right: 8px;
        margin-bottom: 8px;
      }
      button:hover {
        background: #357abd;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      .benchmark-area {
        display: none;
      }
      .progress {
        color: #666;
        font-style: italic;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 16px 0;
      }
      th,
      td {
        padding: 8px 12px;
        text-align: left;
        border-bottom: 1px solid #ddd;
      }
      th {
        background: #f0f0f0;
        font-weight: 600;
      }
      .faster {
        color: #2e7d32;
        font-weight: bold;
      }
      .slower {
        color: #c62828;
      }
      .speedup {
        background: #e8f5e9;
        padding: 16px;
        border-radius: 6px;
        margin-top: 16px;
      }
      .speedup h3 {
        margin-top: 0;
        color: #2e7d32;
      }
      .explainer {
        background: #fff3e0;
        padding: 16px;
        border-radius: 6px;
        margin-bottom: 16px;
      }
      .explainer h3 {
        margin-top: 0;
        color: #e65100;
      }
      .explainer code {
        background: #ffe0b2;
        padding: 2px 6px;
        border-radius: 3px;
      }
      .warning {
        background: #fff8e1;
        border: 1px solid #ffc107;
        padding: 12px;
        border-radius: 6px;
        margin-bottom: 16px;
      }
      .warning strong {
        color: #f57c00;
      }
      .config-section {
        background: #e3f2fd;
        padding: 16px;
        border-radius: 6px;
        margin-bottom: 16px;
      }
      .config-section h3 {
        margin-top: 0;
        color: #1565c0;
      }
      .config-row {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 12px;
      }
      .config-row label {
        min-width: 120px;
        font-weight: 500;
      }
      .config-row input[type="range"] {
        flex: 1;
        max-width: 200px;
      }
      .config-row select {
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid #ccc;
      }
      .config-value {
        min-width: 80px;
        font-family: monospace;
        color: #1565c0;
      }
      .dom-writes {
        background: #fce4ec;
        padding: 12px;
        border-radius: 6px;
        margin-top: 16px;
      }
      .dom-writes h4 {
        margin: 0 0 8px 0;
        color: #c2185b;
      }
      .dom-writes-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }
      .dom-writes-item {
        display: flex;
        justify-content: space-between;
        padding: 4px 8px;
        background: white;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <h1>BosatsuUI vs React Performance Benchmark</h1>
    <p class="subtitle">Comparing direct DOM binding updates vs Virtual DOM diffing</p>

    <div class="warning">
      <strong>Fair Benchmark:</strong> This benchmark uses actual React 18 (ReactDOM.createRoot, useState) -
      not a simulation. Both frameworks perform real DOM updates. Run multiple times for consistent results.
    </div>

    <div class="card config-section">
      <h3>BosatsuUI Batching Configuration</h3>
      <div class="config-row">
        <label for="batch-size">Batch Size:</label>
        <input type="range" id="batch-size" min="1" max="1000" value="1000" />
        <span class="config-value" id="batch-size-value">Infinity</span>
      </div>
      <div class="config-row">
        <label for="flush-delay">Flush Delay:</label>
        <select id="flush-delay">
          <option value="microtask" selected>microtask (default)</option>
          <option value="0">0 (synchronous)</option>
          <option value="16">16ms (frame-aligned)</option>
        </select>
      </div>
      <p style="margin: 8px 0 0; color: #666; font-size: 13px;">
        <strong>Tip:</strong> Set batch size to "Infinity" and flush delay to "microtask" for fair comparison with React's automatic batching.
        Use batch size "1" with "0 (synchronous)" for immediate updates (like drag-and-drop scenarios).
      </p>
    </div>

    <div class="card explainer">
      <h3>How BosatsuUI Works (No Virtual DOM!)</h3>
      <p>
        BosatsuUI uses <strong>compile-time static analysis</strong> to extract
        <code>statePath -> DOMProperty</code> bindings. When state changes:
      </p>
      <ol>
        <li>Look up bindings for the changed state path (O(1) map lookup)</li>
        <li>Apply <code>element.property = value</code> directly (O(1) per binding)</li>
        <li>No virtual DOM creation, no tree diffing, no reconciliation</li>
      </ol>
      <p>
        <strong>React approach:</strong> Create new virtual DOM tree -> Diff against old tree
        -> Generate patches -> Apply patches. This is O(n) where n is component tree size.
      </p>
      <p>
        <strong>With batching:</strong> BosatsuUI collects updates in a Map (last-write-wins monoid),
        then applies them all at once. This gives React 18-style automatic batching while
        skipping VDOM diffing entirely.
      </p>
    </div>

    <div class="card">
      <h2>Benchmark Controls</h2>
      <button id="run-all" onclick="runAllBenchmarks()">Run All Benchmarks</button>
      <button id="run-single" onclick="runSingleBenchmark()">Single Updates</button>
      <button id="run-list" onclick="runListBenchmark()">List Updates (100 items)</button>
      <button id="run-targeted" onclick="runTargetedBenchmark()">Targeted Updates</button>
      <p class="progress" id="progress"></p>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div id="results">Click a button above to run benchmarks</div>
    </div>

    <!-- Hidden benchmark areas -->
    <div id="bosatsu-root" class="benchmark-area"></div>
    <div id="react-root" class="benchmark-area"></div>

    <script>
      // =========================================================================
      // Configuration UI
      // =========================================================================

      const batchSizeSlider = document.getElementById('batch-size');
      const batchSizeValue = document.getElementById('batch-size-value');
      const flushDelaySelect = document.getElementById('flush-delay');

      function getBatchSize() {
        const val = parseInt(batchSizeSlider.value);
        return val >= 1000 ? Infinity : val;
      }

      function getFlushDelay() {
        const val = flushDelaySelect.value;
        return val === 'microtask' ? 'microtask' : parseInt(val);
      }

      batchSizeSlider.addEventListener('input', () => {
        const val = getBatchSize();
        batchSizeValue.textContent = val === Infinity ? 'Infinity' : val;
        applyBosatsuConfig();
      });

      flushDelaySelect.addEventListener('change', applyBosatsuConfig);

      function applyBosatsuConfig() {
        if (window.BosatsuUI && window.BosatsuUI.configure) {
          window.BosatsuUI.configure({
            batchSize: getBatchSize(),
            flushDelay: getFlushDelay()
          });
        }
      }

      // Apply initial config
      applyBosatsuConfig();

      // =========================================================================
      // DOM Write Tracking
      // =========================================================================

      let bosatsuDOMWrites = 0;
      let reactDOMWrites = 0;

      function resetDOMWriteCounts() {
        bosatsuDOMWrites = 0;
        reactDOMWrites = 0;
      }

      // =========================================================================
      // Real React 18 Counter Component
      // =========================================================================

      const { useState, useCallback, memo, useEffect } = React;

      function ReactCounter() {
        const [count, setCount] = useState(0);

        window._reactSetCount = (val) => {
          setCount(val);
          reactDOMWrites++;
        };

        return React.createElement('div', { id: 'react-counter-app' },
          React.createElement('span', { id: 'react-count' }, count)
        );
      }

      const ListItem = memo(function ListItem({ id, value }) {
        return React.createElement('li', { id: `react-item-${id}` }, value);
      });

      function ReactList({ size }) {
        const [items, setItems] = useState(() =>
          Array.from({ length: size }, (_, i) => i)
        );

        window._reactSetItems = (fn) => {
          setItems(fn);
          reactDOMWrites++;
        };
        window._reactItems = items;

        return React.createElement('ul', { id: 'react-list' },
          items.map((value, i) =>
            React.createElement(ListItem, { key: i, id: i, value })
          )
        );
      }

      function ReactTargeted() {
        const keys = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];
        const [values, setValues] = useState(() =>
          Object.fromEntries(keys.map(k => [k, 0]))
        );

        window._reactSetValues = (fn) => {
          setValues(fn);
          reactDOMWrites++;
        };

        return React.createElement('div', { id: 'react-targeted-app' },
          keys.map(k =>
            React.createElement('div', { key: k, id: `react-section-${k}` },
              React.createElement('span', { id: `react-value-${k}` }, values[k])
            )
          )
        );
      }

      // =========================================================================
      // BosatsuUI Wrapper (uses real runtime from bosatsu-ui-runtime.js)
      // =========================================================================

      class BosatsuBenchmarkWrapper {
        constructor(bindings, root) {
          this.root = root;
          this.bindings = {};

          // Convert array bindings to the format expected by the runtime
          bindings.forEach((b) => {
            const key = b.statePath.join('.');
            if (!this.bindings[key]) {
              this.bindings[key] = [];
            }
            this.bindings[key].push({
              elementId: b.elementId,
              property: b.property,
              statePath: b.statePath
            });
          });
        }

        mount(initialState) {
          window.BosatsuUI._initRuntime(this.bindings, initialState);
          // Build element cache
          this.root.querySelectorAll('[id]').forEach(el => {
            window.BosatsuUI._elementCache.set(`[data-bosatsu-id="${el.id}"]`, el);
            window.BosatsuUI._elementCache.set(`#${el.id}`, el);
          });
        }

        setState(path, value) {
          window.BosatsuUI.setState(path, value);
          bosatsuDOMWrites++;
        }
      }

      // =========================================================================
      // Benchmark Utilities
      // =========================================================================

      async function runThroughputBenchmark(name, durationMs, setupFn, updateFn) {
        await new Promise(r => setTimeout(r, 50));

        let ops = 0;

        // Warmup
        for (let i = 0; i < 100; i++) {
          updateFn(i);
        }
        await new Promise(r => setTimeout(r, 50));

        const benchStart = performance.now();
        while (performance.now() - benchStart < durationMs) {
          updateFn(ops);
          ops++;
        }
        const elapsed = performance.now() - benchStart;

        // Let React/BosatsuUI flush final updates
        await new Promise(r => setTimeout(r, 50));

        const opsPerSec = (ops / elapsed) * 1000;
        const avgMs = elapsed / ops;

        return {
          name,
          iterations: ops,
          totalMs: elapsed,
          avgMs,
          opsPerSec,
        };
      }

      function setProgress(msg) {
        document.getElementById('progress').textContent = msg;
      }

      function formatResults(results, bosatsuWrites, reactWrites) {
        let html = '<table>';
        html +=
          '<tr><th>Framework</th><th>Avg (ms)</th><th>Ops/sec</th><th>Speedup vs React</th></tr>';

        const reactResult = results.find((r) => r.name.includes('React'));
        const reactAvg = reactResult ? reactResult.avgMs : 1;

        results.forEach((r) => {
          const speedup = reactAvg / r.avgMs;
          const speedupText = r.name.includes('React')
            ? '1.00x (baseline)'
            : `${speedup.toFixed(2)}x ${speedup > 1 ? 'faster' : 'slower'}`;
          const cls = speedup > 1.5 ? 'faster' : speedup < 0.9 ? 'slower' : '';

          html += `<tr class="${cls}">
            <td>${r.name}</td>
            <td>${r.avgMs.toFixed(4)}</td>
            <td>${Math.round(r.opsPerSec).toLocaleString()}</td>
            <td>${speedupText}</td>
          </tr>`;
        });

        html += '</table>';

        // Add DOM writes comparison
        html += `<div class="dom-writes">
          <h4>DOM Write Counts (setState calls)</h4>
          <div class="dom-writes-grid">
            <div class="dom-writes-item">
              <span>BosatsuUI:</span>
              <strong>${bosatsuWrites.toLocaleString()}</strong>
            </div>
            <div class="dom-writes-item">
              <span>React 18:</span>
              <strong>${reactWrites.toLocaleString()}</strong>
            </div>
          </div>
          <p style="margin: 8px 0 0; font-size: 12px; color: #666;">
            Note: With batching, multiple setState calls may result in fewer actual DOM updates.
            React 18 batches all setState calls in a tick into one render.
          </p>
        </div>`;

        return html;
      }

      // =========================================================================
      // Single Update Benchmark
      // =========================================================================

      async function runSingleBenchmark() {
        setProgress('Running single update benchmark...');
        const results = [];
        const durationMs = 2000;

        resetDOMWriteCounts();
        applyBosatsuConfig();

        // Setup BosatsuUI
        const bosatsuRoot = document.getElementById('bosatsu-root');
        bosatsuRoot.innerHTML = '<div id="bosatsu-counter-app"><span id="bosatsu-count">0</span></div>';

        const bosatsu = new BosatsuBenchmarkWrapper(
          [{ elementId: 'bosatsu-count', property: 'textContent', statePath: ['count'] }],
          bosatsuRoot
        );
        bosatsu.mount({ count: 0 });

        results.push(
          await runThroughputBenchmark(
            'BosatsuUI (direct binding)',
            durationMs,
            null,
            (i) => bosatsu.setState(['count'], i % 10000)
          )
        );
        const bosatsuWrites = bosatsuDOMWrites;

        // Setup REAL React 18
        const reactRoot = document.getElementById('react-root');
        reactRoot.innerHTML = '';
        const root = ReactDOM.createRoot(reactRoot);
        root.render(React.createElement(ReactCounter));

        await new Promise(r => setTimeout(r, 100));

        resetDOMWriteCounts();
        results.push(
          await runThroughputBenchmark(
            'React 18 (VDOM)',
            durationMs,
            null,
            (i) => window._reactSetCount(i % 10000)
          )
        );
        const reactWrites = reactDOMWrites;

        root.unmount();

        const config = window.BosatsuUI.getConfig();
        let html = '<h3>Single Property Update</h3>';
        html += `<p style="color: #666; margin-bottom: 8px;">BosatsuUI config: batchSize=${config.batchSize === Infinity ? '∞' : config.batchSize}, flushDelay=${config.flushDelay}</p>`;
        html += formatResults(results, bosatsuWrites, reactWrites);
        html += `<div class="speedup">
          <h3>Why BosatsuUI is faster:</h3>
          <p>BosatsuUI looks up the binding for <code>['count']</code> and directly sets
          <code>element.textContent = value</code>. React must schedule a re-render,
          create a new VDOM tree, diff it, and apply patches.</p>
          <p>With batching enabled (batchSize=Infinity), BosatsuUI collects updates in a Map
          and flushes once per microtask—same as React 18's automatic batching—but skips
          VDOM diffing entirely.</p>
        </div>`;

        document.getElementById('results').innerHTML = html;
        setProgress('');
      }

      // =========================================================================
      // List Update Benchmark
      // =========================================================================

      async function runListBenchmark() {
        setProgress('Running list update benchmark...');
        const results = [];
        const durationMs = 2000;
        const listSize = 100;

        resetDOMWriteCounts();
        applyBosatsuConfig();

        const bosatsuRoot = document.getElementById('bosatsu-root');
        let html = '<ul id="bosatsu-list">';
        for (let i = 0; i < listSize; i++) {
          html += `<li id="bosatsu-item-${i}">${i}</li>`;
        }
        html += '</ul>';
        bosatsuRoot.innerHTML = html;

        const bindings = [];
        const initialState = { items: {} };
        for (let i = 0; i < listSize; i++) {
          bindings.push({
            elementId: `bosatsu-item-${i}`,
            property: 'textContent',
            statePath: ['items', String(i)],
          });
          initialState.items[i] = i;
        }

        const bosatsu = new BosatsuBenchmarkWrapper(bindings, bosatsuRoot);
        bosatsu.mount(initialState);

        results.push(
          await runThroughputBenchmark(
            `BosatsuUI (1 of ${listSize} items)`,
            durationMs,
            null,
            (i) => {
              const index = i % listSize;
              bosatsu.setState(['items', String(index)], i % 10000);
            }
          )
        );
        const bosatsuWrites = bosatsuDOMWrites;

        const reactRoot = document.getElementById('react-root');
        reactRoot.innerHTML = '';
        const root = ReactDOM.createRoot(reactRoot);
        root.render(React.createElement(ReactList, { size: listSize }));

        await new Promise(r => setTimeout(r, 100));

        resetDOMWriteCounts();
        results.push(
          await runThroughputBenchmark(
            `React 18 (1 of ${listSize} items, memo)`,
            durationMs,
            null,
            (i) => {
              const index = i % listSize;
              window._reactSetItems(prev => {
                const copy = [...prev];
                copy[index] = i % 10000;
                return copy;
              });
            }
          )
        );
        const reactWrites = reactDOMWrites;

        root.unmount();

        const config = window.BosatsuUI.getConfig();
        let resultHtml = `<h3>List Item Update (${listSize}-item list)</h3>`;
        resultHtml += `<p style="color: #666; margin-bottom: 8px;">BosatsuUI config: batchSize=${config.batchSize === Infinity ? '∞' : config.batchSize}, flushDelay=${config.flushDelay}</p>`;
        resultHtml += formatResults(results, bosatsuWrites, reactWrites);
        resultHtml += `<div class="speedup">
          <h3>Why BosatsuUI is faster:</h3>
          <p>BosatsuUI has a direct binding for each list item: <code>['items', '42']</code>
          maps to <code>#bosatsu-item-42.textContent</code>. Updating one item is O(1).</p>
          <p>React must create a new array, re-render the parent, and even with <code>memo()</code>
          must check each of ${listSize} children to determine which changed.</p>
        </div>`;

        document.getElementById('results').innerHTML = resultHtml;
        setProgress('');
      }

      // =========================================================================
      // Targeted Update Benchmark
      // =========================================================================

      async function runTargetedBenchmark() {
        setProgress('Running targeted update benchmark...');
        const results = [];
        const durationMs = 2000;
        const keys = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'];

        resetDOMWriteCounts();
        applyBosatsuConfig();

        const bosatsuRoot = document.getElementById('bosatsu-root');
        bosatsuRoot.innerHTML = `<div id="bosatsu-targeted-app">${keys.map((k) =>
          `<div id="bosatsu-section-${k}"><span id="bosatsu-value-${k}">0</span></div>`
        ).join('')}</div>`;

        const bindings = keys.map((k) => ({
          elementId: `bosatsu-value-${k}`,
          property: 'textContent',
          statePath: [k],
        }));
        const initialState = Object.fromEntries(keys.map((k) => [k, 0]));

        const bosatsu = new BosatsuBenchmarkWrapper(bindings, bosatsuRoot);
        bosatsu.mount(initialState);

        results.push(
          await runThroughputBenchmark(
            'BosatsuUI (1 of 10 elements)',
            durationMs,
            null,
            (i) => {
              const key = keys[i % keys.length];
              bosatsu.setState([key], i % 10000);
            }
          )
        );
        const bosatsuWrites = bosatsuDOMWrites;

        const reactRoot = document.getElementById('react-root');
        reactRoot.innerHTML = '';
        const root = ReactDOM.createRoot(reactRoot);
        root.render(React.createElement(ReactTargeted));

        await new Promise(r => setTimeout(r, 100));

        resetDOMWriteCounts();
        results.push(
          await runThroughputBenchmark(
            'React 18 (1 of 10 elements)',
            durationMs,
            null,
            (i) => {
              const key = keys[i % keys.length];
              window._reactSetValues(prev => ({ ...prev, [key]: i % 10000 }));
            }
          )
        );
        const reactWrites = reactDOMWrites;

        root.unmount();

        const config = window.BosatsuUI.getConfig();
        let html = '<h3>Targeted Update (update 1 element in 10-element tree)</h3>';
        html += `<p style="color: #666; margin-bottom: 8px;">BosatsuUI config: batchSize=${config.batchSize === Infinity ? '∞' : config.batchSize}, flushDelay=${config.flushDelay}</p>`;
        html += formatResults(results, bosatsuWrites, reactWrites);
        html += `<div class="speedup">
          <h3>Why BosatsuUI excels at targeted updates:</h3>
          <p>This is BosatsuUI's sweet spot. Updating state path <code>['c']</code>
          triggers a direct O(1) lookup and update of <code>#bosatsu-value-c.textContent</code>.</p>
          <p>React must re-render the parent component and reconcile all 10 children,
          even though only one value changed.</p>
        </div>`;

        document.getElementById('results').innerHTML = html;
        setProgress('');
      }

      // =========================================================================
      // Run All Benchmarks
      // =========================================================================

      async function runAllBenchmarks() {
        const buttons = document.querySelectorAll('button');
        buttons.forEach((b) => (b.disabled = true));

        document.getElementById('results').innerHTML = '<p>Running benchmarks... this may take a while.</p>';

        await runSingleBenchmark();
        await new Promise((r) => setTimeout(r, 500));

        await runListBenchmark();
        await new Promise((r) => setTimeout(r, 500));

        await runTargetedBenchmark();

        buttons.forEach((b) => (b.disabled = false));
        setProgress('All benchmarks complete!');
      }
    </script>
  </body>
</html>
